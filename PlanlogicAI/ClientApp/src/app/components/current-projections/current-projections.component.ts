import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { ClientService } from '../../services/client.service';
import { ToastyService } from 'ng2-toasty';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/Observable/forkJoin';
import { Client, BasicDetails } from './../../models/Client';
import { LifestyleAsset } from './../../models/LifestyleAsset';
import { Property } from './../../models/Property';
import { CommonService } from '../../services/common.service';
import { CashFlowService } from '../../services/cashFlow.service';
import { InvestmentService } from '../../services/investment.service';
import { PropertyService } from '../../services/property.service';
import { SuperService } from '../../services/super.service';
import { Super } from './../../models/Super';
import { SuperAssumptionsService } from '../../services/superAssumptions.service';
import { LiabilityService } from '../../services/liability.service';
import { Liability, LiabilityDetails } from './../../models/Liability';
import { PensionService } from '../../services/pension.service';
import { PensionAssumptionsService } from '../../services/pensionAssumptions.service';
import { LifestyleAssetService } from '../../services/lifestyleAsset.service';
import { CentrelinkAssumptionsService } from '../../services/centrelinkAssumptions.service';

import { CashflowExpenditureComponent } from '../cashflow-expenditure/cashflow-expenditure.component';
import { CashFlow } from '../../models/CashFlow';
import { Investment, InvestmentDetails } from '../../models/Investment';
import * as $ from 'jquery';
import { Pension } from '../../models/Pension';

@Component({
  selector: 'app-current-projections',
  templateUrl: './current-projections.component.html',
  styleUrls: ['./current-projections.component.css']
})
export class CurrentProjectionsComponent implements OnInit {

    //Common declaration
    financialAssetList: any;
    projection: any;
    clientDetails: any = {};
     sub: any;
    clientAge: number = 0;
    partnerAge: number = 0;
    years: any[] = [];
    clientRetirementYear: number = 0;
    partnerRetirementYear: number = 0;
    marginalTaxRates: any[] = [];
    generalAssumptions: any = [];
    sgcRates: any[] = [];
    superAssumptions: any = [];
    preservationAge: any = [];
    qualifyingAge: any = [];
    minimumPensionDrawdown: any = [];
    //total: number = 10; //TODO: verify

    //CashFlow declaration
    cashFlowIncome: CashFlow[] = [];
    cashFlowExpenditure: CashFlow[] = [];
    period: number = 0;

    cfiClient: any = [];
    cfiPartner: any = [];
    cfeClient: any = [];
    cfePartner: any = [];
    cfeJoint: any = [];
     inflow: any[] = [];
     outflow: any[] = [];
     netCashFlow: any[] = [];
     netAsset: any[] = [];

     inflowOptimized: any[] = [];
     outflowOptimized: any[] = [];
     netCashFlowOptimized: any[] = [];
     netAssetOptimized: any[] = [];

    //Tax declaration
    EPRTClient: any = [];
    EPRTPartner: any = [];
    EPRTJoint: any = [];
     Income: any[] = [];
     ClientDeductions: any[] = [];
     PartnerDeductions: any[] = [];
     IncomeOptimized: any[] = [];
     ClientDeductionsOptimized: any[] = [];
     PartnerDeductionsOptimized: any[] = [];


    //Centrelink Declaration

     CentrelinkTotal: any[] = [];


     clientTaxableIncome: any[] = [];
     clientLossAdjustment: any[] = [];
     clientNRTaxOffset: any[] = [];
     clientRTaxOffset: any[] = [];
     clientMedicareLevy: any[] = [];
     clientGrossTax: any[] = [];

     partnerTaxableIncome: any[] = [];
     partnerLossAdjustment: any[] = [];
     partnerNRTaxOffset: any[] = [];
     partnerRTaxOffset: any[] = [];
     partnerMedicareLevy: any[] = [];

     GrossTax: any[] = [];
     NetPayable: any[] = [];
     TotalPayable: any[] = [];


     clientTaxableIncomeOptimized: any[] = [];
     clientLossAdjustmentOptimized: any[] = [];
     clientNRTaxOffsetOptimized: any[] = [];
     clientRTaxOffsetOptimized: any[] = [];
     clientMedicareLevyOptimized: any[] = [];
     clientGrossTaxOptimized: any[] = [];

     partnerTaxableIncomeOptimized: any[] = [];
     partnerLossAdjustmentOptimized: any[] = [];
     partnerNRTaxOffsetOptimized: any[] = [];
     partnerRTaxOffsetOptimized: any[] = [];
     partnerMedicareLevyOptimized: any[] = [];

     GrossTaxOptimized: any[] = [];
     NetPayableOptimized: any[] = [];
     TotalPayableOptimized: any[] = [];

    //FinancialAssets declaration
    investmentCW: any = [];
    investmentContribution: any = [];
    investmentWithdrawal: any = [];
    investments: Investment[] = [];
    investmentClient: any = [];
    investmentClientOptimized: any = [];
    investmentPartner: any = [];
    investmentPartnerOptimized: any = [];
    investmentJoint: any = [];
    investmentJointOptimized: any = [];
     FAtotal: any[] = [];
     BeginningValue: any[] = [];
     FAtotalOptimized: any[] = [];
     BeginningValueOptimized: any[] = [];
    investmentContributionOptimized: any = [];
    investmentWithdrawalOptimized: any = [];


    //Properties declaration
    propertiesClient: any = [];
    propertiesPartner: any = [];
    propertiesJoint: any = [];
    properties: Property[] = [];
     Propertiestotal: any[] = [];
     PropertiesValue: any[] = [];
     PropertiestotalOptimized: any[] = [];
     PropertiesValueOptimized: any[] = [];

    //Super declaration
    superClient: any = [];
    superPartner: any = [];
    supers: Super[] = [];
     Supertotal: any[] = [];
     SuperValue: any[] = [];
    superDetails: any = [];
    superSS: any = [];
    superPNC: any = [];
    superSpouse: any = [];
    superLumpSum: any = [];
     SupertotalOptimized: any[] = [];
     SuperValueOptimized: any[] = [];

    //liabilities declaration
    liabilityDD: any = [];
    liabilityDrawDown : any = [];
    liabilities: Liability[] = [];
    liabilityClient: any = [];
    liabilityPartner: any = [];
    liabilityJoint: any = [];
     LBtotal: any[] = [];
     LBValue: any[] = [];

     LBtotalOptimized: any[] = [];
     LBValueOptimized: any[] = [];

    //pension declaration
    pensionDD: any = [];
    pensionDrawDown: any = [];
    pensions: Pension[] = [];
    pensionClient: any = [];
    pensionPartner: any = [];
     Pensiontotal: any[] = [];
     PensionValue: any[] = [];
     PensiontotalOptimized: any[] = [];
     PensionValueOptimized: any[] = [];
    owner: any = [];


    lifestyleAssets: LifestyleAsset[] = [];
    lifestyleClient: any = [];
    lifestylePartner: any = [];
    lifestyleJoint: any = [];
     lifestyles: any = [];
     LATotal: any = [];

     lifestylesOptimized: any = [];
     LATotalOptimized: any = [];

    assetAssumptions: any = [];
     
    investmentDetailsTest: any = {
        investmentId: 0,
        clientId: 0,
        type: 'Domestic Cash',
        name: 'Investment Portfolio',
        owner: 'Client',
        value: 0,
        growth: 0.00,
        income: 0.00,
        franked: 0.00,
        productFees: 0.0000,
        costBase: 0,
        reinvest: 'Y',
        centrelink: 'N',
        startDateType: 'Existing',
        startDate: 0,
        endDateType: 'Retain',
        endDate: 0
    };


    //Overview
     taxableIncomes: any = [];
     nonTaxableIncomes: any = [];
     living: any = [];
     saving: any = [];
     lifestyleOverview: any = [];
     investmentOverview: any = [];
     superOverview: any = [];
     pensionOverview: any = [];
     liabilityOverview: any = [];

     totaltaxableIncomes: any = [];
     totalnonTaxableIncomes: any = [];
     totalliving: any = [];
     totalsaving: any = []; 
     totallifestyleOverview: any = [];
     totalinvestmentOverview: any = [];
     totalsuperOverview: any = [];
     totalpensionOverview: any = [];
     totalliabilityOverview: any = [];

     netAssetArray: number[] = [];
     netAssetOptimizedArray: number[] = [];

    public lineChartData: Array<any> = [{ data: [], label: '' }, { data: [], label: ''}];
       
    public lineChartLabels: Array<any> = [];
    public lineChartOptions: any = {
        responsive: true,
        maintainAspectRatio: false
    };
    public lineChartColors: Array<any> = [
        { // grey
            backgroundColor: 'rgba(198,98,95,0.2)',
            borderColor: 'rgba(198,98,95,1)',
            pointBackgroundColor: 'rgba(198,98,95,1)',
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: 'rgba(198,98,95,0.8)'
        },
        { // dark grey
            backgroundColor: 'rgba(62,117,182,0.2)',
            borderColor: 'rgba(62,117,182,1)',
            pointBackgroundColor: 'rgba(62,117,182,1)',
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: 'rgba(62,117,182,0.8)'
        }
       //{ // grey
       //     backgroundColor: 'rgba(148,159,177,0.2)',
       //     borderColor: 'rgba(148,159,177,1)',
       //     pointBackgroundColor: 'rgba(148,159,177,1)',
       //     pointBorderColor: '#fff',
       //     pointHoverBackgroundColor: '#fff',
       //     pointHoverBorderColor: 'rgba(148,159,177,0.8)'
       // },
       // { // dark grey
       //     backgroundColor: 'rgba(77,83,96,0.2)',
       //     borderColor: 'rgba(77,83,96,1)',
       //     pointBackgroundColor: 'rgba(77,83,96,1)',
       //     pointBorderColor: '#fff',
       //     pointHoverBackgroundColor: '#fff',
       //     pointHoverBorderColor: 'rgba(77,83,96,1)'
       // }
    ];
    public lineChartLegend: boolean = true;
    public lineChartType: string = 'line';
     finalStrategies: any[] = [];

  constructor(private route: ActivatedRoute,
      private router: Router, private cashFlowService: CashFlowService,
      private clientService: ClientService, private commonService: CommonService, private investmentService: InvestmentService, private propertyService: PropertyService, private superService: SuperService, private superAssumptionsService: SuperAssumptionsService, private liabilityService: LiabilityService, private pensionService: PensionService, private pensionAssumptionsService: PensionAssumptionsService, private lifestyleService: LifestyleAssetService, private centrelinkAssumptionsService:CentrelinkAssumptionsService) { }

  ngOnInit() {

      this.clientDetails = JSON.parse(localStorage.getItem('ClientDetails') || '{}');
      var yearRange = [];
      yearRange.push("1/7/" + this.clientDetails.startDate);
      for (var i = 1; i < this.clientDetails.period; i++) {
          yearRange.push("1/7/" + Number(this.clientDetails.startDate + i));
      }
      this.lineChartLabels = yearRange;
          //['January', 'February', 'March', 'April', 'May', 'June', 'July'];
   
       

      this.sub = this.route.params.subscribe(params => {
          this.projection = params['id'];
          window.scroll(0, 0);
      });

     // this.selectedClient = JSON.parse(localStorage.getItem('selectedClient') || '{}');
     

      var years = [];
      var sources = [];
      var age: number;
      this.period = this.clientDetails.period + 1;

      this.clientRetirementYear = this.clientDetails.clientRetirementYear;
      this.partnerRetirementYear = this.clientDetails.partnerRetirementYear;


      if (this.clientDetails.maritalStatus == "S") {
          this.owner = ["Client"];
      } else {
          this.owner = ["Client", "Partner", "Joint"]; 
      }


      if (this.clientDetails.clientId) {
          sources.push(this.cashFlowService.getCashFlows(this.clientDetails.clientId, "I"));
          sources.push(this.cashFlowService.getCashFlows(this.clientDetails.clientId, "E"));
          sources.push(this.commonService.getMarginalTaxRates());
          sources.push(this.investmentService.getInvestments(this.clientDetails.clientId));
          sources.push(this.commonService.getGeneralAssumptions());
          sources.push(this.investmentService.getAllInvestmentDetails(this.clientDetails.clientId));
          sources.push(this.propertyService.getProperties(this.clientDetails.clientId));
          sources.push(this.superService.getSupers(this.clientDetails.clientId));
          sources.push(this.superService.getAllSuperDetails(this.clientDetails.clientId));
          sources.push(this.superAssumptionsService.getSgcrates());
          sources.push(this.superAssumptionsService.getSuperAssumptions());
          sources.push(this.liabilityService.getLiabilities(this.clientDetails.clientId));
          sources.push(this.liabilityService.getAllLiabilityDetails(this.clientDetails.clientId));
          sources.push(this.pensionService.getPensions(this.clientDetails.clientId));
          sources.push(this.pensionService.getAllPensionDetails(this.clientDetails.clientId));
          sources.push(this.pensionAssumptionsService.getPreservationAge());
          sources.push(this.pensionAssumptionsService.getMinimumPensionDrawdown());
          sources.push(this.lifestyleService.getLifestyleAssets(this.clientDetails.clientId));
          sources.push(this.commonService.getAssetTypesAssumptions());
          sources.push(this.centrelinkAssumptionsService.getQualifyingAge());
      }

      Observable.forkJoin(sources).subscribe((data: any)=>  {

          if (this.clientDetails.clientId) {
              this.cashFlowIncome = data[0];
              this.cashFlowExpenditure = data[1];
              this.marginalTaxRates = data[2];
              this.investments = data[3];
              this.generalAssumptions = data[4];
              this.investmentCW = data[5];
              this.properties = data[6];
              this.supers = data[7];
              this.superDetails = data[8];
              this.sgcRates = data[9];
              this.superAssumptions = data[10];
              this.liabilities = data[11];
              this.liabilityDD = data[12];
              this.pensions = data[13];
              this.pensionDD = data[14];
              this.preservationAge = data[15];
              this.minimumPensionDrawdown = data[16];
              this.lifestyleAssets = data[17];
              this.assetAssumptions = data[18];
              this.qualifyingAge = data[19];

              this.marginalTaxRates = this.marginalTaxRates.sort(function (obj1: any, obj2: any) {
                  return obj1.index - obj2.index;
              });

              this.sgcRates = this.sgcRates.sort(function (obj1: any, obj2: any) {
                  return obj1.index - obj2.index;
              });

              this.cfiClient = this.cashFlowIncome.filter(c => c.owner === "Client");
              this.cfiPartner = this.cashFlowIncome.filter(c => c.owner === "Partner");

              this.cfeClient = this.cashFlowExpenditure.filter(c => c.owner === "Client");
              this.cfePartner = this.cashFlowExpenditure.filter(c => c.owner === "Partner");
              this.cfeJoint = this.cashFlowExpenditure.filter(c => c.owner === "Joint");

              //PreTaxExpenditures for tax
              this.EPRTClient = this.cashFlowExpenditure.filter(c => c.owner === "Client").filter(r => r.type === "Pre-tax");
              this.EPRTJoint = this.cashFlowExpenditure.filter(c => c.owner === "Joint").filter(r => r.type === "Pre-tax");
              this.EPRTPartner = this.cashFlowExpenditure.filter(c => c.owner === "Partner").filter(r => r.type === "Pre-tax");

              //Investments
              this.investmentClient = this.investments.filter(c => c.owner === "Client");
              this.investmentClientOptimized = this.investments.filter(c => c.owner === "Client");
              this.investmentPartner = this.investments.filter(c => c.owner === "Partner");
              this.investmentPartnerOptimized = this.investments.filter(c => c.owner === "Partner");
              this.investmentJoint = this.investments.filter(c => c.owner === "Joint");
              this.investmentJointOptimized = this.investments.filter(c => c.owner === "Joint");

              //Properties
              this.propertiesClient = this.properties.filter(c => c.owner === "Client");
              this.propertiesPartner = this.properties.filter(c => c.owner === "Partner");
              this.propertiesJoint = this.properties.filter(c => c.owner === "Joint");

              //Supers
              this.superClient = this.supers.filter(c => c.owner === "Client");
              this.superPartner = this.supers.filter(c => c.owner === "Partner");

              //Liabilities
              this.liabilityClient = this.liabilities.filter(c => c.owner === "Client");
              this.liabilityPartner = this.liabilities.filter(c => c.owner === "Partner");
              this.liabilityJoint = this.liabilities.filter(c => c.owner === "Joint");


              //Pensions
              this.pensionClient = this.pensions.filter(c => c.owner === "Client");
              this.pensionPartner = this.pensions.filter(c => c.owner === "Partner");

              this.lifestyleClient = this.lifestyleAssets.filter(c => c.owner === "Client");
              this.lifestylePartner = this.lifestyleAssets.filter(c => c.owner === "Partner");
              this.lifestyleJoint = this.lifestyleAssets.filter(c => c.owner === "Joint");



             

              //Calculate Inflow Values
              var indexRangeInflow: any = [];
              var indexRangeOutflow: any = [];

              var clientEmploymentIncome: any = [];
              var partnerEmploymentIncome: any = [];
            
              //var j = 0;
              var m = 1;
             
              for (var i = 0; i < this.clientDetails.period; i++) {
                  for (var q = 0; q <= 1; q++) {


                      //TO DO : Get Highest.
                      var highestVal: number = 0;
                      var highestValObject: any;
                      //    highestVal = this.investmentClient.find Math.max(this.investmentClient.map((o: any) => o.value));
                      if (this.clientDetails.maritalStatus == "S") {
                          highestValObject = this.investmentClient.filter((c: any) => c.type === "Domestic Cash");
                          if (highestValObject != null && highestValObject.length != 0) {
                              highestVal = highestValObject[0].investmentId;
                          }
                      }
                      else {
                          highestValObject = this.investmentJoint.filter((c: any) => c.type === "Domestic Cash");
                          if (highestValObject != null && highestValObject.length != 0) {
                              highestVal = highestValObject[0].investmentId;
                          }
                          else {
                              highestValObject = this.investmentClient.filter((c: any) => c.type === "Domestic Cash");
                              if (highestValObject != null && highestValObject.length != 0) {
                                  highestVal = highestValObject[0].investmentId;
                              }
                              else {
                                  highestValObject = this.investmentPartner.filter((c: any) => c.type === "Domestic Cash");
                                  if (highestValObject != null && highestValObject.length != 0) {
                                      highestVal = highestValObject[0].investmentId;
                                  }
                              }
                          }
                      }



                      //Client LifeStyles
                      this.lifestyleClient.forEach((x: any) => { // client

                          var obj = this.lifestyles.find((y: any) => y.id === x.lassetId);
                          var obj1: any = {};
                          var purchaseOfAssets: any = {};
                          var saleOfAssets: any = {};
                          var j: number = 0;
                          if (obj == null) {
                              obj = {};
                              j = 0;
                          }
                          else {
                              obj1 = obj.values;
                              purchaseOfAssets = obj.purchaseOfAssetValues;
                              saleOfAssets = obj.saleOfAssetValues;
                              j = obj.increment;
                          }

                          if (q == 0) {
                              obj["owner"] = x.owner;
                              obj["name"] = x.name;

                              obj["id"] = x.lassetId;
                              obj["type"] = x.lassetType;

                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate;
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }


                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }

                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }


                              else if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {

                                  if (x.lassetType == "PrimaryResidence") {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }

                              //Purchase of assets
                              if (x.startDateType != "Existing") {

                                  if (x.startDate == this.clientDetails.startDate + i) {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Sale of assets
                              if (x.endDateType != "Retain") {

                                  if (x.endDate == this.clientDetails.startDate + i) {
                                      if (x.lassetType == "PrimaryResidence") {
                                          if (j == 0) {
                                              saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();

                                          }
                                          else {
                                              saleOfAssets[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                          }
                                          j++;
                                      }
                                      else {
                                          saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }

                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }
                          }

                          obj["values"] = obj1;
                          obj["increment"] = j;
                          obj["purchaseOfAssetValues"] = purchaseOfAssets;
                          obj["saleOfAssetValues"] = saleOfAssets;


                          if (this.lifestyles.find((y: any) => y.id === x.lassetId) != null) {
                              this.lifestyles[this.lifestyles.findIndex((c: any) => c.id === x.lassetId)] = obj;
                          }
                          else {
                              this.lifestyles.push(obj);
                          }

                      })

                      this.lifestylePartner.forEach((x: any) => {

                          var obj = this.lifestyles.find((y: any) => y.id === x.lassetId);
                          var obj1: any = {};
                          var purchaseOfAssets: any = {};
                          var saleOfAssets: any = {};
                          var j: number = 0;
                          if (obj == null) {
                              obj = {};
                              j = 0;
                          }
                          else {
                              obj1 = obj.values;
                              purchaseOfAssets = obj.purchaseOfAssetValues;
                              saleOfAssets = obj.saleOfAssetValues;
                              j = obj.increment;
                          }

                          if (q == 0) {
                              obj["owner"] = x.owner;
                              obj["name"] = x.name;

                              obj["id"] = x.lassetId;
                              obj["type"] = x.lassetType;

                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              else if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (x.lassetType == "PrimaryResidence") {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }

                              //Purchase of assets
                              if (x.startDateType != "Existing") {

                                  if (x.startDate == this.clientDetails.startDate + i) {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Sale of assets
                              if (x.endDateType != "Retain") {

                                  if (x.endDate == this.clientDetails.startDate + i) {
                                      if (x.lassetType == "PrimaryResidence") {
                                          if (j == 0) {
                                              saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();

                                          }
                                          else {
                                              saleOfAssets[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                          }
                                          j++;
                                      }
                                      else {
                                          saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }

                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }
                          }

                          obj["values"] = obj1;
                          obj["increment"] = j;
                          obj["purchaseOfAssetValues"] = purchaseOfAssets;
                          obj["saleOfAssetValues"] = saleOfAssets;


                          if (this.lifestyles.find((y: any) => y.id === x.lassetId) != null) {
                              this.lifestyles[this.lifestyles.findIndex((c: any) => c.id === x.lassetId)] = obj;
                          }
                          else {
                              this.lifestyles.push(obj);
                          }

                      })
                      this.lifestyleJoint.forEach((x: any) => {

                          var obj = this.lifestyles.find((y: any) => y.id === x.lassetId);
                          var obj1: any = {};
                          var purchaseOfAssets: any = {};
                          var saleOfAssets: any = {};
                          var j: number = 0;
                          if (obj == null) {
                              obj = {};
                              j = 0;
                          }
                          else {
                              obj1 = obj.values;
                              purchaseOfAssets = obj.purchaseOfAssetValues;
                              saleOfAssets = obj.saleOfAssetValues;
                              j = obj.increment;
                          }
                          if (q == 0) {
                              obj["owner"] = x.owner;
                              obj["name"] = x.name;

                              obj["id"] = x.lassetId;
                              obj["type"] = x.lassetType;

                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate;
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              else if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (x.lassetType == "PrimaryResidence") {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }

                              //Purchase of assets
                              if (x.startDateType != "Existing") {

                                  if (x.startDate == this.clientDetails.startDate + i) {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Sale of assets
                              if (x.endDateType != "Retain") {

                                  if (x.endDate == this.clientDetails.startDate + i) {
                                      if (x.lassetType == "PrimaryResidence") {
                                          if (j == 0) {
                                              saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();

                                          }
                                          else {
                                              saleOfAssets[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                          }
                                          j++;
                                      }
                                      else {
                                          saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }

                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }
                          }

                          obj["values"] = obj1;
                          obj["increment"] = j;
                          obj["purchaseOfAssetValues"] = purchaseOfAssets;
                          obj["saleOfAssetValues"] = saleOfAssets;


                          if (this.lifestyles.find((y: any) => y.id === x.lassetId) != null) {
                              this.lifestyles[this.lifestyles.findIndex((c: any) => c.id === x.lassetId)] = obj;
                          }
                          else {
                              this.lifestyles.push(obj);
                          }

                      })


                      this.calculateTotalLASaleProceeds("TotalLASales", i);
                      this.calculateTotalLAPropertyExpenses("TotalLAPurchase", i);


                      this.cfiClient.forEach((x: any) => { // client
                          var obj = indexRangeInflow.find((y: any) => y.id === x.cflowId);
                          var obj1: any = {};
                          var j: number = 0;
                          if (obj == null) {
                              obj = {};
                              j = 0;
                          }
                          else {
                              obj1 = obj.values;
                              j = obj.increment;
                          }
                          obj["owner"] = x.owner;
                          obj["name"] = x.cfname;
                          obj["id"] = x.cflowId;
                          obj["type"] = x.type;
                          if (x.startDateType == "Start") {
                              x.startDate = this.clientDetails.startDate
                          }
                          else if (x.startDateType == "Client Retirement") {
                              x.startDate = this.clientDetails.clientRetirementYear - 1;
                          }

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Client Retirement") {
                              x.endDate = this.clientDetails.clientRetirementYear - 1;
                          }

                          if (q == 0) {
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }

                                  j++;

                              }

                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }

                              obj["values"] = obj1;
                              obj["increment"] = j;
                          }

                          if (indexRangeInflow.find((y: any) => y.id === x.cflowId) != null) {
                              indexRangeInflow[indexRangeInflow.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              clientEmploymentIncome[clientEmploymentIncome.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              this.Income[this.Income.findIndex((c: any) => c.id === x.cflowId)] = obj;
                          }
                          else {
                              indexRangeInflow.push(obj);
                              this.Income.push(obj);
                              clientEmploymentIncome.push(obj);
                          }
                      });

                      this.cfiPartner.forEach((x: any) => { // partner
                          if (x.startDateType == "Start") {
                              x.startDate = this.clientDetails.startDate
                          }
                          else if (x.startDateType == "Partner Retirement") {
                              x.startDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Partner Retirement") {
                              x.endDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          var obj = indexRangeInflow.find((y: any) => y.id === x.cflowId);
                          var obj1: any = {};
                          var j: number = 0;
                          if (obj == null) {
                              obj = {};
                              j = 0;
                          }
                          else {
                              obj1 = obj.values;
                              j = obj.increment;
                          }

                          if (q == 0) {
                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;
                              obj["type"] = x.type;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;
                          }

                          if (indexRangeInflow.find((y: any) => y.id === x.cflowId) != null) {
                              indexRangeInflow[indexRangeInflow.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              partnerEmploymentIncome[partnerEmploymentIncome.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              this.Income[this.Income.findIndex((c: any) => c.id === x.cflowId)] = obj;
                          }
                          else {
                              indexRangeInflow.push(obj);
                              this.Income.push(obj);
                              partnerEmploymentIncome.push(obj);
                          }

                      })
                      //    //Todo -TaxIncome Total
                      this.cfiClient.forEach((x: any) => { // client

                          if (x.type != "Non-Taxable") {
                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              //TODO : Reconfirm end date
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }

                              var obj = indexRangeInflow.find((y: any) => y.id === "Tax" + x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = "ClientIncome-tax";
                              obj["name"] = x.cfname;
                              obj["id"] = "Tax" + x.cflowId;

                              if (q == 0) {
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                                  obj["values"] = obj1;
                                  obj["increment"] = j;
                              }

                              if (indexRangeInflow.find((y: any) => y.id === "Tax" + x.cflowId) != null) {
                                  indexRangeInflow[indexRangeInflow.findIndex((c: any) => c.id === "Tax" + x.cflowId)] = obj;
                                  this.Income[this.Income.findIndex((c: any) => c.id === "Tax" + x.cflowId)] = obj;
                              }
                              else {
                                  indexRangeInflow.push(obj);
                                  this.Income.push(obj);
                              }
                          }

                      })
                      this.cfiPartner.forEach((x: any) => { // partner
                          if (x.type != "Non-Taxable") {
                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = indexRangeInflow.find((y: any) => y.id === "Tax" + x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = "PartnerIncome-tax";
                              obj["name"] = x.cfname;
                              obj["id"] = "Tax" + x.cflowId;


                              if (q == 0) {
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                                  obj["values"] = obj1;
                                  obj["increment"] = j;
                              }


                              if (indexRangeInflow.find((y: any) => y.id === "Tax" + x.cflowId) != null) {
                                  indexRangeInflow[indexRangeInflow.findIndex((c: any) => c.id === "Tax" + x.cflowId)] = obj;
                                  this.Income[this.Income.findIndex((c: any) => c.id === "Tax" + x.cflowId)] = obj;
                              }
                              else {
                                  indexRangeInflow.push(obj);
                                  this.Income.push(obj);
                              }
                          }

                      })
                      this.inflow = indexRangeInflow;

                      //Calculate Outflow Values
                      this.cfeClient.forEach((x: any) => { // client

                          var obj = indexRangeOutflow.find((y: any) => y.id === x.cflowId);
                          var obj1: any = {};
                          var j: number = 0;
                          if (obj == null) {
                              obj = {};
                              j = 0;
                          }
                          else {
                              obj1 = obj.values;
                              j = obj.increment;
                          }
                          obj["owner"] = x.owner;
                          obj["name"] = x.cfname;
                          obj["id"] = x.cflowId;

                          if (x.startDateType == "Start") {
                              x.startDate = this.clientDetails.startDate
                          }
                          else if (x.startDateType == "Client Retirement") {
                              x.startDate = this.clientDetails.clientRetirementYear - 1;
                          }

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Client Retirement") {
                              x.endDate = this.clientDetails.clientRetirementYear - 1;
                          }

                          if (q == 0) {
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;
                          }


                          if (indexRangeOutflow.find((y: any) => y.id === x.cflowId) != null) {
                              indexRangeOutflow[indexRangeOutflow.findIndex((c: any) => c.id === x.cflowId)] = obj;
                          }
                          else {
                              indexRangeOutflow.push(obj);
                          }

                      })
                      this.cfePartner.forEach((x: any) => { // partner
                          if (x.startDateType == "Start") {
                              x.startDate = this.clientDetails.startDate
                          }
                          else if (x.startDateType == "Partner Retirement") {
                              x.startDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Partner Retirement") {
                              x.endDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          var obj = indexRangeOutflow.find((y: any) => y.id === x.cflowId);
                          var obj1: any = {};
                          var j: number = 0;
                          if (obj == null) {
                              obj = {};
                              j = 0;
                          }
                          else {
                              obj1 = obj.values;
                              j = obj.increment;
                          }
                          obj["owner"] = x.owner;
                          obj["name"] = x.cfname;
                          obj["id"] = x.cflowId;

                          if (q == 0) {

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;
                          }

                          if (indexRangeOutflow.find((y: any) => y.id === x.cflowId) != null) {
                              indexRangeOutflow[indexRangeOutflow.findIndex((c: any) => c.id === x.cflowId)] = obj;
                          }
                          else {
                              indexRangeOutflow.push(obj);
                          }


                      })
                      this.cfeJoint.forEach((x: any) => { // joint
                          if (x.startDateType == "Start") {
                              x.startDate = this.clientDetails.startDate
                          }
                          else if (x.startDateType == "Client Retirement") {
                              x.startDate = this.clientDetails.clientRetirementYear - 1;
                          }
                          else if (x.startDateType == "Partner Retirement") {
                              x.startDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Client Retirement") {
                              x.endDate = this.clientDetails.clientRetirementYear - 1;
                          }
                          else if (x.endDateType == "Partner Retirement") {
                              x.endDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          var obj = indexRangeOutflow.find((y: any) => y.id === x.cflowId);
                          var obj1: any = {};
                          var j: number = 0;
                          if (obj == null) {
                              obj = {};
                              j = 0;
                          }
                          else {
                              obj1 = obj.values;
                              j = obj.increment;
                          }
                          obj["owner"] = x.owner;
                          obj["name"] = x.cfname;
                          obj["id"] = x.cflowId;

                          if (q == 0) {

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;
                          }

                          if (indexRangeOutflow.find((y: any) => y.id === x.cflowId) != null) {
                              indexRangeOutflow[indexRangeOutflow.findIndex((c: any) => c.id === x.cflowId)] = obj;
                          }
                          else {
                              indexRangeOutflow.push(obj);
                          }

                      })
                      this.outflow = indexRangeOutflow;

                      //Calculate Client Investment
                      this.investmentClient.forEach((x: any) => {

                          this.investmentContribution = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "C");
                          this.investmentWithdrawal = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "W");


                          if (x.startDateType == "Start" || x.startDateType == "Existing") {
                              x.startDate = this.clientDetails.startDate
                          }
                          else if (x.startDateType == "Client Retirement") {
                              x.startDate = this.clientDetails.clientRetirementYear - 1;
                          }
                        

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Client Retirement") {
                              x.endDate = this.clientDetails.clientRetirementYear - 1;
                          }
                        

                          var obj = this.BeginningValue.find((y: any) => y.owner === x.investmentId);
                          var begVal: any = {};
                          var growth: any = {};
                          var income: any = {};
                          var incomePaidOut: any = {};
                          var frankingCredits: any = {};
                          var earnings: any = {};
                          var purchaseOfAssets: any = {};
                          var regularContributions: any = {};
                          var contributions: any = {};
                          var saleOfAssets: any = {};
                          var regularWithdrawals: any = {};
                          var withdrawals: any = {};
                          var endingVal: any = {};
                          var endingValPV: any = {};
                          var realCG: any = {};
                          var unrealCG: any = {};
                          var cashFlow: any = {};
                          var unfunded: any = {};

                          if (obj == null) {
                              obj = {};
                          }
                          else {
                              obj.values;
                              begVal = obj.BegValues;
                              growth = obj.growthValues;
                              income = obj.incomeValues;
                              incomePaidOut = obj.incomePaidOutValues;
                              frankingCredits = obj.frankingCreditsValues;
                              earnings = obj.earningsValues;
                              purchaseOfAssets = obj.purchaseOfAssetValues;
                              regularContributions = obj.regularContributionsValues;
                              contributions = obj.contributionsValues;
                              saleOfAssets = obj.saleOfAssetValues;
                              regularWithdrawals = obj.regularWithdrawalsValues;
                              withdrawals = obj.withdrawalsValues;
                              endingVal = obj.endingValues;
                              endingValPV = obj.endingValuesPV;
                              realCG = obj.realCGValues;
                              unrealCG = obj.unrealCGValues;
                              cashFlow = obj.cashFlowValues;
                              unfunded = obj.unfundedValues;
                          }



                          obj["owner"] = x.investmentId;
                          obj["type"] = "Client";
                          obj["name"] = "Opening Value";

                          //BeginningValue
                          if (m == 1) {
                              if (x.startDateType == "Existing") {
                                  begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }
                           
                          }
                          else {
                             

                              if ((this.clientDetails.startDate + i) == x.startDate) {
                                  begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else if ((this.clientDetails.startDate + i) < x.startDate) {

                                  begVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                              }
                          }


                          if (highestVal == x.investmentId) {
                              if (q == 1) {

                                  var netValue: any = {};
                                  netValue = this.netCashFlow.filter(c => c.owner === "NetCashflow");
                                  cashFlow[(this.clientDetails.startDate + i)] = Number(netValue[0].values[(this.clientDetails.startDate + i)]);

                                  

                              }
                              else {
                                  cashFlow[(this.clientDetails.startDate + i)] = 0;
                              }
                          }
                          else {
                              cashFlow[(this.clientDetails.startDate + i)] = 0;
                          }   


                          //growth & income
                          var growthUnAdj = (x.growth / 100) * (Number(begVal[this.clientDetails.startDate + i]));
                          var incomeUnAdj = (x.income / 100) * (Number(begVal[this.clientDetails.startDate + i]));

                          var ICR = (x.productFees / 100) * (Number(begVal[this.clientDetails.startDate + i]));


                          var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                          var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                          if (typeof growthVal === "number" && !isNaN(growthVal)) {
                              growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                          }
                          else {
                              growth[this.clientDetails.startDate + i] = 0;
                          }

                          if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                              income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                          }
                          else {
                              income[this.clientDetails.startDate + i] = 0;
                          }


                          //incomePaidOut

                          if (x.reinvest == "N") {
                              incomePaidOut[this.clientDetails.startDate + i] = income[this.clientDetails.startDate + i];

                          }
                          else {
                              incomePaidOut[this.clientDetails.startDate + i] = 0;
                          }

                          //FrankingCredits

                          var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                          var ctr = Number(corporateTaxRate[0].percentage) / 100;

                          frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                          //Earnings
                          earnings[this.clientDetails.startDate + i] = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])).toFixed();

                          //List of Contributions
                          let ContributionSum: number = 0;
                          this.investmentContribution.forEach((y: any) => { // client

                              if (y.fromDateType == "Start") {
                                  y.fromDate = this.clientDetails.startDate;
                              }
                              if (y.toDateType == "End") {
                                  y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }

                              if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                  var t = parseInt(y.value);
                                  ContributionSum = ContributionSum + t;
                              }

                          });

                          regularContributions[this.clientDetails.startDate + i] = ContributionSum;



                          //Purchase of assets
                          if (x.startDateType != "Existing") {

                              if (x.startDate == this.clientDetails.startDate + i) {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }
                          }
                          else {
                              purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                          }

                          //Contributions
                          contributions[this.clientDetails.startDate + i] = regularContributions[this.clientDetails.startDate + i] + Number(purchaseOfAssets[this.clientDetails.startDate + i]);

                          //List of Withdrawals
                          //TODO: only if main date started
                          let WithdrawalSum: number = 0;
                          this.investmentWithdrawal.forEach((y: any) => { // client

                              if (y.fromDateType == "Start") {
                                  y.fromDate = this.clientDetails.startDate;
                              }
                              if (y.toDateType == "End") {
                                  y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }

                              if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                  var t = parseInt(y.value);
                                  WithdrawalSum = WithdrawalSum + t;
                              }

                          });

                          regularWithdrawals[this.clientDetails.startDate + i] = WithdrawalSum;


                          //Sale of assets
                          if (x.endDateType != "Retain") {

                              if (x.endDate == this.clientDetails.startDate + i) {
                                  saleOfAssets[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(regularWithdrawals[this.clientDetails.startDate + i]);
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }
                          }
                          else {
                              saleOfAssets[this.clientDetails.startDate + i] = 0;
                          }

                          //Withdrawals
                          withdrawals[this.clientDetails.startDate + i] = Number(regularWithdrawals[this.clientDetails.startDate + i]) + Number(saleOfAssets[this.clientDetails.startDate + i]);

                          if (highestVal == x.investmentId) {
                              if (q == 1) { 

                                  if (Number(cashFlow[(this.clientDetails.startDate + i)]) < 0) {
                                      if (Math.abs(Number(cashFlow[(this.clientDetails.startDate + i)])) > ((Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(withdrawals[this.clientDetails.startDate + i])))) {
                                          unfunded[this.clientDetails.startDate + i] = Math.abs(Number(cashFlow[(this.clientDetails.startDate + i)])) - ((Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(withdrawals[this.clientDetails.startDate + i])));
                                          cashFlow[(this.clientDetails.startDate + i)] = ((Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(withdrawals[this.clientDetails.startDate + i]))) * -1;
                                          
                                      }
                                      else {
                                          unfunded[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                  unfunded[this.clientDetails.startDate + i] = 0;
                                }

                              }
                              else {
                                  unfunded[(this.clientDetails.startDate + i)] = 0;
                              }
                          }
                          else {
                              unfunded[(this.clientDetails.startDate + i)] = 0;
                          }

                          
                        
                          endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(cashFlow[(this.clientDetails.startDate + i)]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(withdrawals[this.clientDetails.startDate + i])).toFixed();

                          //Ending Value PV
                          var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                          var inf = Number(inflation[0].percentage) / 100;
                          var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                          endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();


                          if (x.type == "Domestic Cash" || x.type == "Domestic Fixed Interest") {
                              realCG[this.clientDetails.startDate + i] = 0;
                              unrealCG[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              if ((begVal[this.clientDetails.startDate + i]) != 0) {
                                  //Real and Unreal CG
                                  var TotalCG = 0;
                                  var RateCG = 0


                                  if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                      TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(growth[this.clientDetails.startDate + i])));
                                  }
                                  else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                      TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(growth[this.clientDetails.startDate + i]);
                                  }

                                  if (endingVal[this.clientDetails.startDate + i] == 0) {
                                      realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                  }
                                  else {
                                      if (Number(withdrawals[this.clientDetails.startDate + i]) != 0) {
                                          realCG[this.clientDetails.startDate + i] = ((Number(withdrawals[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                      }
                                      else {
                                          realCG[this.clientDetails.startDate + i] = 0;
                                      }
                                  }

                                  unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                              }
                              else {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }
                          }


                          obj["BegValues"] = begVal;
                          obj["growthValues"] = growth;
                          obj["incomeValues"] = income;
                          obj["incomePaidOutValues"] = incomePaidOut;
                          obj["frankingCreditsValues"] = frankingCredits;
                          obj["earningsValues"] = earnings;
                          obj["purchaseOfAssetValues"] = purchaseOfAssets;
                          obj["regularContributionsValues"] = regularContributions;
                          obj["contributionsValues"] = contributions;
                          obj["saleOfAssetValues"] = saleOfAssets;
                          obj["regularWithdrawalsValues"] = regularWithdrawals;
                          obj["withdrawalsValues"] = withdrawals;
                          obj["endingValues"] = endingVal;
                          obj["endingValuesPV"] = endingValPV;
                          obj["realCGValues"] = realCG;
                          obj["unrealCGValues"] = unrealCG;
                          obj["cashFlowValues"] = cashFlow;
                          obj["unfundedValues"] = unfunded;

                          if (this.BeginningValue.find((y: any) => y.owner === x.investmentId) != null) {
                              this.BeginningValue[this.BeginningValue.findIndex((c: any) => c.owner === x.investmentId)] = obj;
                          }
                          else {
                              this.BeginningValue.push(obj);
                          }
                      })

                      //Calculate Partner Investment
                      this.investmentPartner.forEach((x: any) => { // client

                          this.investmentContribution = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "C");
                          this.investmentWithdrawal = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "W");


                          if (x.startDateType == "Start" || x.startDateType == "Existing") {
                              x.startDate = this.clientDetails.startDate
                          } 
                          else if (x.startDateType == "Partner Retirement") {
                              x.startDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Partner Retirement") {
                              x.endDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          var obj = this.BeginningValue.find((y: any) => y.owner === x.investmentId);
                          var begVal: any = {};
                          var growth: any = {};
                          var income: any = {};
                          var incomePaidOut: any = {};
                          var frankingCredits: any = {};
                          var earnings: any = {};
                          var purchaseOfAssets: any = {};
                          var regularContributions: any = {};
                          var contributions: any = {};
                          var saleOfAssets: any = {};
                          var regularWithdrawals: any = {};
                          var withdrawals: any = {};
                          var endingVal: any = {};
                          var endingValPV: any = {};
                          var realCG: any = {};
                          var unrealCG: any = {};
                          if (obj == null) {
                              obj = {};
                          }
                          else {
                              obj.values;
                              begVal = obj.BegValues;
                              growth = obj.growthValues;
                              income = obj.incomeValues;
                              incomePaidOut = obj.incomePaidOutValues;
                              frankingCredits = obj.frankingCreditsValues;
                              earnings = obj.earningsValues;
                              purchaseOfAssets = obj.purchaseOfAssetValues;
                              regularContributions = obj.regularContributionsValues;
                              contributions = obj.contributionsValues;
                              saleOfAssets = obj.saleOfAssetValues;
                              regularWithdrawals = obj.regularWithdrawalsValues;
                              withdrawals = obj.withdrawalsValues;
                              endingVal = obj.endingValues;
                              endingValPV = obj.endingValuesPV;
                              realCG = obj.realCGValues;
                              unrealCG = obj.unrealCGValues;
                          }

                          obj["owner"] = x.investmentId;
                          obj["type"] = "Partner";
                          obj["name"] = "Opening Value";

                          //BeginningValue
                          if (m == 1) {
                              if (x.startDateType == "Existing") {
                                  begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }

                          }
                          else {
                              if ((this.clientDetails.startDate + i) == x.startDate) {
                                  begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else if ((this.clientDetails.startDate + i) < x.startDate) {

                                  begVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                              }
                          }

                          //growth & income
                          var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                          var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                          var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                          var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                          var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                          if (typeof growthVal === "number" && !isNaN(growthVal)) {
                              growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                          }
                          else {
                              growth[this.clientDetails.startDate + i] = 0;
                          }

                          if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                              income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                          }
                          else {
                              income[this.clientDetails.startDate + i] = 0;
                          }


                          //incomePaidOut

                          if (x.reinvest == "N") {
                              incomePaidOut[this.clientDetails.startDate + i] = income[this.clientDetails.startDate + i];

                          }
                          else {
                              incomePaidOut[this.clientDetails.startDate + i] = 0;
                          }

                          //FrankingCredits

                          var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                          var ctr = Number(corporateTaxRate[0].percentage) / 100;

                          frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                          //Earnings
                          earnings[this.clientDetails.startDate + i] = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])).toFixed();

                          //List of Contributions
                          let ContributionSum: number = 0;
                          this.investmentContribution.forEach((y: any) => { // client

                              if (y.fromDateType == "Start") {
                                  y.fromDate = this.clientDetails.startDate;
                              }
                              if (y.toDateType == "End") {
                                  y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }

                              if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                  var t = parseInt(y.value);
                                  ContributionSum = ContributionSum + t;
                              }

                          });

                          regularContributions[this.clientDetails.startDate + i] = ContributionSum;



                          //Purchase of assets
                          if (x.startDateType != "Existing") {

                              if (x.startDate == this.clientDetails.startDate + i) {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }
                          }
                          else {
                              purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                          }

                          //Contributions
                          contributions[this.clientDetails.startDate + i] = regularContributions[this.clientDetails.startDate + i] + Number(purchaseOfAssets[this.clientDetails.startDate + i]);

                          //List of Withdrawals
                          let WithdrawalSum: number = 0;
                          this.investmentWithdrawal.forEach((y: any) => { // client

                              if (y.fromDateType == "Start") {
                                  y.fromDate = this.clientDetails.startDate;
                              }
                              if (y.toDateType == "End") {
                                  y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }

                              if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                  var t = parseInt(y.value);
                                  WithdrawalSum = WithdrawalSum + t;
                              }

                          });

                          regularWithdrawals[this.clientDetails.startDate + i] = WithdrawalSum;

                          //Sale of assets
                          if (x.endDateType != "Retain") {

                              if (x.endDate == this.clientDetails.startDate + i) {
                                  saleOfAssets[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(regularWithdrawals[this.clientDetails.startDate + i]);
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }
                          }
                          else {
                              saleOfAssets[this.clientDetails.startDate + i] = 0;
                          }

                          //Withdrawals
                          withdrawals[this.clientDetails.startDate + i] = Number(regularWithdrawals[this.clientDetails.startDate + i]) + Number(saleOfAssets[this.clientDetails.startDate + i]);

                          //Ending Value
                          endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(withdrawals[this.clientDetails.startDate + i])).toFixed();

                          //Ending Value PV
                          var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                          var inf = Number(inflation[0].percentage) / 100;
                          var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                          endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                          if (x.type == "Domestic Cash" || x.type == "Domestic Fixed Interest") {
                              realCG[this.clientDetails.startDate + i] = 0;
                              unrealCG[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              if (begVal[this.clientDetails.startDate + i] != 0) {
                                  //Real and Unreal CG
                                  var TotalCG = 0;
                                  var RateCG = 0


                                  if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                      TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(growth[this.clientDetails.startDate + i])));
                                  }
                                  else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                      TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(growth[this.clientDetails.startDate + i]);
                                  }

                                  if (endingVal[this.clientDetails.startDate + i] == 0) {
                                      realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                  }
                                  else {
                                      if (Number(withdrawals[this.clientDetails.startDate + i]) != 0) {
                                          realCG[this.clientDetails.startDate + i] = ((Number(withdrawals[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                      }
                                      else {
                                          realCG[this.clientDetails.startDate + i] = 0;
                                      }
                                  }

                                  unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                              }
                              else {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }
                          }


                          obj["BegValues"] = begVal;
                          obj["growthValues"] = growth;
                          obj["incomeValues"] = income;
                          obj["incomePaidOutValues"] = incomePaidOut;
                          obj["frankingCreditsValues"] = frankingCredits;
                          obj["earningsValues"] = earnings;
                          obj["purchaseOfAssetValues"] = purchaseOfAssets;
                          obj["regularContributionsValues"] = regularContributions;
                          obj["contributionsValues"] = contributions;
                          obj["saleOfAssetValues"] = saleOfAssets;
                          obj["regularWithdrawalsValues"] = regularWithdrawals;
                          obj["withdrawalsValues"] = withdrawals;
                          obj["endingValues"] = endingVal;
                          obj["endingValuesPV"] = endingValPV;
                          obj["realCGValues"] = realCG;
                          obj["unrealCGValues"] = unrealCG;


                          if (this.BeginningValue.find((y: any) => y.owner === x.investmentId) != null) {
                              this.BeginningValue[this.BeginningValue.findIndex((c: any) => c.owner === x.investmentId)] = obj;
                          }
                          else {
                              this.BeginningValue.push(obj);
                          }

                      })

                      //Calculate Joint Investment
                      this.investmentJoint.forEach((x: any) => { // client

                          this.investmentContribution = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "C");
                          this.investmentWithdrawal = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "W");


                          if (x.startDateType == "Start" || x.startDateType == "Existing") {
                              x.startDate = this.clientDetails.startDate
                          }
                          else if (x.startDateType == "Client Retirement") {
                              x.startDate = this.clientDetails.clientRetirementYear - 1;
                          }
                          else if (x.startDateType == "Partner Retirement") {
                              x.startDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Client Retirement") {
                              x.endDate = this.clientDetails.clientRetirementYear - 1;
                          }
                          else if (x.endDateType == "Partner Retirement") {
                              x.endDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          var obj = this.BeginningValue.find((y: any) => y.owner === x.investmentId);
                          var begVal: any = {};
                          var growth: any = {};
                          var income: any = {};
                          var incomePaidOut: any = {};
                          var frankingCredits: any = {};
                          var earnings: any = {};
                          var purchaseOfAssets: any = {};
                          var regularContributions: any = {};
                          var contributions: any = {};
                          var saleOfAssets: any = {};
                          var regularWithdrawals: any = {};
                          var withdrawals: any = {};
                          var endingVal: any = {};
                          var endingValPV: any = {};
                          var realCG: any = {};
                          var unrealCG: any = {};
                          if (obj == null) {
                              obj = {};
                          }
                          else {
                              obj.values;
                              begVal = obj.BegValues;
                              growth = obj.growthValues;
                              income = obj.incomeValues;
                              incomePaidOut = obj.incomePaidOutValues;
                              frankingCredits = obj.frankingCreditsValues;
                              earnings = obj.earningsValues;
                              purchaseOfAssets = obj.purchaseOfAssetValues;
                              regularContributions = obj.regularContributionsValues;
                              contributions = obj.contributionsValues;
                              saleOfAssets = obj.saleOfAssetValues;
                              regularWithdrawals = obj.regularWithdrawalsValues;
                              withdrawals = obj.withdrawalsValues;
                              endingVal = obj.endingValues;
                              endingValPV = obj.endingValuesPV;
                              realCG = obj.realCGValues;
                              unrealCG = obj.unrealCGValues;
                          }

                          obj["owner"] = x.investmentId;
                          obj["type"] = "Joint";
                          obj["name"] = "Opening Value";

                          //BeginningValue
                          if (m == 1) {
                              if (x.startDateType == "Existing") {
                                  begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }

                          }
                          else {
                              if ((this.clientDetails.startDate + i) == x.startDate) {
                                  begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else if ((this.clientDetails.startDate + i) < x.startDate) {

                                  begVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                              }
                          }

                          //growth & income
                          var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                          var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                          var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                          var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                          var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                          if (typeof growthVal === "number" && !isNaN(growthVal)) {
                              growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                          }
                          else {
                              growth[this.clientDetails.startDate + i] = 0;
                          }

                          if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                              income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                          }
                          else {
                              income[this.clientDetails.startDate + i] = 0;
                          }


                          //incomePaidOut

                          if (x.reinvest == "N") {
                              incomePaidOut[this.clientDetails.startDate + i] = income[this.clientDetails.startDate + i];

                          }
                          else {
                              incomePaidOut[this.clientDetails.startDate + i] = 0;
                          }

                          //FrankingCredits

                          var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                          var ctr = Number(corporateTaxRate[0].percentage) / 100;

                          frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                          //Earnings
                          earnings[this.clientDetails.startDate + i] = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])).toFixed();

                          //List of Contributions
                          let ContributionSum: number = 0;
                          this.investmentContribution.forEach((y: any) => { // client

                              if (y.fromDateType == "Start") {
                                  y.fromDate = this.clientDetails.startDate;
                              }
                              if (y.toDateType == "End") {
                                  y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }

                              if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                  var t = parseInt(y.value);
                                  ContributionSum = ContributionSum + t;
                              }

                          });

                          regularContributions[this.clientDetails.startDate + i] = ContributionSum;



                          //Purchase of assets
                          if (x.startDateType != "Existing") {

                              if (x.startDate == this.clientDetails.startDate + i) {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }
                          }
                          else {
                              purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                          }

                          //Contributions
                          contributions[this.clientDetails.startDate + i] = regularContributions[this.clientDetails.startDate + i] + Number(purchaseOfAssets[this.clientDetails.startDate + i]);

                          //List of Withdrawals
                          let WithdrawalSum: number = 0;
                          this.investmentWithdrawal.forEach((y: any) => { // client

                              if (y.fromDateType == "Start") {
                                  y.fromDate = this.clientDetails.startDate;
                              }
                              if (y.toDateType == "End") {
                                  y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }

                              if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                  var t = parseInt(y.value);
                                  WithdrawalSum = WithdrawalSum + t;
                              }

                          });

                          regularWithdrawals[this.clientDetails.startDate + i] = WithdrawalSum;

                          //Sale of assets
                          if (x.endDateType != "Retain") {

                              if (x.endDate == this.clientDetails.startDate + i) {
                                  saleOfAssets[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(regularWithdrawals[this.clientDetails.startDate + i]);
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }
                          }
                          else {
                              saleOfAssets[this.clientDetails.startDate + i] = 0;
                          }

                          //Withdrawals
                          withdrawals[this.clientDetails.startDate + i] = Number(regularWithdrawals[this.clientDetails.startDate + i]) + Number(saleOfAssets[this.clientDetails.startDate + i]);

                          //Ending Value
                          endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(withdrawals[this.clientDetails.startDate + i])).toFixed();

                          //Ending Value PV
                          var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                          var inf = inflation[0].percentage;
                          var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                          endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                          if (x.type == "Domestic Cash" || x.type == "Domestic Fixed Interest") {
                              realCG[this.clientDetails.startDate + i] = 0;
                              unrealCG[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              if (begVal[this.clientDetails.startDate + i] != 0) {
                                  //Real and Unreal CG
                                  var TotalCG = 0;
                                  var RateCG = 0


                                  if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                      TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(growth[this.clientDetails.startDate + i])));
                                  }
                                  else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                      TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(growth[this.clientDetails.startDate + i]);
                                  }

                                  if (endingVal[this.clientDetails.startDate + i] == 0) {
                                      realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                  }
                                  else {
                                      if (Number(withdrawals[this.clientDetails.startDate + i]) != 0) {
                                          realCG[this.clientDetails.startDate + i] = ((Number(withdrawals[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                      }
                                      else {
                                          realCG[this.clientDetails.startDate + i] = 0;
                                      }
                                  }

                                  unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                              }
                              else {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }
                          }

                          obj["BegValues"] = begVal;
                          obj["growthValues"] = growth;
                          obj["incomeValues"] = income;
                          obj["incomePaidOutValues"] = incomePaidOut;
                          obj["frankingCreditsValues"] = frankingCredits;
                          obj["earningsValues"] = earnings;
                          obj["purchaseOfAssetValues"] = purchaseOfAssets;
                          obj["regularContributionsValues"] = regularContributions;
                          obj["contributionsValues"] = contributions;
                          obj["saleOfAssetValues"] = saleOfAssets;
                          obj["regularWithdrawalsValues"] = regularWithdrawals;
                          obj["withdrawalsValues"] = withdrawals;
                          obj["endingValues"] = endingVal;
                          obj["endingValuesPV"] = endingValPV;
                          obj["realCGValues"] = realCG;
                          obj["unrealCGValues"] = unrealCG;

                          if (this.BeginningValue.find((y: any) => y.owner === x.investmentId) != null) {
                              this.BeginningValue[this.BeginningValue.findIndex((c: any) => c.owner === x.investmentId)] = obj;
                          }
                          else {
                              this.BeginningValue.push(obj);
                          }

                      })

                      //Calculate Financial Assets Totals
                      this.calculateTotalInvestmentPaidOut("TotalIPO", i);
                      this.calculateTotalInvestmentWithdrawals("TotalIW", i);
                      this.calculateTotalInvestmentContributions("TotalIC", i);
                      this.calculateTotalInvestmentEarnings("TotalTaxIE-client", "Client", i);
                      this.calculateTotalInvestmentEarnings("TotalTaxIE-partner", "Partner", i);
                      this.calculateRealizedCGFA("RCGFA-client", "Client", i);
                      this.calculateRealizedCGFA("RCGFA-partner", "Partner", i);
                      this.calculateFrankingCredits("FrankingCredits-client", "Client", i);
                      this.calculateFrankingCredits("FrankingCredits-partner", "Partner", i);


                      //Calculate Client Properties
                      this.propertiesClient.forEach((x: any) => { // client

                          if (x.startDateType == "Start" || x.startDateType == "Existing") {
                              x.startDate = this.clientDetails.startDate;
                          }
                          else if (x.startDateType == "Client Retirement") {
                              x.startDate = this.clientDetails.clientRetirementYear - 1;
                          }
                         

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Client Retirement") {
                              x.endDate = this.clientDetails.clientRetirementYear - 1;
                          } 
                          else if (x.endDateType == "Retain") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                          }


                          var obj = this.PropertiesValue.find((y: any) => y.owner === x.propertyId);
                          var begVal: any = {};
                          var propertyPurchase: any = {};
                          var propertySale: any = {};
                          var capitalGrowth: any = {};
                          var endingVal: any = {};
                          var endingValPV: any = {};
                          var rent: any = {};
                          var expenses: any = {};
                          var realCG: any = {};
                          var unrealCG: any = {};
                          var propPurchase: number = 0;
                          var propSale: number = 0;

                          if (obj == null) {
                              obj = {};
                          }
                          else {
                              begVal = obj.BegValues;
                              propertyPurchase = obj.PropertyPurchaseValues;
                              propertySale = obj.PropertySaleValues;
                              capitalGrowth = obj.capitalGrowthValues;
                              endingVal = obj.endingValues;
                              endingValPV = obj.endingValuesPV;
                              rent = obj.rentValues;
                              expenses = obj.expensesValues;
                              realCG = obj.realCGValues;
                              unrealCG = obj.unrealCGValues;
                          }


                          obj["owner"] = x.propertyId;
                          obj["type"] = "Client";
                          obj["name"] = x.name;
                          obj["startDateType"] = x.startDateType;

                          //BeginningValue
                          if (m == 1 && x.startDateType == "Existing") {
                              begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                          }
                          else if ((this.clientDetails.startDate + i) <= x.startDate) {
                              begVal[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                          }

                          //capital growth
                          capitalGrowth[this.clientDetails.startDate + i] = ((x.growth / 100) * Number(begVal[this.clientDetails.startDate + i])).toFixed();

                          ////Ending Value


                          if ((this.clientDetails.startDate + i) == x.startDate) {
                              endingVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              propertyPurchase[this.clientDetails.startDate + i] = x.value.toFixed();
                              propPurchase = this.clientDetails.startDate + i;
                              propertySale[this.clientDetails.startDate + i] = 0;

                          }
                          else if ((this.clientDetails.startDate + i) < x.startDate) {
                              endingVal[this.clientDetails.startDate + i] = 0;
                              propertyPurchase[this.clientDetails.startDate + i] = 0;


                          }


                          if ((this.clientDetails.startDate + i) == x.endDate) {
                              propertySale[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();
                              endingVal[this.clientDetails.startDate + i] = 0;
                          }
                          else if ((this.clientDetails.startDate + i) > x.startDate && (this.clientDetails.startDate + i) < x.endDate) {
                              propSale = this.clientDetails.startDate + i;
                              propertySale[this.clientDetails.startDate + i] = 0;
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();

                          }
                          else if ((this.clientDetails.startDate + i) > x.endDate) {
                              endingVal[this.clientDetails.startDate + i] = 0;
                              propertyPurchase[this.clientDetails.startDate + i] = 0;
                              propertySale[this.clientDetails.startDate + i] = 0;
                          }




                          ////Ending Value PV
                          var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                          var inf = Number(inflation[0].percentage) / 100;
                          var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                          endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                          //rent
                          if ((this.clientDetails.startDate + i) >= x.endDate) {
                              rent[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              let rentVal: number = 0;

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  rentVal = parseInt(x.rent);
                              }

                              rent[this.clientDetails.startDate + i] = rentVal;
                          }


                          //expenses
                          if ((this.clientDetails.startDate + i) >= x.endDate) {
                              expenses[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              let expensesVal: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  expensesVal = parseInt(x.expenses);
                              }
                              expenses[this.clientDetails.startDate + i] = expensesVal;
                          }

                          if (begVal[this.clientDetails.startDate + i] != 0) {
                              //Real and Unreal CG
                              var TotalCG = 0;
                              var RateCG = 0


                              if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                  TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(capitalGrowth[this.clientDetails.startDate + i])));
                              }
                              else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                  TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(capitalGrowth[this.clientDetails.startDate + i]);
                              }

                              if (endingVal[this.clientDetails.startDate + i] == 0) {
                                  realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                              }
                              else {
                                  if (Number(propertySale[this.clientDetails.startDate + i]) != 0) {
                                      realCG[this.clientDetails.startDate + i] = ((Number(propertySale[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                  }
                                  else {
                                      realCG[this.clientDetails.startDate + i] = 0;
                                  }
                              }

                              unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                          }
                          else {
                              realCG[this.clientDetails.startDate + i] = 0;
                              unrealCG[this.clientDetails.startDate + i] = 0;
                          }


                          obj["BegValues"] = begVal;
                          obj["PropertyPurchaseValues"] = propertyPurchase;
                          obj["PropertySaleValues"] = propertySale;
                          obj["capitalGrowthValues"] = capitalGrowth;
                          obj["endingValues"] = endingVal;
                          obj["endingValuesPV"] = endingValPV;
                          obj["rentValues"] = rent;
                          obj["expensesValues"] = expenses;
                          obj["realCGValues"] = realCG;
                          obj["unrealCGValues"] = unrealCG;
                          obj["propPurchase"] = propPurchase;

                          if (this.PropertiesValue.find((y: any) => y.owner === x.propertyId) != null) {
                              this.PropertiesValue[this.PropertiesValue.findIndex((c: any) => c.owner === x.propertyId)] = obj;
                          }
                          else {
                              this.PropertiesValue.push(obj);
                          }

                      })

                      //Calculate Partner Properties
                      this.propertiesPartner.forEach((x: any) => { // client

                          if (x.startDateType == "Start" || x.startDateType == "Existing") {
                              x.startDate = this.clientDetails.startDate;
                          }
                          else if (x.startDateType == "Partner Retirement") {
                              x.startDate = this.clientDetails.partnerRetirementYear - 1;
                          }
                          //TODO : Confirm retain end date value
                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Partner Retirement") {
                              x.endDate = this.clientDetails.partnerRetirementYear - 1;
                          }
                          else if (x.endDateType == "Retain") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                          }
                          var obj = this.PropertiesValue.find((y: any) => y.owner === x.propertyId);
                          var begVal: any = {};
                          var propertyPurchase: any = {};
                          var propertySale: any = {};
                          var capitalGrowth: any = {};
                          var endingVal: any = {};
                          var endingValPV: any = {};
                          var rent: any = {};
                          var expenses: any = {};
                          var realCG: any = {};
                          var unrealCG: any = {};
                          var propPurchase: number = 0;
                          var propSale: number = 0;

                          if (obj == null) {
                              obj = {};
                          }
                          else {
                              begVal = obj.BegValues;
                              propertyPurchase = obj.PropertyPurchaseValues;
                              propertySale = obj.PropertySaleValues;
                              capitalGrowth = obj.capitalGrowthValues;
                              endingVal = obj.endingValues;
                              endingValPV = obj.endingValuesPV;
                              rent = obj.rentValues;
                              expenses = obj.expensesValues;
                              realCG = obj.realCGValues;
                              unrealCG = obj.unrealCGValues;
                          }

                          obj["owner"] = x.propertyId;
                          obj["type"] = "Partner";
                          obj["name"] = x.name;
                          obj["startDateType"] = x.startDateType;

                          //BeginningValue
                          if (m == 1 && x.startDateType == "Existing") {
                              begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                          }
                          else if ((this.clientDetails.startDate + i) <= x.startDate) {
                              begVal[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                          }

                          //capital growth
                          capitalGrowth[this.clientDetails.startDate + i] = ((x.growth / 100) * Number(begVal[this.clientDetails.startDate + i])).toFixed();

                          ////Ending Value


                          if ((this.clientDetails.startDate + i) == x.startDate) {
                              endingVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              propertyPurchase[this.clientDetails.startDate + i] = x.value.toFixed();
                              propPurchase = this.clientDetails.startDate + i;
                              propertySale[this.clientDetails.startDate + i] = 0;

                          }
                          else if ((this.clientDetails.startDate + i) < x.startDate) {
                              endingVal[this.clientDetails.startDate + i] = 0;
                              propertyPurchase[this.clientDetails.startDate + i] = 0;


                          }


                          if ((this.clientDetails.startDate + i) == x.endDate) {
                              propertySale[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();
                              endingVal[this.clientDetails.startDate + i] = 0;
                          }
                          else if ((this.clientDetails.startDate + i) > x.startDate && (this.clientDetails.startDate + i) < x.endDate) {
                              propSale = this.clientDetails.startDate + i;
                              propertySale[this.clientDetails.startDate + i] = 0;
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();

                          }
                          else if ((this.clientDetails.startDate + i) > x.endDate) {
                              endingVal[this.clientDetails.startDate + i] = 0;
                              propertyPurchase[this.clientDetails.startDate + i] = 0;
                              propertySale[this.clientDetails.startDate + i] = 0;
                          }




                          ////Ending Value PV
                          var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                          var inf = Number(inflation[0].percentage) / 100;
                          var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                          endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                          //rent
                          if ((this.clientDetails.startDate + i) >= x.endDate) {
                              rent[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              let rentVal: number = 0;

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  rentVal = parseInt(x.rent);
                              }

                              rent[this.clientDetails.startDate + i] = rentVal;
                          }


                          //expenses
                          if ((this.clientDetails.startDate + i) >= x.endDate) {
                              expenses[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              let expensesVal: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  expensesVal = parseInt(x.expenses);
                              }
                              expenses[this.clientDetails.startDate + i] = expensesVal;
                          }

                          if (begVal[this.clientDetails.startDate + i] != 0) {
                              //Real and Unreal CG
                              var TotalCG = 0;
                              var RateCG = 0


                              if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                  TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(capitalGrowth[this.clientDetails.startDate + i])));
                              }
                              else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                  TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(capitalGrowth[this.clientDetails.startDate + i]);
                              }

                              if (endingVal[this.clientDetails.startDate + i] == 0) {
                                  realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                              }
                              else {
                                  if (Number(propertySale[this.clientDetails.startDate + i]) != 0) {
                                      realCG[this.clientDetails.startDate + i] = ((Number(propertySale[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                  }
                                  else {
                                      realCG[this.clientDetails.startDate + i] = 0;
                                  }
                              }

                              unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                          }
                          else {
                              realCG[this.clientDetails.startDate + i] = 0;
                              unrealCG[this.clientDetails.startDate + i] = 0;
                          }


                          obj["BegValues"] = begVal;
                          obj["PropertyPurchaseValues"] = propertyPurchase;
                          obj["PropertySaleValues"] = propertySale;
                          obj["capitalGrowthValues"] = capitalGrowth;
                          obj["endingValues"] = endingVal;
                          obj["endingValuesPV"] = endingValPV;
                          obj["rentValues"] = rent;
                          obj["expensesValues"] = expenses;
                          obj["realCGValues"] = realCG;
                          obj["unrealCGValues"] = unrealCG;
                          obj["propPurchase"] = propPurchase;

                          if (this.PropertiesValue.find((y: any) => y.owner === x.propertyId) != null) {
                              this.PropertiesValue[this.PropertiesValue.findIndex((c: any) => c.owner === x.propertyId)] = obj;
                          }
                          else {
                              this.PropertiesValue.push(obj);
                          }
                      })
                      //Calculate Joint Properties
                      this.propertiesJoint.forEach((x: any) => { // client

                          if (x.startDateType == "Start" || x.startDateType == "Existing") {
                              x.startDate = this.clientDetails.startDate;
                          }
                          else if (x.startDateType == "Client Retirement") {
                              x.startDate = this.clientDetails.clientRetirementYear - 1;
                          }
                          else if (x.startDateType == "Partner Retirement") {
                              x.startDate = this.clientDetails.partnerRetirementYear - 1;
                          }
                          //TODO : Confirm retain end date value
                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Retain") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                          }
                          else if (x.endDateType == "Client Retirement") {
                              x.endDate = this.clientDetails.clientRetirementYear - 1;
                          }
                          else if (x.endDateType == "Partner Retirement") {
                              x.endDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          var obj = this.PropertiesValue.find((y: any) => y.owner === x.propertyId);
                          var begVal: any = {};
                          var propertyPurchase: any = {};
                          var propertySale: any = {};
                          var capitalGrowth: any = {};
                          var endingVal: any = {};
                          var endingValPV: any = {};
                          var rent: any = {};
                          var expenses: any = {};
                          var realCG: any = {};
                          var unrealCG: any = {};
                          var propPurchase: number = 0;
                          var propSale: number = 0;

                          if (obj == null) {
                              obj = {};
                          }
                          else {
                              begVal = obj.BegValues;
                              propertyPurchase = obj.PropertyPurchaseValues;
                              propertySale = obj.PropertySaleValues;
                              capitalGrowth = obj.capitalGrowthValues;
                              endingVal = obj.endingValues;
                              endingValPV = obj.endingValuesPV;
                              rent = obj.rentValues;
                              expenses = obj.expensesValues;
                              realCG = obj.realCGValues;
                              unrealCG = obj.unrealCGValues;
                          }

                          obj["owner"] = x.propertyId;
                          obj["type"] = "Joint";
                          obj["name"] = x.name;
                          obj["startDateType"] = x.startDateType;

                          //BeginningValue
                          if (m == 1 && x.startDateType == "Existing") {
                              begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                          }
                          else if ((this.clientDetails.startDate + i) <= x.startDate) {
                              begVal[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                          }

                          //capital growth
                          capitalGrowth[this.clientDetails.startDate + i] = ((x.growth / 100) * Number(begVal[this.clientDetails.startDate + i])).toFixed();

                          ////Ending Value


                          if ((this.clientDetails.startDate + i) == x.startDate) {
                              endingVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              propertyPurchase[this.clientDetails.startDate + i] = x.value.toFixed();
                              propPurchase = this.clientDetails.startDate + i;
                              propertySale[this.clientDetails.startDate + i] = 0;

                          }
                          else if ((this.clientDetails.startDate + i) < x.startDate) {
                              endingVal[this.clientDetails.startDate + i] = 0;
                              propertyPurchase[this.clientDetails.startDate + i] = 0;


                          }


                          if ((this.clientDetails.startDate + i) == x.endDate) {
                              propertySale[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();
                              endingVal[this.clientDetails.startDate + i] = 0;
                          }
                          else if ((this.clientDetails.startDate + i) > x.startDate && (this.clientDetails.startDate + i) < x.endDate) {
                              propSale = this.clientDetails.startDate + i;
                              propertySale[this.clientDetails.startDate + i] = 0;
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();

                          }
                          else if ((this.clientDetails.startDate + i) > x.endDate) {
                              endingVal[this.clientDetails.startDate + i] = 0;
                              propertyPurchase[this.clientDetails.startDate + i] = 0;
                              propertySale[this.clientDetails.startDate + i] = 0;
                          }




                          ////Ending Value PV
                          var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                          var inf = Number(inflation[0].percentage) / 100;
                          var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                          endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                          //rent
                          if ((this.clientDetails.startDate + i) >= x.endDate) {
                              rent[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              let rentVal: number = 0;

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  rentVal = parseInt(x.rent);
                              }

                              rent[this.clientDetails.startDate + i] = rentVal;
                          }


                          //expenses
                          if ((this.clientDetails.startDate + i) >= x.endDate) {
                              expenses[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              let expensesVal: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  expensesVal = parseInt(x.expenses);
                              }
                              expenses[this.clientDetails.startDate + i] = expensesVal;
                          }

                          if (begVal[this.clientDetails.startDate + i] != 0) {
                              //Real and Unreal CG
                              var TotalCG = 0;
                              var RateCG = 0


                              if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                  TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(capitalGrowth[this.clientDetails.startDate + i])));
                              }
                              else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                  TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(capitalGrowth[this.clientDetails.startDate + i]);
                              }

                              if (endingVal[this.clientDetails.startDate + i] == 0) {
                                  realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                              }
                              else {
                                  if (Number(propertySale[this.clientDetails.startDate + i]) != 0) {
                                      realCG[this.clientDetails.startDate + i] = ((Number(propertySale[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                  }
                                  else {
                                      realCG[this.clientDetails.startDate + i] = 0;
                                  }
                              }

                              unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                          }
                          else {
                              realCG[this.clientDetails.startDate + i] = 0;
                              unrealCG[this.clientDetails.startDate + i] = 0;
                          }


                          obj["BegValues"] = begVal;
                          obj["PropertyPurchaseValues"] = propertyPurchase;
                          obj["PropertySaleValues"] = propertySale;
                          obj["capitalGrowthValues"] = capitalGrowth;
                          obj["endingValues"] = endingVal;
                          obj["endingValuesPV"] = endingValPV;
                          obj["rentValues"] = rent;
                          obj["expensesValues"] = expenses;
                          obj["realCGValues"] = realCG;
                          obj["unrealCGValues"] = unrealCG;
                          obj["propPurchase"] = propPurchase;

                          if (this.PropertiesValue.find((y: any) => y.owner === x.propertyId) != null) {
                              this.PropertiesValue[this.PropertiesValue.findIndex((c: any) => c.owner === x.propertyId)] = obj;
                          }
                          else {
                              this.PropertiesValue.push(obj);
                          }

                      })


                      //Calculate PropertyTotal
                      this.calculateTotalRent("TotalRent", i);
                      this.calculateTotalSaleProceeds("TotalSaleProceeds", i);
                      this.calculateTotalPropertyExpenses("TotalPropertyExpenses", i);
                      this.calculateInvestmentPropertyExpenses("InvestmentPropertyExpenses-client", "Client", i);
                      this.calculateInvestmentPropertyExpenses("InvestmentPropertyExpenses-partner", "Partner", i);
                      this.calculateRealizedCGP("RCGP-client", "Client", i);
                      this.calculateRealizedCGP("RCGP-partner", "Partner", i);




                      ////Calculate Client Liability
                      this.liabilityClient.forEach((x: any) => { // client

                          this.liabilityDrawDown = this.liabilityDD.filter((c: any) => c.liabilityId === x.liabilityId);


                          if (x.commenceOnDateType == "Start" || x.commenceOnDateType == "Existing") {
                              x.commenceOnDate = this.clientDetails.startDate;
                          }
                          if (x.repaymentDateType == "End") {
                              x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.repaymentDateType == "Retain") {
                              x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                          }


                          var obj = this.LBValue.find((y: any) => y.owner === x.liabilityId);
                          var begVal: any = {};
                          var accruedInterest: any = {};
                          var repmt: any = {};
                          var endingVal: any = {};

                          if (obj == null) {
                              obj = {};
                          }
                          else {
                              begVal = obj.BegValues;
                              accruedInterest = obj.accruedInterestValues;
                              repmt = obj.repmtValues;
                              endingVal = obj.endingValues;
                          }

                          obj["owner"] = x.liabilityId;
                          obj["type"] = "Client";
                          obj["name"] = "Opening Value";
                          obj["deductibility"] = x.deductibility;

                          if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {
                              //BeginningValue
                              if (m == 1) {
                                  if (x.commenceOnDateType == "Existing") {
                                      begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  if ((this.clientDetails.startDate + i) == x.commenceOnDate) {
                                      begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.commenceOnDate) {

                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = Number(endingVal[Number(this.clientDetails.startDate + i) - 1]);
                                  }
                              }
                          }
                          else {
                              begVal[this.clientDetails.startDate + i] = 0;
                          }

                          //accrued Interest
                          accruedInterest[this.clientDetails.startDate + i] = (begVal[this.clientDetails.startDate + i] * (x.interestRate / 100)).toFixed();

                          //Minimum repayment

                          var PMT: number = 0;
                          if (x.repaymentType == "IO") {
                              PMT = Number(accruedInterest[this.clientDetails.startDate + i]);
                          }
                          else {
                              PMT = Number(x.principal) * (x.interestRate / 100) * (Math.pow((1 + (x.interestRate / 100)), x.term) / (Math.pow((1 + (x.interestRate / 100)), x.term) - 1));
                          }
                          if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {

                              //Repayment Value
                              var Repmt: number = 0;
                              if (x.repaymentDateType == "Retain") {
                                  Repmt = Math.max(x.repayment, PMT);
                              }
                              else if ((this.clientDetails.startDate + i) == x.repaymentDate) {
                                  Repmt = Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]);
                              }
                              else {
                                  Repmt = Math.max(x.repayment, PMT);
                              }
                              var repayment = Math.min((begVal[this.clientDetails.startDate + i] + accruedInterest[this.clientDetails.startDate + i]), Repmt);
                              repmt[this.clientDetails.startDate + i] = repayment.toFixed();
                          }
                          else {
                              repmt[this.clientDetails.startDate + i] = 0;
                          }
                          ////Ending Value
                          if (Number(repmt[this.clientDetails.startDate + i]) > (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]))) {
                              endingVal[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]) - Number(repmt[this.clientDetails.startDate + i])).toFixed();
                          }

                          obj["BegValues"] = begVal;
                          obj["accruedInterestValues"] = accruedInterest;
                          obj["repmtValues"] = repmt;
                          obj["endingValues"] = endingVal;


                          if (this.LBValue.find((y: any) => y.owner === x.liabilityId) != null) {
                              this.LBValue[this.LBValue.findIndex((c: any) => c.owner === x.liabilityId)] = obj;
                          }
                          else {
                              this.LBValue.push(obj);
                          }


                      })

                      //Calculate Partner Liability
                      this.liabilityPartner.forEach((x: any) => { // client

                          this.liabilityDrawDown = this.liabilityDD.filter((c: any) => c.liabilityId === x.liabilityId);


                          if (x.commenceOnDateType == "Start" || x.commenceOnDateType == "Existing") {
                              x.commenceOnDate = this.clientDetails.startDate;
                          }
                          if (x.repaymentDateType == "End") {
                              x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.repaymentDateType == "Retain") {
                              x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                          }


                          var obj = this.LBValue.find((y: any) => y.owner === x.liabilityId);
                          var begVal: any = {};
                          var accruedInterest: any = {};
                          var repmt: any = {};
                          var endingVal: any = {};

                          if (obj == null) {
                              obj = {};
                          }
                          else {
                              begVal = obj.BegValues;
                              accruedInterest = obj.accruedInterestValues;
                              repmt = obj.repmtValues;
                              endingVal = obj.endingValues;
                          }


                          obj["owner"] = x.liabilityId;
                          obj["type"] = "Partner";
                          obj["name"] = "Opening Value";
                          obj["deductibility"] = x.deductibility;

                          if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {
                              //BeginningValue
                              if (m == 1) {
                                  if (x.commenceOnDateType == "Existing") {
                                      begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  if ((this.clientDetails.startDate + i) == x.commenceOnDate) {
                                      begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.commenceOnDate) {

                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = Number(endingVal[Number(this.clientDetails.startDate + i) - 1]);
                                  }
                              }
                          }
                          else {
                              begVal[this.clientDetails.startDate + i] = 0;
                          }

                          //accrued Interest
                          accruedInterest[this.clientDetails.startDate + i] = (begVal[this.clientDetails.startDate + i] * (x.interestRate / 100)).toFixed();

                          //Minimum repayment

                          var PMT: number = 0;
                          if (x.repaymentType == "IO") {
                              PMT = Number(accruedInterest[this.clientDetails.startDate + i]);
                          }
                          else {
                              PMT = Number(x.principal) * (x.interestRate / 100) * (Math.pow((1 + (x.interestRate / 100)), x.term) / (Math.pow((1 + (x.interestRate / 100)), x.term) - 1));
                          }
                          if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {

                              //Repayment Value
                              var Repmt: number = 0;
                              if (x.repaymentDateType == "Retain") {
                                  Repmt = Math.max(x.repayment, PMT);
                              }
                              else if ((this.clientDetails.startDate + i) == x.repaymentDate) {
                                  Repmt = Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]);
                              }
                              else {
                                  Repmt = Math.max(x.repayment, PMT);
                              }
                              var repayment = Math.min((begVal[this.clientDetails.startDate + i] + accruedInterest[this.clientDetails.startDate + i]), Repmt);
                              repmt[this.clientDetails.startDate + i] = repayment.toFixed();
                          }
                          else {
                              repmt[this.clientDetails.startDate + i] = 0;
                          }
                          ////Ending Value
                          if (Number(repmt[this.clientDetails.startDate + i]) > (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]))) {
                              endingVal[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]) - Number(repmt[this.clientDetails.startDate + i])).toFixed();
                          }

                          obj["BegValues"] = begVal;
                          obj["accruedInterestValues"] = accruedInterest;
                          obj["repmtValues"] = repmt;
                          obj["endingValues"] = endingVal;

                          if (this.LBValue.find((y: any) => y.owner === x.liabilityId) != null) {
                              this.LBValue[this.LBValue.findIndex((c: any) => c.owner === x.liabilityId)] = obj;
                          }
                          else {
                              this.LBValue.push(obj);
                          }

                      })
                      //Calculate Joint Liability
                      this.liabilityJoint.forEach((x: any) => { // client

                          this.liabilityDrawDown = this.liabilityDD.filter((c: any) => c.liabilityId === x.liabilityId);


                          if (x.commenceOnDateType == "Start" || x.commenceOnDateType == "Existing") {
                              x.commenceOnDate = this.clientDetails.startDate;
                          }
                          if (x.repaymentDateType == "End") {
                              x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.repaymentDateType == "Retain") {
                              x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                          }



                          var obj = this.LBValue.find((y: any) => y.owner === x.liabilityId);
                          var begVal: any = {};
                          var accruedInterest: any = {};
                          var repmt: any = {};
                          var endingVal: any = {};

                          if (obj == null) {
                              obj = {};
                          }
                          else {
                              begVal = obj.BegValues;
                              accruedInterest = obj.accruedInterestValues;
                              repmt = obj.repmtValues;
                              endingVal = obj.endingValues;
                          }


                          obj["owner"] = x.liabilityId;
                          obj["type"] = "Joint";
                          obj["name"] = "Opening Value";
                          obj["deductibility"] = x.deductibility;

                          if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {
                              //BeginningValue
                              if (m == 1) {
                                  if (x.commenceOnDateType == "Existing") {
                                      begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  if ((this.clientDetails.startDate + i) == x.commenceOnDate) {
                                      begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.commenceOnDate) {

                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = Number(endingVal[Number(this.clientDetails.startDate + i) - 1]);
                                  }
                              }
                          }
                          else {
                              begVal[this.clientDetails.startDate + i] = 0;
                          }

                          //accrued Interest
                          accruedInterest[this.clientDetails.startDate + i] = (begVal[this.clientDetails.startDate + i] * (x.interestRate / 100)).toFixed();

                          //Minimum repayment

                          var PMT: number = 0;
                          if (x.repaymentType == "IO") {
                              PMT = Number(accruedInterest[this.clientDetails.startDate + i]);
                          }
                          else {
                              PMT = Number(x.principal) * (x.interestRate / 100) * (Math.pow((1 + (x.interestRate / 100)), x.term) / (Math.pow((1 + (x.interestRate / 100)), x.term) - 1));
                          }
                          if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {

                              //Repayment Value
                              var Repmt: number = 0;
                              if (x.repaymentDateType == "Retain") {
                                  Repmt = Math.max(x.repayment, PMT);
                              }
                              else if ((this.clientDetails.startDate + i) == x.repaymentDate) {
                                  Repmt = Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]);
                              }
                              else {
                                  Repmt = Math.max(x.repayment, PMT);
                              }
                              var repayment = Math.min((begVal[this.clientDetails.startDate + i] + accruedInterest[this.clientDetails.startDate + i]), Repmt);
                              repmt[this.clientDetails.startDate + i] = repayment.toFixed();
                          }
                          else {
                              repmt[this.clientDetails.startDate + i] = 0;
                          }
                          ////Ending Value
                          if (Number(repmt[this.clientDetails.startDate + i]) > (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]))) {
                              endingVal[this.clientDetails.startDate + i] = 0;
                          }
                          else {
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]) - Number(repmt[this.clientDetails.startDate + i])).toFixed();
                          }

                          obj["BegValues"] = begVal;
                          obj["accruedInterestValues"] = accruedInterest;
                          obj["repmtValues"] = repmt;
                          obj["endingValues"] = endingVal;

                          if (this.LBValue.find((y: any) => y.owner === x.liabilityId) != null) {
                              this.LBValue[this.LBValue.findIndex((c: any) => c.owner === x.liabilityId)] = obj;
                          }
                          else {
                              this.LBValue.push(obj);
                          }

                      })

                      //Calculate Liability Total

                      this.calculateTotalDebtRepayment("TotalDebtRepayment", i);
                      this.calculateAccruedLiabilities("Accruedliability-client", "Client", i);
                      this.calculateAccruedLiabilities("Accruedliability-partner", "Partner", i);


                      //Pension - Client
                      this.pensionClient.forEach((x: any) => {

                          this.pensionDrawDown = this.pensionDD.filter((c: any) => c.pensionId === x.pensionId);
                          if (x.pensionRebootFromType == "Start" || x.pensionRebootFromType == "Existing") {
                              x.pensionRebootFromDate = this.clientDetails.startDate;
                          }
                          else if (x.pensionRebootFromType == "Client Retirement") {
                              x.pensionRebootFromDate = this.clientDetails.clientRetirementYear - 1;
                          }
                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Retain") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                          }
                          else if (x.endDateType == "Client Retirement") {
                              x.endDate = this.clientDetails.clientRetirementYear - 1;
                          }

                          var obj = this.PensionValue.find((y: any) => y.owner === x.pensionId);
                          var begVal: any = {};
                          var TaxableBegVal: any = {};
                          var TaxFreeBegVal: any = {};

                          var growth: any = {};
                          var income: any = {};
                          var frankingCredits: any = {};

                          var pensionIncome: any = {};
                          var pITaxAssessable: any = {};
                          var pITaxExempt: any = {};

                          var endingVal: any = {};
                          var TaxableEndingVal: any = {};
                          var TaxFreeEndingVal: any = {};
                          var endingValPV: any = {};
                          var TaxableProp: number = 0;
                          var TaxFreeProp: number = 0;

                          if (obj == null) {
                              obj = {};
                              TaxableProp = 0;
                              TaxFreeProp = 0;
                          }
                          else {
                              begVal = obj.BegValues;
                              TaxableBegVal = obj.TaxableBegValues;
                              TaxFreeBegVal = obj.TaxFreeBegValues;
                              growth = obj.growthValues;
                              income = obj.incomeValues;
                              frankingCredits = obj.frankingCreditsValues;
                              pensionIncome = obj.pensionIncomeValues;
                              pITaxAssessable = obj.pITaxAssessableValues;
                              pITaxExempt = obj.pITaxExemptValues;
                              endingVal = obj.endingValues;
                              TaxableEndingVal = obj.TaxableEndingValues;
                              TaxFreeEndingVal = obj.TaxFreeEndingValues;
                              endingValPV = obj.endingValuesPV;
                              TaxableProp = obj.taxableProp;
                              TaxFreeProp = obj.taxfreeProp;

                          }

                          obj["owner"] = x.pensionId;
                          obj["type"] = "Client";
                          obj["name"] = "Opening Value";


                          if (x.pensionRebootFromDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              //BeginningValue
                              if (m == 1) {
                                  if (x.pensionRebootFromType == "Existing") {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      //begVal[this.clientDetails.startDate + i] = x.value;
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  if ((this.clientDetails.startDate + i) == x.pensionRebootFromDate) {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      //begVal[this.clientDetails.startDate + i] = x.value;
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.pensionRebootFromDate) {

                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {

                                      begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                                  }
                              }


                              if ((this.clientDetails.startDate + i) == x.pensionRebootFromDate || x.pensionRebootFromType == "Existing") {
                                  //TODO Confirm negative
                                  if (x.taxableComponent != 0 && x.value != 0) {
                                      TaxableProp = (Number(x.taxableComponent) / Number(x.value));
                                  }
                                  else {
                                      TaxableProp = 0;
                                  }
                                  TaxFreeProp = 1 - TaxableProp;

                                  TaxableBegVal[this.clientDetails.startDate + i] = x.taxableComponent.toFixed();
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = x.taxFreeComponent.toFixed();
                                  //TaxableBegVal[this.clientDetails.startDate + i] = x.taxableComponent;
                                  //TaxFreeBegVal[this.clientDetails.startDate + i] = x.taxFreeComponent;
                              }
                              else if ((this.clientDetails.startDate + i) < x.pensionRebootFromDate) {

                                  TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {

                                  TaxableBegVal[this.clientDetails.startDate + i] = Number(TaxableEndingVal[Number(this.clientDetails.startDate + i) - 1]);
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = Number(TaxFreeEndingVal[Number(this.clientDetails.startDate + i) - 1]);
                              }
                          }
                          else {
                              TaxableBegVal[this.clientDetails.startDate + i] = 0;
                              TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                              begVal[this.clientDetails.startDate + i] = 0;
                          }


                          ////growth & income
                          var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                          var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                          var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                          var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                          var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                          if (typeof growthVal === "number" && !isNaN(growthVal)) {
                              growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              //growth[this.clientDetails.startDate + i] = growthVal;
                          }
                          else {
                              growth[this.clientDetails.startDate + i] = 0;
                          }

                          if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                              income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              //income[this.clientDetails.startDate + i] = incomeVal;
                          }
                          else {
                              income[this.clientDetails.startDate + i] = 0;
                          }

                          //FrankingCredits

                          var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                          var ctr = Number(corporateTaxRate[0].percentage) / 100;

                          frankingCredits[this.clientDetails.startDate + i] = (Number(income[this.clientDetails.startDate + i]) * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();
                          //frankingCredits[this.clientDetails.startDate + i] = (Number(income[this.clientDetails.startDate + i]) * (ctr / (1 - ctr)) * (x.franked / 100));


                          //pension Income
                          var preservation = this.preservationAge.sort((a: any, b: any) => a.dob - b.dob);
                          var minPendionDD = this.minimumPensionDrawdown.sort((a: any, b: any) => a.age - b.age);
                         
                          var currentYear = this.clientDetails.startDate + i;
                          var pAge: number = 0;
                          var minRate: number = 0;

                          for (var k = 0; k < preservation.length; k++) {


                              if ((k == (preservation.length - 1)) && (this.clientDetails.clientDob >= preservation[k].dob)) {
                                  pAge = preservation[k].age;

                              }
                              else if (k == 0 && ((this.clientDetails.clientDob) <= preservation[k].dob)) {
                                  pAge = preservation[k].age;
                                  break;

                              }
                              else if ((this.clientDetails.clientDob) > preservation[k].dob && (this.clientDetails.clientDob) <= preservation[k + 1].dob) {
                                  pAge = preservation[k + 1].age;
                                  break;

                              }
                          }
                          var date1 = new Date("7/01/ " + (this.clientDetails.startDate + i));
                          var date2 = new Date(this.clientDetails.clientDob);
                          var timeDiff = Math.abs(date2.getTime() - date1.getTime());
                          var diffDays = (Math.ceil(timeDiff / (1000 * 3600 * 24))) / 365;

                          var clientAge = Math.round(diffDays * 10) / 10;

                          for (var l = 0; l < minPendionDD.length; l++) {


                              if ((l == (minPendionDD.length - 1)) && (clientAge >= minPendionDD[l].age)) {
                                  minRate = minPendionDD[l].minimumDrawdown;

                              }
                              else if (l == 0 && (clientAge <= minPendionDD[l].age)) {
                                  minRate = minPendionDD[l].minimumDrawdown;
                                  break;

                              }
                              else if (clientAge > minPendionDD[l].age && clientAge <= minPendionDD[l + 1].age) {
                                  minRate = minPendionDD[l + 1].minimumDrawdown;
                                  break;

                              }
                          }


                          var minDrawdown: number = 0;
                          var maxDrawdown: number = 0;

                          if (clientAge < pAge) {
                              minDrawdown = 0;
                              maxDrawdown = 0;
                          }
                          else if (clientAge >= pAge && clientAge < 65) {
                              if (this.clientRetirementYear != 0 && this.clientRetirementYear <= (this.clientDetails.startDate + i)) {
                                  minDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (minRate / 100);
                                  maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]);

                              }
                              else {
                                  minDrawdown = 0;
                                  maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (10 / 100);
                              }

                          }
                          else if (clientAge >= 65) {
                              minDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (minRate / 100);
                              maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]);
                          }


                          if (x.pensionRebootFromDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {

                              if (this.pensionDrawDown.length > 0) {
                                  let pIncomeSum: number = 0;
                                  this.pensionDrawDown.forEach((y: any) => {

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.amount == 0) {
                                              if (y.type == "Minimum") {
                                                  pensionIncome[this.clientDetails.startDate + i] = minDrawdown.toFixed();
                                                  //pensionIncome[this.clientDetails.startDate + i] = minDrawdown;
                                              } else if (y.type == "Maximum") {
                                                  pensionIncome[this.clientDetails.startDate + i] = maxDrawdown.toFixed();
                                                  //pensionIncome[this.clientDetails.startDate + i] = maxDrawdown;
                                              }
                                          }
                                          else {
                                              pensionIncome[this.clientDetails.startDate + i] = (Math.min(maxDrawdown, Math.max(minDrawdown, y.amount))).toFixed();
                                              //pensionIncome[this.clientDetails.startDate + i] = (Math.min(maxDrawdown, Math.max(minDrawdown, y.amount)));
                                          }
                                          //var t = parseInt(y.amount);
                                          //ContributionSum = ContributionSum + t;
                                      }

                                  });
                              }
                              else {
                                  pensionIncome[this.clientDetails.startDate + i] = 0;
                              }


                          }
                          else {
                              pensionIncome[this.clientDetails.startDate + i] = 0;
                          }


                          if (clientAge >= pAge && clientAge < 60) {
                              pITaxAssessable[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) * TaxableProp).toFixed();
                              pITaxExempt[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) - pITaxAssessable[this.clientDetails.startDate + i]).toFixed();
                              //pITaxAssessable[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) * TaxableProp);
                              //pITaxExempt[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) - pITaxAssessable[this.clientDetails.startDate + i]);

                          }
                          else if (clientAge >= 60) {
                              pITaxAssessable[this.clientDetails.startDate + i] = 0;
                              pITaxExempt[this.clientDetails.startDate + i] = Number(pensionIncome[this.clientDetails.startDate + i]).toFixed();
                              //pITaxExempt[this.clientDetails.startDate + i] = Number(pensionIncome[this.clientDetails.startDate + i]);
                          }

                          //Ending Value
                          endingVal[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(pensionIncome[this.clientDetails.startDate + i]);

                          ////Ending Value PV
                          var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                          var inf = Number(inflation[0].percentage) / 100;
                          var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                          endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();
                          //endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k)));


                          ////Ending Value - Taxable
                          TaxableEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) * TaxableProp).toFixed();

                          TaxFreeEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) - TaxFreeProp).toFixed();
                          //TaxableEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) * TaxableProp);

                          //TaxFreeEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) - TaxFreeProp);


                          obj["BegValues"] = begVal;
                          obj["TaxableBegValues"] = TaxableBegVal;
                          obj["TaxFreeBegValues"] = TaxFreeBegVal;
                          obj["growthValues"] = growth;
                          obj["incomeValues"] = income;
                          obj["frankingCreditsValues"] = frankingCredits;
                          obj["pensionIncomeValues"] = pensionIncome;
                          obj["pITaxAssessableValues"] = pITaxAssessable;
                          obj["pITaxExemptValues"] = pITaxExempt;
                          obj["endingValues"] = endingVal;
                          obj["endingValuesPV"] = endingValPV;
                          obj["TaxableEndingValues"] = TaxableEndingVal;
                          obj["TaxFreeEndingValues"] = TaxFreeEndingVal;
                          //TODO: Verify
                          obj["taxableProp"] = TaxableProp;
                          obj["taxfreeProp"] = TaxFreeProp;


                          if (this.PensionValue.find((y: any) => y.owner === x.pensionId) != null) {
                              this.PensionValue[this.PensionValue.findIndex((c: any) => c.owner === x.pensionId)] = obj;
                          }
                          else {
                              this.PensionValue.push(obj);

                          }

                          
                      });

                      //Pension - Partner
                      this.pensionPartner.forEach((x: any) => { // client

                          this.pensionDrawDown = this.pensionDD.filter((c: any) => c.pensionId === x.pensionId);


                          if (x.pensionRebootFromType == "Start" || x.pensionRebootFromType == "Existing") {
                              x.pensionRebootFromDate = this.clientDetails.startDate
                          }
                          else if (x.pensionRebootFromType == "Partner Retirement") {
                              x.pensionRebootFromDate = this.clientDetails.partnerRetirementYear - 1;
                          }
                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Retain") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                          }
                          else if (x.endDateType == "Partner Retirement") {
                              x.endDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          var obj = this.PensionValue.find((y: any) => y.owner === x.pensionId);
                          var begVal: any = {};
                          var TaxableBegVal: any = {};
                          var TaxFreeBegVal: any = {};

                          var growth: any = {};
                          var income: any = {};
                          var frankingCredits: any = {};

                          var pensionIncome: any = {};
                          var pITaxAssessable: any = {};
                          var pITaxExempt: any = {};

                          var endingVal: any = {};
                          var TaxableEndingVal: any = {};
                          var TaxFreeEndingVal: any = {};
                          var endingValPV: any = {};
                          var TaxableProp: number = 0;
                          var TaxFreeProp: number = 0;

                          if (obj == null) {
                              obj = {};
                              TaxableProp = 0;
                              TaxFreeProp = 0;
                          }
                          else {
                              begVal = obj.BegValues;
                              TaxableBegVal = obj.TaxableBegValues;
                              TaxFreeBegVal = obj.TaxFreeBegValues;
                              growth = obj.growthValues;
                              income = obj.incomeValues;
                              frankingCredits = obj.frankingCreditsValues;
                              pensionIncome = obj.pensionIncomeValues;
                              pITaxAssessable = obj.pITaxAssessableValues;
                              pITaxExempt = obj.pITaxExemptValues;
                              endingVal = obj.endingValues;
                              TaxableEndingVal = obj.TaxableEndingValues;
                              TaxFreeEndingVal = obj.TaxFreeEndingValues;
                              endingValPV = obj.endingValuesPV;
                              TaxableProp = obj.taxableProp;
                              TaxFreeProp = obj.taxfreeProp;

                          }


                          obj["owner"] = x.pensionId;
                          obj["type"] = "Partner";
                          obj["name"] = "Opening Value";


                          if (x.pensionRebootFromDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              //BeginningValue
                              if (m == 1) {
                                  if (x.pensionRebootFromType == "Existing") {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  if ((this.clientDetails.startDate + i) == x.pensionRebootFromDate) {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.pensionRebootFromDate) {

                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {

                                      begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                                  }
                              }


                              if ((this.clientDetails.startDate + i) == x.pensionRebootFromDate || x.pensionRebootFromType == "Existing") {
                                  //TODO Confirm negative
                                  if (x.taxableComponent != 0 && x.value != 0) {
                                      TaxableProp = (Number(x.taxableComponent) / Number(x.value));
                                  }
                                  else {
                                      TaxableProp = 0;
                                  }
                                  TaxFreeProp = 1 - TaxableProp;

                                  TaxableBegVal[this.clientDetails.startDate + i] = x.taxableComponent.toFixed();
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = x.taxFreeComponent.toFixed();
                              }
                              else if ((this.clientDetails.startDate + i) < x.pensionRebootFromDate) {

                                  TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {

                                  TaxableBegVal[this.clientDetails.startDate + i] = Number(TaxableEndingVal[Number(this.clientDetails.startDate + i) - 1]);
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = Number(TaxFreeEndingVal[Number(this.clientDetails.startDate + i) - 1]);
                              }
                          }
                          else {
                              TaxableBegVal[this.clientDetails.startDate + i] = 0;
                              TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                              begVal[this.clientDetails.startDate + i] = 0;
                          }


                          ////growth & income
                          var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                          var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                          var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                          var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                          var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                          if (typeof growthVal === "number" && !isNaN(growthVal)) {
                              growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                          }
                          else {
                              growth[this.clientDetails.startDate + i] = 0;
                          }

                          if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                              income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                          }
                          else {
                              income[this.clientDetails.startDate + i] = 0;
                          }

                          //FrankingCredits

                          var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                          var ctr = Number(corporateTaxRate[0].percentage) / 100;

                          frankingCredits[this.clientDetails.startDate + i] = (Number(income[this.clientDetails.startDate + i]) * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                          //pension Income
                          var preservation = this.preservationAge.sort((a: any, b: any) => a.dob - b.dob);
                          var minPendionDD = this.minimumPensionDrawdown.sort((a: any, b: any) => a.age - b.age);
                          var currentYear = this.clientDetails.startDate + i;
                          var pAge: number = 0;
                          var minRate: number = 0;

                          for (var k = 0; k < preservation.length; k++) {


                              if ((k == (preservation.length - 1)) && (this.clientDetails.partnerDob >= preservation[k].dob)) {
                                  pAge = preservation[k].age;

                              }
                              else if (k == 0 && ((this.clientDetails.partnerDob) <= preservation[k].dob)) {
                                  pAge = preservation[k].age;
                                  break;

                              }
                              else if ((this.clientDetails.partnerDob) > preservation[k].dob && (this.clientDetails.partnerDob) <= preservation[k + 1].dob) {
                                  pAge = preservation[k + 1].age;
                                  break;

                              }
                          }
                          var date1 = new Date("7/01/ " + (this.clientDetails.startDate + i));
                          var date2 = new Date(this.clientDetails.partnerDob);
                          var timeDiff = Math.abs(date2.getTime() - date1.getTime());
                          var diffDays = (Math.ceil(timeDiff / (1000 * 3600 * 24))) / 365;

                          var partnerAge = Math.round(diffDays * 10) / 10;

                          for (var l = 0; l < minPendionDD.length; l++) {


                              if ((l == (minPendionDD.length - 1)) && (partnerAge >= minPendionDD[l].age)) {
                                  minRate = minPendionDD[l].minimumDrawdown;

                              }
                              else if (l == 0 && (partnerAge <= minPendionDD[l].age)) {
                                  minRate = minPendionDD[l].minimumDrawdown;
                                  break;

                              }
                              else if (partnerAge > minPendionDD[l].age && partnerAge <= minPendionDD[l + 1].age) {
                                  minRate = minPendionDD[l + 1].minimumDrawdown;
                                  break;

                              }
                          }


                          var minDrawdown: number = 0;
                          var maxDrawdown: number = 0;

                          if (partnerAge < pAge) {
                              minDrawdown = 0;
                              maxDrawdown = 0;
                          }
                          else if (partnerAge >= pAge && partnerAge < 65) {
                              if (this.partnerRetirementYear != 0 && this.partnerRetirementYear <= (this.clientDetails.startDate + i)) {
                                  minDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (minRate / 100);
                                  maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]);

                              }
                              else {
                                  minDrawdown = 0;
                                  maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (10 / 100);
                              }

                          }
                          else if (partnerAge >= 65) {
                              minDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (minRate / 100);
                              maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]);
                          }


                          if (x.pensionRebootFromDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {

                              if (this.pensionDrawDown.length > 0) {
                                  let pIncomeSum: number = 0;
                                  this.pensionDrawDown.forEach((y: any) => {

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.amount == 0) {
                                              if (y.type == "Minimum") {
                                                  pensionIncome[this.clientDetails.startDate + i] = minDrawdown.toFixed();
                                              } else if (y.type == "Maximum") {
                                                  pensionIncome[this.clientDetails.startDate + i] = maxDrawdown.toFixed();
                                              }
                                          }
                                          else {
                                              pensionIncome[this.clientDetails.startDate + i] = (Math.min(maxDrawdown, Math.max(minDrawdown, y.amount))).toFixed();
                                          }
                                          //var t = parseInt(y.amount);
                                          //ContributionSum = ContributionSum + t;
                                      }

                                  });
                              }
                                else {
                                      pensionIncome[this.clientDetails.startDate + i] = 0;
                                  }

                          }
                          else {
                              pensionIncome[this.clientDetails.startDate + i] = 0;
                          }


                          if (partnerAge >= pAge && partnerAge < 60) {
                              pITaxAssessable[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) * TaxableProp).toFixed();
                              pITaxExempt[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) - pITaxAssessable[this.clientDetails.startDate + i]).toFixed();
                          }
                          else if (partnerAge >= 60) {
                              pITaxAssessable[this.clientDetails.startDate + i] = 0;
                              pITaxExempt[this.clientDetails.startDate + i] = Number(pensionIncome[this.clientDetails.startDate + i]).toFixed();
                          }

                          //Ending Value
                          endingVal[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(pensionIncome[this.clientDetails.startDate + i]);

                          ////Ending Value PV
                          var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                          var inf = Number(inflation[0].percentage) / 100;
                          var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                          endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                          ////Ending Value - Taxable
                          TaxableEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) * TaxableProp).toFixed();

                          TaxFreeEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) - TaxFreeProp).toFixed();


                          obj["BegValues"] = begVal;
                          obj["TaxableBegValues"] = TaxableBegVal;
                          obj["TaxFreeBegValues"] = TaxFreeBegVal;
                          obj["growthValues"] = growth;
                          obj["incomeValues"] = income;
                          obj["frankingCreditsValues"] = frankingCredits;
                          obj["pensionIncomeValues"] = pensionIncome;
                          obj["pITaxAssessableValues"] = pITaxAssessable;
                          obj["pITaxExemptValues"] = pITaxExempt;
                          obj["endingValues"] = endingVal;
                          obj["endingValuesPV"] = endingValPV;
                          obj["TaxableEndingValues"] = TaxableEndingVal;
                          obj["TaxFreeEndingValues"] = TaxFreeEndingVal;
                          //TODO: Verify
                          obj["taxableProp"] = TaxableProp;
                          obj["taxfreeProp"] = TaxFreeProp;


                          if (this.PensionValue.find((y: any) => y.owner === x.pensionId) != null) {
                              this.PensionValue[this.PensionValue.findIndex((c: any) => c.owner === x.pensionId)] = obj;
                          }
                          else {
                              this.PensionValue.push(obj);

                          }


                      });

                      //PensionTotals

                      this.calculateTotalPensionIncome("TotalPensionIncome", i);
                      this.calculatePensionIncomeTaxable("PensionIncome-client", "Client", i);
                      this.calculatePensionIncomeTaxable("PensionIncome-partner", "Partner", i);
                      this.calculateSuperIncomeTaxOffset("SIncomeTaxOffset-client", "Client", i);
                      this.calculateSuperIncomeTaxOffset("SIncomeTaxOffset-partner", "Partner", i);



                      //Super Client
                      this.superClient.forEach((x: any) => { // client

                          this.superSS = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "SS");
                          this.superPNC = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "PNC");
                          this.superSpouse = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "Spouse");
                          this.superLumpSum = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "LumpSum");


                          if (x.startDateType == "Start" || x.startDateType == "Existing") {
                              x.startDate = this.clientDetails.startDate
                          }
                          else if (x.startDateType == "Client Retirement") {
                              x.startDate = this.clientDetails.clientRetirementYear - 1;
                          }
                        
                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Retain") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                          }
                          else if (x.endDateType == "Client Retirement") {
                              x.endDate = this.clientDetails.clientRetirementYear - 1;
                          }
                         

                          var obj = this.SuperValue.find((y: any) => y.owner === x.superId);
                          var begVal: any = {};
                          var TaxableBegVal: any = {};
                          var TaxFreeBegVal: any = {};
                          var growth: any = {};
                          var income: any = {};
                          var frankingCredits: any = {};
                          var insurance: any = {};
                          var sgContr: any = {};
                          var ssContr: any = {};
                          var pncContr: any = {};
                          var spouseContr: any = {};
                          var lumpSum: any = {};
                          var lumpSumTaxable: any = {};
                          var taxPayable: any = {};

                          var endingVal: any = {};
                          var TaxableEndingVal: any = {};
                          var TaxFreeEndingVal: any = {};
                          var endingValPV: any = {};

                          if (obj == null) {
                              obj = {};

                          }
                          else {
                              begVal = obj.BegValues;
                              TaxableBegVal = obj.TaxableBegValues;
                              TaxFreeBegVal = obj.TaxFreeBegValues;
                              growth = obj.growthValues;
                              income = obj.incomeValues;
                              frankingCredits = obj.frankingCreditsValues;

                              insurance = obj.insuranceValues;
                              sgContr = obj.sgContrValues;
                              ssContr = obj.ssContrValues;
                              pncContr = obj.pncContrValues;
                              spouseContr = obj.spouseContrValues;
                              lumpSum = obj.lumpSumValues;
                              lumpSumTaxable = obj.lumpSumTaxableValues;
                              taxPayable = obj.taxPayableValues;

                              endingVal = obj.endingValues;
                              TaxableEndingVal = obj.TaxableEndingValues;
                              TaxFreeEndingVal = obj.TaxFreeEndingValues;
                              endingValPV = obj.endingValuesPV;


                          }


                          obj["owner"] = x.superId;
                          obj["type"] = "Client";
                          obj["name"] = "Opening Value";

                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              //BeginningValue
                              if (m == 1) {
                                  if (x.startDateType == "Existing") {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  if ((this.clientDetails.startDate + i) == x.startDate) {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.startDate) {

                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {

                                      begVal[this.clientDetails.startDate + i] = (Number(endingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                  }
                              }


                              if ((this.clientDetails.startDate + i) == x.startDate) {
                                  TaxableBegVal[this.clientDetails.startDate + i] = x.taxableComponent.toFixed();
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = x.taxFreeComponent.toFixed();
                              }
                              else if ((this.clientDetails.startDate + i) < x.startDate) {

                                  TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {

                                  TaxableBegVal[this.clientDetails.startDate + i] = (Number(TaxableEndingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = (Number(TaxFreeEndingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                              }
                          }
                          else {
                              TaxableBegVal[this.clientDetails.startDate + i] = 0;
                              TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                              begVal[this.clientDetails.startDate + i] = 0;
                          }


                          ////growth & income
                          var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                          var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                          var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                          var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                          var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                          if (typeof growthVal === "number" && !isNaN(growthVal)) {
                              growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                          }
                          else {
                              growth[this.clientDetails.startDate + i] = 0;
                          }

                          if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                              income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                          }
                          else {
                              income[this.clientDetails.startDate + i] = 0;
                          }

                          //FrankingCredits

                          var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                          var ctr = Number(corporateTaxRate[0].percentage) / 100;

                          frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                          //insurance

                          let insuranceVal: number = 0;

                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              insuranceVal = parseInt(x.insuranceCost);
                          }

                          insurance[this.clientDetails.startDate + i] = insuranceVal;

                          //Super Guarantee

                          var cc_cap = this.superAssumptions.filter((a: any) => a.type == "CC_Cap");
                          var cc_cap_val = cc_cap[0].value;

                          var ncc_cap = this.superAssumptions.filter((a: any) => a.type == "NCC_Cap");
                          var ncc_cap_val = cc_cap[0].value;

                          var mscb = this.superAssumptions.filter((a: any) => a.type == "MSCB");
                          var mscb_val = mscb[0].value;


                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              if (x.increaseToLimit == "Y") {

                                  let ContributionSum: number = 0;
                                  this.superSS.forEach((y: any) => {

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          var t = parseInt(y.amount);
                                          ContributionSum = ContributionSum + t;
                                      }

                                  });

                                  sgContr[this.clientDetails.startDate + i] = (cc_cap_val - ContributionSum).toFixed();
                              }
                              else {
                                  //TODO: get SGCRatev-verify
                                  var sgcRate: number = 1;

                                  if (x.sgrate == "SGC") {
                                      var sgc = this.sgcRates.sort((a: any, b: any) => a.year - b.year);
                                      var currentYear = this.clientDetails.startDate + i;


                                      for (var j = 0; j < sgc.length; j++) {


                                          if ((j == (sgc.length - 1)) && ((this.clientDetails.startDate + i) >= sgc[j].year)) {
                                              sgcRate = sgc[j].sgcrate1;

                                          }
                                          else if (j == 0 && ((this.clientDetails.startDate + i) <= sgc[j].year)) {
                                              sgcRate = sgc[j].sgcrate1;
                                              break;

                                          }
                                          else if ((this.clientDetails.startDate + i) > sgc[j].year && (this.clientDetails.startDate + i) <= sgc[j + 1].year) {
                                              sgcRate = sgc[j + 1].sgcrate1;
                                              break;

                                          }
                                      }

                                  }
                                  else {
                                      sgcRate = Number(x.sgrate);
                                  }

                                  var cEmploymentIncome = clientEmploymentIncome.filter((g: any) => g.type === "Employment");

                                  var totalcEmploymentIncome = 0;
                                  for (var k = 0; k < cEmploymentIncome.length; k++) {
                                      if (isNaN(cEmploymentIncome[k].values[this.clientDetails.startDate + i])) {
                                          continue;
                                      }
                                      totalcEmploymentIncome += Number(cEmploymentIncome[k].values[this.clientDetails.startDate + i]);
                                  }




                                  // sgContr[this.clientDetails.startDate + i] = Math.min((x.superSalary * (sgcRate / 100)), mscb_val);
                                  sgContr[this.clientDetails.startDate + i] = (Math.min((totalcEmploymentIncome * (sgcRate / 100)), mscb_val)).toFixed();

                              }
                          }
                          else {
                              sgContr[this.clientDetails.startDate + i] = 0;
                          }

                          //Salary Sacrifice

                          let SalarySacrificeSum: number = 0;
                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              this.superSS.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      if (y.increaseToLimit == "Y") {

                                          var sgContr: number = 0;
                                          var sgcRate: number = 1;



                                          if (x.sgrate == "SGC") {
                                              var sgc = this.sgcRates.sort((a: any, b: any) => a.year - b.year);
                                              var currentYear = this.clientDetails.startDate + i;
                                              for (var j = 0; j < sgc.length; j++) {
                                                  if ((j == (sgc.length - 1)) && ((this.clientDetails.startDate + i) >= sgc[j].year)) {
                                                      sgcRate = sgc[j].sgcrate1;

                                                  }
                                                  else if (j == 0 && ((this.clientDetails.startDate + i) <= sgc[j].year)) {
                                                      sgcRate = sgc[j].sgcrate1;
                                                      break;

                                                  }
                                                  else if ((this.clientDetails.startDate + i) > sgc[j].year && (this.clientDetails.startDate + i) <= sgc[j + 1].year) {
                                                      sgcRate = sgc[j + 1].sgcrate1;
                                                      break;

                                                  }
                                              }

                                          }
                                          else {
                                              sgcRate = Number(x.sgrate);
                                          }

                                          var cEmploymentIncome = clientEmploymentIncome.filter((g: any) => g.type === "Employment");

                                          var totalcEmploymentIncome = 0;
                                          for (var k = 0; k < cEmploymentIncome.length; k++) {
                                              if (isNaN(cEmploymentIncome[k].values[this.clientDetails.startDate + i])) {
                                                  continue;
                                              }
                                              totalcEmploymentIncome += Number(cEmploymentIncome[k].values[this.clientDetails.startDate + i]);
                                          }

                                          //sgContr = Math.min((x.superSalary * (sgcRate / 100)), mscb_val);
                                          sgContr = Math.min((totalcEmploymentIncome * (sgcRate / 100)), mscb_val);
                                          SalarySacrificeSum = cc_cap_val - sgContr;
                                      }
                                      else {
                                          var t = parseInt(y.amount);
                                          SalarySacrificeSum = SalarySacrificeSum + t;
                                      }



                                  }

                              });

                              ssContr[this.clientDetails.startDate + i] = (SalarySacrificeSum).toFixed();
                          }
                          else {
                              ssContr[this.clientDetails.startDate + i] = 0;
                          }

                          //PNC Contribution
                          let PNCContributionSum: number = 0;
                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              this.superPNC.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      if (y.increaseToLimit == "Y") {
                                          let SpouseSum: number = 0;
                                          this.superSpouse.forEach((y: any) => {

                                              if (y.fromDateType == "Start") {
                                                  y.fromDate = this.clientDetails.startDate;
                                              }
                                              if (y.toDateType == "End") {
                                                  y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                              }

                                              if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                  var t = parseInt(y.amount);
                                                  SpouseSum = SpouseSum + t;
                                              }

                                          });

                                          PNCContributionSum = ncc_cap_val - SpouseSum;

                                      }
                                      else {
                                          var t = parseInt(y.amount);
                                          PNCContributionSum = PNCContributionSum + t;
                                      }
                                  }

                              });
                              pncContr[this.clientDetails.startDate + i] = (PNCContributionSum).toFixed();;
                          }
                          else {
                              pncContr[this.clientDetails.startDate + i] = 0;
                          }

                          //Spouse Contribution
                          let SpouseContributionSum: number = 0;
                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              this.superSpouse.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      if (y.increaseToLimit == "Y") {
                                          let PNCSum: number = 0;
                                          this.superPNC.forEach((y: any) => {

                                              if (y.fromDateType == "Start") {
                                                  y.fromDate = this.clientDetails.startDate;
                                              }
                                              if (y.toDateType == "End") {
                                                  y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                              }

                                              if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                  var t = parseInt(y.amount);
                                                  PNCSum = PNCSum + t;
                                              }

                                          });

                                          SpouseContributionSum = ncc_cap_val - PNCSum;

                                      }
                                      else {
                                          var t = parseInt(y.amount);
                                          SpouseContributionSum = SpouseContributionSum + t;
                                      }
                                  }

                              });
                              spouseContr[this.clientDetails.startDate + i] = (SpouseContributionSum).toFixed();
                          }
                          else {
                              spouseContr[this.clientDetails.startDate + i] = 0;
                          }
                          //Lumpsum Withdrawals
                          let LumpsumWithdrawalsSum: number = 0;
                          let LumpsumTaxableSum: number = 0;
                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              this.superLumpSum.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      var t = parseInt(y.amount);
                                      LumpsumWithdrawalsSum = LumpsumWithdrawalsSum + t;
                                  }

                              });
                              lumpSum[this.clientDetails.startDate + i] = LumpsumWithdrawalsSum;


                              if (LumpsumWithdrawalsSum > 0) {
                                  var TaxableBeforLS = Number(TaxableBegVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]);
                                  //TODO: Add govtContr
                                  var ValueBeforeLS = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) + Number(pncContr[this.clientDetails.startDate + i]) + Number(spouseContr[this.clientDetails.startDate + i]);
                                  if (TaxableBeforLS != 0 && ValueBeforeLS != 0) {
                                      lumpSumTaxable[this.clientDetails.startDate + i] = LumpsumWithdrawalsSum * (TaxableBeforLS / ValueBeforeLS);
                                  }
                                  else {
                                      lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                              }

                          }
                          else {
                              lumpSum[this.clientDetails.startDate + i] = 0;
                              lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                          }


                          //Taxes Payable
                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              var earningsTax = this.superAssumptions.filter((a: any) => a.type == "EarningsTaxRate");
                              var earningsTax_val = earningsTax[0].value;

                              var ccTaxRate = this.superAssumptions.filter((a: any) => a.type == "CCTaxRate");
                              var ccTaxRate_val = ccTaxRate[0].value;

                              var addTaxRate = this.superAssumptions.filter((a: any) => a.type == "AddTaxRate");
                              var addTaxRate_val = addTaxRate[0].value;

                              let ccTax: number = 0;
                              var EarningsTax = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i])) * (earningsTax_val / 100);

                              //var taxableIncome: any = {};
                              //taxableIncome = this.clientTaxableIncome.filter(c => c.owner === "ClientTaxableIncome");
                              //let taxableIncomeVal: number = Number(taxableIncome[0].values[this.clientDetails.startDate + i]);
                              //if (taxableIncomeVal <= 250000) {
                              ccTax = (Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i])) * (ccTaxRate_val / 100);
                              //}
                              //else {
                              //    ccTax = (sgContr[this.clientDetails.startDate + i] + ssContr[this.clientDetails.startDate + i]) * ((ccTaxRate_val / 100) + (addTaxRate_val / 100));

                              //}
                              taxPayable[this.clientDetails.startDate + i] = (EarningsTax + ccTax).toFixed()
                          }
                          else {
                              taxPayable[this.clientDetails.startDate + i] = 0;
                          }




                          //Ending Value
                          endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) + Number(pncContr[this.clientDetails.startDate + i]) + Number(spouseContr[this.clientDetails.startDate + i]) - Number(taxPayable[this.clientDetails.startDate + i]) - Number(lumpSum[this.clientDetails.startDate + i])).toFixed()

                          ////Ending Value PV
                          var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                          var inf = Number(inflation[0].percentage) / 100;
                          var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                          endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                          //Ending Value - Taxable
                          TaxableEndingVal[this.clientDetails.startDate + i] = (Number(TaxableBegVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) - Number(taxPayable[this.clientDetails.startDate + i]) - Number(lumpSum[this.clientDetails.startDate + i])).toFixed();

                          TaxFreeEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) - Number(TaxableEndingVal[this.clientDetails.startDate + i])).toFixed();


                          obj["BegValues"] = begVal;
                          obj["TaxableBegValues"] = TaxableBegVal;
                          obj["TaxFreeBegValues"] = TaxFreeBegVal;
                          obj["growthValues"] = growth;
                          obj["incomeValues"] = income;
                          obj["frankingCreditsValues"] = frankingCredits;
                          obj["insuranceValues"] = insurance;
                          obj["sgContrValues"] = sgContr;
                          obj["ssContrValues"] = ssContr;
                          obj["pncContrValues"] = pncContr;
                          obj["spouseContrValues"] = spouseContr;
                          obj["lumpSumValues"] = lumpSum;
                          obj["lumpSumTaxableValues"] = lumpSumTaxable;
                          obj["taxPayableValues"] = taxPayable;
                          obj["endingValues"] = endingVal;
                          obj["endingValuesPV"] = endingValPV;
                          obj["TaxableEndingValues"] = TaxableEndingVal;
                          obj["TaxFreeEndingValues"] = TaxFreeEndingVal;

                          if (this.SuperValue.find((y: any) => y.owner === x.superId) != null) {
                              this.SuperValue[this.SuperValue.findIndex((c: any) => c.owner === x.superId)] = obj;
                          }
                          else {
                              this.SuperValue.push(obj);

                          }

                      });

                      this.superPartner.forEach((x: any) => { // client

                          this.superSS = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "SS");
                          this.superPNC = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "PNC");
                          this.superSpouse = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "Spouse");
                          this.superLumpSum = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "LumpSum");


                          if (x.startDateType == "Start" || x.startDateType == "Existing") {
                              x.startDate = this.clientDetails.startDate
                          }  
                          else if (x.startDateType == "Partner Retirement") {
                              x.startDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Retain") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                          }
                          else if (x.endDateType == "Partner Retirement") {
                              x.endDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          var obj = this.SuperValue.find((y: any) => y.owner === x.superId);
                          var begVal: any = {};
                          var TaxableBegVal: any = {};
                          var TaxFreeBegVal: any = {};
                          var growth: any = {};
                          var income: any = {};
                          var frankingCredits: any = {};
                          var insurance: any = {};
                          var sgContr: any = {};
                          var ssContr: any = {};
                          var pncContr: any = {};
                          var spouseContr: any = {};
                          var lumpSum: any = {};
                          var lumpSumTaxable: any = {};
                          var taxPayable: any = {};

                          var endingVal: any = {};
                          var TaxableEndingVal: any = {};
                          var TaxFreeEndingVal: any = {};
                          var endingValPV: any = {};

                          if (obj == null) {
                              obj = {};

                          }
                          else {
                              begVal = obj.BegValues;
                              TaxableBegVal = obj.TaxableBegValues;
                              TaxFreeBegVal = obj.TaxFreeBegValues;
                              growth = obj.growthValues;
                              income = obj.incomeValues;
                              frankingCredits = obj.frankingCreditsValues;

                              insurance = obj.insuranceValues;
                              sgContr = obj.sgContrValues;
                              ssContr = obj.ssContrValues;
                              pncContr = obj.pncContrValues;
                              spouseContr = obj.spouseContrValues;
                              lumpSum = obj.lumpSumValues;
                              lumpSumTaxable = obj.lumpSumTaxableValues;
                              taxPayable = obj.taxPayableValues;

                              endingVal = obj.endingValues;
                              TaxableEndingVal = obj.TaxableEndingValues;
                              TaxFreeEndingVal = obj.TaxFreeEndingValues;
                              endingValPV = obj.endingValuesPV;


                          }


                          obj["owner"] = x.superId;
                          obj["type"] = "Partner";
                          obj["name"] = "Opening Value";

                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              //BeginningValue
                              if (m == 1) {
                                  if (x.startDateType == "Existing") {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  if ((this.clientDetails.startDate + i) == x.startDate) {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.startDate) {

                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {

                                      begVal[this.clientDetails.startDate + i] = (Number(endingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                  }
                              }


                              if ((this.clientDetails.startDate + i) == x.startDate) {
                                  TaxableBegVal[this.clientDetails.startDate + i] = x.taxableComponent.toFixed();
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = x.taxFreeComponent.toFixed();
                              }
                              else if ((this.clientDetails.startDate + i) < x.startDate) {

                                  TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {

                                  TaxableBegVal[this.clientDetails.startDate + i] = (Number(TaxableEndingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = (Number(TaxFreeEndingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                              }
                          }
                          else {
                              TaxableBegVal[this.clientDetails.startDate + i] = 0;
                              TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                              begVal[this.clientDetails.startDate + i] = 0;
                          }


                          ////growth & income
                          var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                          var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                          var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                          var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                          var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                          if (typeof growthVal === "number" && !isNaN(growthVal)) {
                              growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                          }
                          else {
                              growth[this.clientDetails.startDate + i] = 0;
                          }

                          if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                              income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                          }
                          else {
                              income[this.clientDetails.startDate + i] = 0;
                          }

                          //FrankingCredits

                          var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                          var ctr = Number(corporateTaxRate[0].percentage) / 100;

                          frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                          //insurance

                          let insuranceVal: number = 0;

                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              insuranceVal = parseInt(x.insuranceCost);
                          }

                          insurance[this.clientDetails.startDate + i] = insuranceVal;

                          //Super Guarantee

                          var cc_cap = this.superAssumptions.filter((a: any) => a.type == "CC_Cap");
                          var cc_cap_val = cc_cap[0].value;

                          var ncc_cap = this.superAssumptions.filter((a: any) => a.type == "NCC_Cap");
                          var ncc_cap_val = cc_cap[0].value;

                          var mscb = this.superAssumptions.filter((a: any) => a.type == "MSCB");
                          var mscb_val = mscb[0].value;


                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              if (x.increaseToLimit == "Y") {

                                  let ContributionSum: number = 0;
                                  this.superSS.forEach((y: any) => {

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          var t = parseInt(y.amount);
                                          ContributionSum = ContributionSum + t;
                                      }

                                  });

                                  sgContr[this.clientDetails.startDate + i] = (cc_cap_val - ContributionSum).toFixed();
                              }
                              else {
                                  //TODO: get SGCRatev-verify
                                  var sgcRate: number = 1;

                                  if (x.sgrate == "SGC") {
                                      var sgc = this.sgcRates.sort((a: any, b: any) => a.year - b.year);
                                      var currentYear = this.clientDetails.startDate + i;


                                      for (var j = 0; j < sgc.length; j++) {


                                          if ((j == (sgc.length - 1)) && ((this.clientDetails.startDate + i) >= sgc[j].year)) {
                                              sgcRate = sgc[j].sgcrate1;

                                          }
                                          else if (j == 0 && ((this.clientDetails.startDate + i) <= sgc[j].year)) {
                                              sgcRate = sgc[j].sgcrate1;
                                              break;

                                          }
                                          else if ((this.clientDetails.startDate + i) > sgc[j].year && (this.clientDetails.startDate + i) <= sgc[j + 1].year) {
                                              sgcRate = sgc[j + 1].sgcrate1;
                                              break;

                                          }
                                      }

                                  }
                                  else {
                                      sgcRate = Number(x.sgrate);
                                  }

                                  var pEmploymentIncome = partnerEmploymentIncome.filter((g: any) => g.type === "Employment");

                                  var totalpEmploymentIncome = 0;
                                  for (var k = 0; k < pEmploymentIncome.length; k++) {
                                      if (isNaN(pEmploymentIncome[k].values[this.clientDetails.startDate + i])) {
                                          continue;
                                      }
                                      totalpEmploymentIncome += Number(pEmploymentIncome[k].values[this.clientDetails.startDate + i]);
                                  }

                                  //TODO: Verify if correct
                                  //sgContr[this.clientDetails.startDate + i] = Math.min((x.superSalary * (sgcRate / 100)), mscb_val);
                                  sgContr[this.clientDetails.startDate + i] = (Math.min((totalpEmploymentIncome * (sgcRate / 100)), mscb_val)).toFixed();

                              }
                          }
                          else {
                              sgContr[this.clientDetails.startDate + i] = 0;
                          }

                          //Salary Sacrifice

                          let SalarySacrificeSum: number = 0;
                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              this.superSS.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      if (y.increaseToLimit == "Y") {

                                          var sgContr: number = 0;
                                          var sgcRate: number = 1;



                                          if (x.sgrate == "SGC") {
                                              var sgc = this.sgcRates.sort((a: any, b: any) => a.year - b.year);
                                              var currentYear = this.clientDetails.startDate + i;
                                              for (var j = 0; j < sgc.length; j++) {
                                                  if ((j == (sgc.length - 1)) && ((this.clientDetails.startDate + i) >= sgc[j].year)) {
                                                      sgcRate = sgc[j].sgcrate1;

                                                  }
                                                  else if (j == 0 && ((this.clientDetails.startDate + i) <= sgc[j].year)) {
                                                      sgcRate = sgc[j].sgcrate1;
                                                      break;

                                                  }
                                                  else if ((this.clientDetails.startDate + i) > sgc[j].year && (this.clientDetails.startDate + i) <= sgc[j + 1].year) {
                                                      sgcRate = sgc[j + 1].sgcrate1;
                                                      break;

                                                  }
                                              }

                                          }
                                          else {
                                              sgcRate = Number(x.sgrate);
                                          }

                                          var pEmploymentIncome = partnerEmploymentIncome.filter((g: any) => g.type === "Employment");

                                          var totalpEmploymentIncome = 0;
                                          for (var k = 0; k < pEmploymentIncome.length; k++) {
                                              if (isNaN(pEmploymentIncome[k].values[this.clientDetails.startDate + i])) {
                                                  continue;
                                              }
                                              totalpEmploymentIncome += Number(pEmploymentIncome[k].values[this.clientDetails.startDate + i]);
                                          }

                                          //TODO: Verify if correct
                                          sgContr = Math.min((totalpEmploymentIncome * (sgcRate / 100)), mscb_val);
                                          SalarySacrificeSum = cc_cap_val - sgContr;
                                      }
                                      else {
                                          var t = parseInt(y.amount);
                                          SalarySacrificeSum = SalarySacrificeSum + t;
                                      }



                                  }

                              });

                              ssContr[this.clientDetails.startDate + i] = (SalarySacrificeSum).toFixed();
                          }
                          else {
                              ssContr[this.clientDetails.startDate + i] = 0;
                          }

                          //PNC Contribution
                          let PNCContributionSum: number = 0;
                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              this.superPNC.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      if (y.increaseToLimit == "Y") {
                                          let SpouseSum: number = 0;
                                          this.superSpouse.forEach((y: any) => {

                                              if (y.fromDateType == "Start") {
                                                  y.fromDate = this.clientDetails.startDate;
                                              }
                                              if (y.toDateType == "End") {
                                                  y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                              }

                                              if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                  var t = parseInt(y.amount);
                                                  SpouseSum = SpouseSum + t;
                                              }

                                          });

                                          PNCContributionSum = ncc_cap_val - SpouseSum;

                                      }
                                      else {
                                          var t = parseInt(y.amount);
                                          PNCContributionSum = PNCContributionSum + t;
                                      }
                                  }

                              });
                              pncContr[this.clientDetails.startDate + i] = (PNCContributionSum).toFixed();
                          }
                          else {
                              pncContr[this.clientDetails.startDate + i] = 0;
                          }

                          //Spouse Contribution
                          let SpouseContributionSum: number = 0;
                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              this.superSpouse.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      if (y.increaseToLimit == "Y") {
                                          let PNCSum: number = 0;
                                          this.superPNC.forEach((y: any) => {

                                              if (y.fromDateType == "Start") {
                                                  y.fromDate = this.clientDetails.startDate;
                                              }
                                              if (y.toDateType == "End") {
                                                  y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                              }

                                              if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                  var t = parseInt(y.amount);
                                                  PNCSum = PNCSum + t;
                                              }

                                          });

                                          SpouseContributionSum = ncc_cap_val - PNCSum;

                                      }
                                      else {
                                          var t = parseInt(y.amount);
                                          SpouseContributionSum = SpouseContributionSum + t;
                                      }
                                  }

                              });
                              spouseContr[this.clientDetails.startDate + i] = (SpouseContributionSum).toFixed();
                          }
                          else {
                              spouseContr[this.clientDetails.startDate + i] = 0;
                          }
                          //Lumpsum Withdrawals
                          let LumpsumWithdrawalsSum: number = 0;
                          let LumpsumTaxableSum: number = 0;
                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              this.superLumpSum.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      var t = parseInt(y.amount);
                                      LumpsumWithdrawalsSum = LumpsumWithdrawalsSum + t;
                                  }

                              });
                              lumpSum[this.clientDetails.startDate + i] = LumpsumWithdrawalsSum;


                              if (LumpsumWithdrawalsSum > 0) {
                                  var TaxableBeforLS = Number(TaxableBegVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]);
                                  //TODO: Add govtContr
                                  var ValueBeforeLS = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) + Number(pncContr[this.clientDetails.startDate + i]) + Number(spouseContr[this.clientDetails.startDate + i]);
                                  if (TaxableBeforLS != 0 && ValueBeforeLS != 0) {
                                      lumpSumTaxable[this.clientDetails.startDate + i] = LumpsumWithdrawalsSum * (TaxableBeforLS / ValueBeforeLS);
                                  }
                                  else {
                                      lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                              }

                          }
                          else {
                              lumpSum[this.clientDetails.startDate + i] = 0;
                              lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                          }


                          //Taxes Payable
                          if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                              var earningsTax = this.superAssumptions.filter((a: any) => a.type == "EarningsTaxRate");
                              var earningsTax_val = earningsTax[0].value;

                              var ccTaxRate = this.superAssumptions.filter((a: any) => a.type == "CCTaxRate");
                              var ccTaxRate_val = ccTaxRate[0].value;

                              var addTaxRate = this.superAssumptions.filter((a: any) => a.type == "AddTaxRate");
                              var addTaxRate_val = addTaxRate[0].value;

                              let ccTax: number = 0;
                              var EarningsTax = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i])) * (earningsTax_val / 100);

                              //var taxableIncome: any = {};
                              //taxableIncome = this.clientTaxableIncome.filter(c => c.owner === "ClientTaxableIncome");
                              //let taxableIncomeVal: number = Number(taxableIncome[0].values[this.clientDetails.startDate + i]);
                              //if (taxableIncomeVal <= 250000) {
                              ccTax = (Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i])) * (ccTaxRate_val / 100);
                              //}
                              //else {
                              //    ccTax = (sgContr[this.clientDetails.startDate + i] + ssContr[this.clientDetails.startDate + i]) * ((ccTaxRate_val / 100) + (addTaxRate_val / 100));

                              //}
                              taxPayable[this.clientDetails.startDate + i] = (EarningsTax + ccTax).toFixed()
                          }
                          else {
                              taxPayable[this.clientDetails.startDate + i] = 0;
                          }




                          //Ending Value
                          endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) + Number(pncContr[this.clientDetails.startDate + i]) + Number(spouseContr[this.clientDetails.startDate + i]) - Number(taxPayable[this.clientDetails.startDate + i]) - Number(lumpSum[this.clientDetails.startDate + i])).toFixed()

                          ////Ending Value PV
                          var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                          var inf = Number(inflation[0].percentage) / 100;
                          var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                          endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                          //Ending Value - Taxable
                          TaxableEndingVal[this.clientDetails.startDate + i] = (Number(TaxableBegVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) - Number(taxPayable[this.clientDetails.startDate + i]) - Number(lumpSum[this.clientDetails.startDate + i])).toFixed();

                          TaxFreeEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) - Number(TaxableEndingVal[this.clientDetails.startDate + i])).toFixed();


                          obj["BegValues"] = begVal;
                          obj["TaxableBegValues"] = TaxableBegVal;
                          obj["TaxFreeBegValues"] = TaxFreeBegVal;
                          obj["growthValues"] = growth;
                          obj["incomeValues"] = income;
                          obj["frankingCreditsValues"] = frankingCredits;
                          obj["insuranceValues"] = insurance;
                          obj["sgContrValues"] = sgContr;
                          obj["ssContrValues"] = ssContr;
                          obj["pncContrValues"] = pncContr;
                          obj["spouseContrValues"] = spouseContr;
                          obj["lumpSumValues"] = lumpSum;
                          obj["lumpSumTaxableValues"] = lumpSumTaxable;
                          obj["taxPayableValues"] = taxPayable;
                          obj["endingValues"] = endingVal;
                          obj["endingValuesPV"] = endingValPV;
                          obj["TaxableEndingValues"] = TaxableEndingVal;
                          obj["TaxFreeEndingValues"] = TaxFreeEndingVal;

                          if (this.SuperValue.find((y: any) => y.owner === x.superId) != null) {
                              this.SuperValue[this.SuperValue.findIndex((c: any) => c.owner === x.superId)] = obj;
                          }
                          else {
                              this.SuperValue.push(obj);

                          }


                      });

                      //SuperTotals
                      this.calculateTotalLumpSumWithdrawals("TotalLumpSumWithdrawals", i);
                      this.calculateTotalSalarySacrificeContribution("TotalSalarySacrificeContributions", i);
                      this.calculateTotalPNCContibution("TotalPNCContributions", i);
                      this.calculateTotalSpouseContibution("TotalSpouseContributions", i);
                      this.calculateLumpSumTax("LumpSum-client", "Client", i);
                      this.calculateSalarySacrificeTax("SalarySacrifice-client", "Client", i);
                      this.calculateLumpSumTax("LumpSum-partner", "Partner", i);
                      this.calculateSalarySacrificeTax("SalarySacrifice-partner", "Partner", i);


                      //Calculate Tax Deductions
                      this.EPRTClient.forEach((x: any) => { // client

                          if (x.startDateType == "Start") {
                              x.startDate = this.clientDetails.startDate
                          }
                          else if (x.startDateType == "Client Retirement") {
                              x.startDate = this.clientDetails.clientRetirementYear - 1;
                          }

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Client Retirement") {
                              x.endDate = this.clientDetails.clientRetirementYear - 1;
                          }

                          var obj = this.ClientDeductions.find((y: any) => y.id === x.cflowId);
                          var obj1: any = {};
                          var j: number = 0;
                          if (obj == null) {
                              obj = {};
                              j = 0;
                          }
                          else {
                              obj1 = obj.values;
                              j = obj.increment;
                          }
                          obj["owner"] = x.owner;
                          obj["name"] = x.cfname;
                          obj["id"] = x.cflowId;


                          if (q == 0) {
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;
                          }

                          if (this.ClientDeductions.find((y: any) => y.id === x.cflowId) != null) {
                              this.ClientDeductions[this.ClientDeductions.findIndex((c: any) => c.id === x.cflowId)] = obj;
                          }
                          else {
                              this.ClientDeductions.push(obj);
                          }

                      })
                      this.EPRTPartner.forEach((x: any) => { // client

                          if (x.startDateType == "Start") {
                              x.startDate = this.clientDetails.startDate
                          }
                          else if (x.startDateType == "Partner Retirement") {
                              x.startDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Partner Retirement") {
                              x.endDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          var obj = this.PartnerDeductions.find((y: any) => y.id === x.cflowId);
                          var obj1: any = {};
                          var j: number = 0;
                          if (obj == null) {
                              obj = {};
                              j = 0;
                          }
                          else {
                              obj1 = obj.values;
                              j = obj.increment;
                          }
                          obj["owner"] = x.owner;
                          obj["name"] = x.cfname;
                          obj["id"] = x.cflowId;

                          if (q == 0) {
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;
                          }


                          if (this.PartnerDeductions.find((y: any) => y.id === x.cflowId) != null) {
                              this.PartnerDeductions[this.PartnerDeductions.findIndex((c: any) => c.id === x.cflowId)] = obj;
                          }
                          else {
                              this.PartnerDeductions.push(obj);
                          }

                      })
                      this.EPRTJoint.forEach((x: any) => { // joint

                          if (x.startDateType == "Start") {
                              x.startDate = this.clientDetails.startDate
                          }
                          else if (x.startDateType == "Client Retirement") {
                              x.startDate = this.clientDetails.clientRetirementYear - 1;
                          }
                          else if (x.startDateType == "Partner Retirement") {
                              x.startDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Client Retirement") {
                              x.endDate = this.clientDetails.clientRetirementYear - 1;
                          }
                          else if (x.endDateType == "Partner Retirement") {
                              x.endDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          var obj = this.ClientDeductions.find((y: any) => y.id === "ClientJoint" + x.cflowId);
                          var obj1: any = {};
                          var j: number = 0;
                          if (obj == null) {
                              obj = {};
                              j = 0;
                          }
                          else {
                              obj1 = obj.values;
                              j = obj.increment;
                          }
                          obj["owner"] = "Client";
                          obj["name"] = x.cfname;
                          obj["id"] = "ClientJoint" + x.cflowId;

                          if (q == 0) {
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = (x.value / 2).toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = ((x.value * (Math.pow((1 + x.indexation / 100), j))) / 2).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;
                          }


                          if (this.ClientDeductions.find((y: any) => y.id === "ClientJoint" + x.cflowId) != null) {
                              this.ClientDeductions[this.ClientDeductions.findIndex((c: any) => c.id === "ClientJoint" + x.cflowId)] = obj;
                          }
                          else {
                              this.ClientDeductions.push(obj);
                          }

                      })
                      this.EPRTJoint.forEach((x: any) => { // joint

                          if (x.startDateType == "Start") {
                              x.startDate = this.clientDetails.startDate
                          }
                          else if (x.startDateType == "Client Retirement") {
                              x.startDate = this.clientDetails.clientRetirementYear - 1;
                          }
                          else if (x.startDateType == "Partner Retirement") {
                              x.startDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          if (x.endDateType == "End") {
                              x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                          }
                          else if (x.endDateType == "Client Retirement") {
                              x.endDate = this.clientDetails.clientRetirementYear - 1;
                          }
                          else if (x.endDateType == "Partner Retirement") {
                              x.endDate = this.clientDetails.partnerRetirementYear - 1;
                          }

                          var obj = this.PartnerDeductions.find((y: any) => y.id === "PartnerJoint" + x.cflowId);
                          var obj1: any = {};
                          var j: number = 0;
                          if (obj == null) {
                              obj = {};
                              j = 0;
                          }
                          else {
                              obj1 = obj.values;
                              j = obj.increment;
                          }
                          obj["owner"] = "Partner";
                          obj["name"] = x.cfname;
                          obj["id"] = "PartnerJoint" + x.cflowId;

                          if (q == 0) {

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = (x.value / 2).toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = ((x.value * (Math.pow((1 + x.indexation / 100), j))) / 2).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;
                          }

                          if (this.PartnerDeductions.find((y: any) => y.id === "PartnerJoint" + x.cflowId) != null) {
                              this.PartnerDeductions[this.PartnerDeductions.findIndex((c: any) => c.id === "PartnerJoint" + x.cflowId)] = obj;
                          }
                          else {
                              this.PartnerDeductions.push(obj);
                          }

                      })


                      ////Calculate Tax Totals

                      this.calculateTotalTaxIncome("TotalTax-client", "Client", i);
                      this.calculateCapitalLossAdjustment("CLA-client", "Client", i);
                      this.calculateTotalAssessibleIncome("ClientAssessibleIncome", "TotalTax-client", "Client", i);
                      this.calculateClientTotalDeductions("ClientDeductions", "Client", i);
                      this.calculateClientTaxableIncome(i);
                      this.calculateLowIncomeTO("ClientLowIncomeTO", "ClientTaxableIncome", "Client", i);
                      this.calculateRefundableTaxOffset("ClientFrankingCredits", "Client", i);

                      this.calculateClientTotalNRTaxOffset("ClientTotalTO", "ClientLowIncomeTO", i);
                      this.calculateGrossTax("ClientGrossTax", "ClientTaxableIncome", "Client", i);
                      this.calculateMedicareLevy("ClientMedicareLevy", "ClientTaxableIncome", "Client", i);

                      this.calculateTaxPayableNonRefundable("ClientTPNonRefundable", "ClientGrossTax", "ClientTotalTO", "Client", i);
                      this.calculateTaxPayableRefundable("ClientTPRefundable", "ClientTPNonRefundable", "ClientFrankingCredits", "Client", i);
                      this.calculateTotalTaxesPayable("ClientTotalTaxPayable", "ClientTPRefundable", "ClientMedicareLevy", "Client", i);
                      this.calculateAverageTaxRate("ClientAverageTaxRate", "ClientTotalTaxPayable", "ClientAssessibleIncome", "Client", i);
                      this.calculateMarginalTaxRate("ClientMarginalTaxRate", "ClientTaxableIncome", "Client", i);


                      this.calculateTotalTaxIncome("TotalTax-partner", "Partner", i);

                      this.calculateCapitalLossAdjustment("CLA-partner", "Partner", i);
                      this.calculateTotalAssessibleIncome("PartnerAssessibleIncome", "TotalTax-partner", "Partner", i);
                      this.calculatePartnerTotalDeductions("PartnerDeductions", "Partner", i);
                      this.calculatePartnerTaxableIncome(i);
                      this.calculateLowIncomeTO("PartnerLowIncomeTO", "PartnerTaxableIncome", "Partner", i);
                      this.calculateRefundableTaxOffset("PartnerFrankingCredits", "Partner", i);

                      this.calculatePartnerTotalNRTaxOffset("PartnerTotalTO", "PartnerLowIncomeTO", i);
                      this.calculateGrossTax("PartnerGrossTax", "PartnerTaxableIncome", "Partner", i);
                      this.calculateMedicareLevy("PartnerMedicareLevy", "PartnerTaxableIncome", "Partner", i);

                      this.calculateTaxPayableNonRefundable("PartnerTPNonRefundable", "PartnerGrossTax", "PartnerTotalTO", "Partner", i);
                      this.calculateTaxPayableRefundable("PartnerTPRefundable", "PartnerTPNonRefundable", "PartnerFrankingCredits", "Partner", i);
                      this.calculateTotalTaxesPayable("PartnerTotalTaxPayable", "PartnerTPRefundable", "PartnerMedicareLevy", "Partner", i);
                      this.calculateAverageTaxRate("PartnerAverageTaxRate", "PartnerTotalTaxPayable", "PartnerAssessibleIncome", "Partner", i);
                      this.calculateMarginalTaxRate("PartnerMarginalTaxRate", "PartnerTaxableIncome", "Partner", i);
                      this.calculateTotalIncomeTaxPayable("TotalITPayable", i);



                      //Calculate Cashflow Totals
                      this.calculateTotalIncome("Total-client", "Client", i);
                      this.calculateTotalIncome("Total-partner", "Partner", i);
                      this.calculateTotalExpenditure("Total-client", "Client", i);
                      this.calculateTotalExpenditure("Total-partner", "Partner", i);
                      this.calculateTotalExpenditure("Total-joint", "Joint", i);

                      this.calculateTotalInflows(i);
                      this.calculateTotalOutflows(i);
                      this.calculateNetCashflow(i,q,highestVal);
                      this.calculateNetAsset(i);

                      //Centrelink

                      this.calculateEligiblePeriod("EligiblePeriod-client", "Client", i);
                      this.calculateEligiblePeriod("EligiblePeriod-partner", "Partner", i);

                    

                                     }

                  m++;
              }

              var t = this.CentrelinkTotal;

           

              // Optimizer Logic
              var indexRangeInflowOptimized: any = [];
              var indexRangeOutflowOptimized: any = [];

              var clientEmploymentIncomeOptimized: any = [];
              var partnerEmploymentIncomeOptimized: any = [];
              var n = 1;

             
              for (var w = 0; w < this.clientDetails.period; w++)
              {
                  var strategyOrder: any[] = [];
                 // var p: number = 0;
                  //1st year
                  if (w == 0) {

                      var clientCurrentAge = Number(this.clientAge + w);

                      //Calculate NRR
                      var marginalTaxRate: number = 0;

                      if (this.TotalPayable.filter(c => c.owner === "ClientMarginalTaxRate")[0].values[this.clientDetails.startDate + w] != 0) {
                          marginalTaxRate = Number(this.TotalPayable.filter(c => c.owner === "ClientMarginalTaxRate")[0].values[this.clientDetails.startDate + w]) / 100;
                      }
                      else {
                          marginalTaxRate = 0;
                      }
                      var openingVal: any[] = [];
                      var cashSurplus: any = {};
                      var existingCashSurplus = this.netCashFlow.filter(c => c.owner === "NetCashflow");
                      cashSurplus["name"] = "Cash Surplus";
                      cashSurplus["value"] = Number(existingCashSurplus[0].values[this.clientDetails.startDate + w]);
                      console.log(cashSurplus);
                      if (this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].growth != 0) {
                          cashSurplus["growth"] = Number(this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].growth) / 100;
                      }
                      else {
                          cashSurplus["growth"] = 0;
                      }
                      if (this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].income != 0) {
                          cashSurplus["income"] = Number(this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].income) / 100;
                      }
                      else {
                          cashSurplus["income"] = 0;
                      }

                      cashSurplus["reinvest"] = "Y";
                      cashSurplus["status"] = "Existing";
                      cashSurplus["type"] = "CashSurplus";

                      let varCSNRR = (Number(cashSurplus["growth"]) + Number(cashSurplus["income"])) * (1 - marginalTaxRate);
                      cashSurplus["NRR"] = varCSNRR;

                      openingVal.push(cashSurplus);

                      this.investmentClientOptimized.forEach((x: any) => {
                          var inclient = this.BeginningValue.filter(c => c.owner === x.investmentId);
                          var obj: any = {};
                          obj["name"] = x.name;
                          obj["id"] = x.investmentId;
                          obj["owner"] = x.owner;
                          if (x.reinvest == "Y") {
                              obj["value"] = Number(inclient[0].BegValues[this.clientDetails.startDate + w]) + Number(inclient[0].growthValues[this.clientDetails.startDate + w]) + Number(inclient[0].incomeValues[this.clientDetails.startDate + w]);
                          }
                          else {
                              obj["value"] = Number(inclient[0].BegValues[this.clientDetails.startDate + w]) + Number(inclient[0].growthValues[this.clientDetails.startDate + w]);
                          }
                          obj["growth"] = Number(x.growth) / 100;
                          obj["income"] = Number(x.income) / 100;
                          obj["reinvest"] = x.reinvest;
                          obj["status"] = "Existing";
                          obj["status"] = "Existing";

                          var NRR: number = 0;
                          NRR = ((Number(x.growth) / 100) + (Number(x.income) / 100)) * (1 - marginalTaxRate);
                          //NRR = (Number(x.growth) / 100) + ((Number(x.income) / 100) * (1 - marginalTaxRate));
                          obj["NRR"] = NRR;
                          openingVal.push(obj);

                      });

                      let cash: number = 0;
                      openingVal.forEach((x: any) => {
                          var t = parseInt(x.value);
                          cash = cash + t;
                      });



                      //Check Eigibility

                      var SalarySacrifice: any = {};
                      var NCC: any = {};
                      var Debt: any = {};
                      var Investment: any = {};
                      var strategies: any[] = [];

                      //SS eligibiltiy

                      if (clientCurrentAge < 65) {
                          SalarySacrifice["type"] = "SS";
                          strategies.push(SalarySacrifice);
                      }
                      else if (clientCurrentAge >= 65 && clientCurrentAge < 75) {
                          var cEmploymentIncome = clientEmploymentIncome.filter((g: any) => g.type === "Employment");
                          for (var j = 0; j < cEmploymentIncome.length; j++) {

                              if (Number(cEmploymentIncome[j].values[this.clientDetails.startDate + w]) > 0) {
                                  SalarySacrifice["type"] = "SS";
                                  strategies.push(SalarySacrifice);
                                  break;
                              }
                          }

                      }

                      //NCC eligibility

                      if (clientCurrentAge < 65) {
                          NCC["type"] = "NCC";
                          strategies.push(NCC);
                      }
                      else if (clientCurrentAge >= 65 && clientCurrentAge < 75) {
                          var cEmploymentIncome = clientEmploymentIncome.filter((g: any) => g.type === "Employment");
                          for (var j = 0; j < cEmploymentIncome.length; j++) {

                              if (Number(cEmploymentIncome[j].values[this.clientDetails.startDate + w]) > 0) {
                                  NCC["type"] = "NCC";
                                  strategies.push(NCC);
                                  break;
                              }
                          }

                      }

                      //Investment eligibilty
                      Investment["type"] = "Investment";
                      strategies.push(Investment);


                      //Debt eligibility

                      for (var j = 0; j < this.liabilityClient.length; j++) {
                          var lbclient = this.LBValue.filter(c => c.owner === this.liabilityClient[j].liabilityId);
                          if (Number(lbclient[0].BegValues[this.clientDetails.startDate + w]) > 0) {
                              Debt["type"] = "Debt";
                              strategies.push(Debt);
                              break;
                          }
                      }

                      console.log(strategies);
                      //Net Impact
                      var NRR: any[] = [];
                      strategies.forEach((x: any) => {

                          if (x.type == "SS") {
                              this.superClient.forEach((x: any) => {
                                  var obj: any = {};
                                  obj["name"] = "Salary Sacrifice";
                                  obj["id"] = x.superId;
                                  obj["type"] = "SS";
                                  obj["status"] = "Strategy";
                                  var val: number = 0;
                                  val = (marginalTaxRate - (15 / 100)) + (((Number(x.growth) / 100) + (Number(x.income) / 100)) * (1 - (15 / 100)));
                                  //val = (marginalTaxRate - (15 / 100)) + (Number(x.growth) / 100) + (((Number(x.income) / 100)) * (1 - (15 / 100)));
                                  obj["NRR"] = val;
                                  NRR.push(obj);

                              });
                          }
                          else if (x.type == "NCC") {
                              this.superClient.forEach((x: any) => {
                                  var obj: any = {};
                                  obj["name"] = "Non-concessional Contribution";
                                  obj["id"] = x.superId;
                                  obj["type"] = "NCC";
                                  obj["status"] = "Strategy";
                                  var val: number = 0;
                                  val = ((Number(x.growth) / 100) + (Number(x.income) / 100)) * (1 - (15 / 100));
                                  //val = (Number(x.growth) / 100) + ((Number(x.income) / 100) * (1 - (15 / 100)));
                                  obj["NRR"] = val;
                                  NRR.push(obj);

                              });
                          }
                          else if (x.type == "Investment") {
                              var growth = Number(this.assetAssumptions.filter((a: any) => a.name == this.clientDetails.clientRiskProfile)[0].growth) / 100;
                              var income = Number(this.assetAssumptions.filter((a: any) => a.name == this.clientDetails.clientRiskProfile)[0].income) / 100;
                              var obj: any = {};
                              //obj["NRR"] = Number(growth + ( income * (1 - marginalTaxRate)));
                              obj["NRR"] = Number((growth + income) * (1 - marginalTaxRate));
                              obj["type"] = "Investment";
                              obj["name"] = "Investment";
                              obj["status"] = "Strategy";
                              obj["id"] = 0;
                              NRR.push(obj);

                          }
                          else if (x.type == "Debt") {

                              this.liabilityClient.forEach((x: any) => {
                                  var obj: any = {};
                                  obj["name"] = x.name;
                                  obj["id"] = x.liabilityId;
                                  obj["type"] = "Debt";
                                  obj["status"] = "Strategy";
                                  var val: number = 0;
                                  if (x.type == "Non-Deductible") {
                                      if (marginalTaxRate != 1) {
                                          val = ((x.interestRate / 100) / (1 - marginalTaxRate));
                                      }
                                      else {
                                          val = 0;
                                      }
                                  }
                                  else {
                                      val = (x.interestRate / 100);
                                  }
                                  obj["NRR"] = val;
                                  NRR.push(obj);
                              });
                          }
                      });

                      console.log(NRR);

                      NRR.forEach((x: any) => {
                          strategyOrder.push(x);
                      });


                      openingVal.forEach((x: any) => {
                          strategyOrder.push(x);
                      });

                      console.log(strategyOrder);
                      strategyOrder = strategyOrder.sort(function (obj1: any, obj2: any) {
                          return obj2.NRR - obj1.NRR;
                      });

                      console.log(strategyOrder);
                      var existingCash = cash;
     
                      strategyOrder.forEach((x: any) => {
                          if (existingCash > 0 && x.type != "CashSurplus") {

                              if (x.type == "SS") {
                                  var sg = this.SuperValue.filter(c => c.owner === x.id);
                                  var sgRate = Number(sg[0].sgContrValues[this.clientDetails.startDate + w]);
                                  var cap = 25000 - sgRate;

                                  if (existingCash >= cap) {
                                      x["AllocatedValue"] = cap;
                                      existingCash = existingCash - cap;
                                  }
                                  else {
                                      x["AllocatedValue"] = existingCash;
                                      existingCash = 0;
                                  }

                              }
                              else if (x.type == "NCC") {
                                  var cap = 100000;

                                  if (existingCash >= cap) {
                                      x["AllocatedValue"] = cap;
                                      existingCash = existingCash - cap;
                                  }
                                  else {
                                      x["AllocatedValue"] = existingCash;
                                      existingCash = 0;
                                  }
                              }
                              else if (x.type == "Debt") {
                                  var liability = this.LBValue.filter(c => c.owner === x.id);
                                  var liabilityVal = Number(liability[0].BegValues[this.clientDetails.startDate + w]) + Number(liability[0].accruedInterestValues[this.clientDetails.startDate + w]);


                                  if (existingCash >= liabilityVal) {
                                      x["AllocatedValue"] = liabilityVal;
                                      existingCash = existingCash - liabilityVal;
                                  }
                                  else {
                                      x["AllocatedValue"] = existingCash;
                                      existingCash = 0;
                                  }
                              }
                              else {
                                  if (existingCash >= 0) {
                                      x["AllocatedValue"] = existingCash;
                                      existingCash = 0;
                                  }
                              }
                          }
                          else {
                              x["AllocatedValue"] = 0;
                          }
                      });


                      strategyOrder.forEach((x: any) => {
                         

                          
                          if (x.type != "CashSurplus") {
                              var obj: any = {};
                              if (x.type == "SS") {

                                  obj = this.finalStrategies.filter((y: any) => y.type === "SS").filter((a: any) => a.id === x.id)

                              }
                              else if (x.type == "NCC") {
                                  obj = this.finalStrategies.filter((y: any) => y.type === "NCC").filter((a: any) => a.id === x.id)

                              }
                              else if (x.type == "Debt") {
                                  obj = this.finalStrategies.filter((y: any) => y.type === "Debt").filter((a: any) => a.id === x.id)
                              }
                              else if (x.type == "Investment") {

                                  obj = this.finalStrategies.filter((y: any) => (y.type === "Investment"))
                              }
                              else {
                                  obj = this.finalStrategies.filter((y: any) => y.status === "Existing").filter((a: any) => a.id === x.id)
                              }
                              //}

                              var obj1: any = {};

                              if (obj == null || obj.length <= 0) {
                                  obj = {};

                              }
                              else {
                                  obj1 = obj.values;

                              }

                              obj["name"] = x.name;
                              obj["id"] = x.id;
                              obj["type"] = x.type;
                              obj["status"] = x.status;

                              obj1[this.clientDetails.startDate + w] = x.AllocatedValue.toFixed();



                              obj["values"] = obj1;

                              if (x.type == "SS") {
                                  var t = this.finalStrategies.filter((y: any) => y.type === "SS").filter((a: any) => a.id === x.id)

                                  if (t != null && t.length > 0) {
                                      // this.finalStrategies[this.finalStrategies.findIndex((y: any) => (y.id === x.id && y.type === "SS"))] = obj;
                                      for (i = 0; i < this.finalStrategies.length; i++) {
                                          if (this.finalStrategies[i].id == x.id && this.finalStrategies[i].type == "SS") {
                                              this.finalStrategies[i] = obj
                                          }
                                      }
                                  }
                                  else {
                                      this.finalStrategies.push(obj);

                                  }
                              }
                              else if (x.type == "NCC") {
                                  var t = this.finalStrategies.filter((y: any) => y.type === "NCC").filter((a: any) => a.id === x.id)



                                  if (t != null && t.length > 0) {

                                      for (i = 0; i < this.finalStrategies.length; i++) {
                                          if (this.finalStrategies[i].id == x.id && this.finalStrategies[i].type == "NCC") {
                                              this.finalStrategies[i] = obj
                                          }
                                      }

                                  }
                                  else {
                                      this.finalStrategies.push(obj);

                                  }
                              }
                              else if (x.type == "Debt") {
                                  var t = this.finalStrategies.filter((y: any) => y.type === "Debt").filter((a: any) => a.id === x.id)

                                  if (t != null && t.length > 0) {
                                      // this.finalStrategies[this.finalStrategies.findIndex(t:)] = obj;
                                      for (i = 0; i < this.finalStrategies.length; i++) {
                                          if (this.finalStrategies[i].id == x.id && this.finalStrategies[i].type == "Debt") {
                                              this.finalStrategies[i] = obj
                                          }
                                      }
                                  }
                                  else {
                                      this.finalStrategies.push(obj);

                                  }
                              }
                              else if (x.type == "Investment") {

                                  var t = this.finalStrategies.filter((y: any) => y.type === "Investment")

                                  if (t != null && t.length > 0) {
                                      // this.finalStrategies[this.finalStrategies.findIndex(t:)] = obj;
                                      for (i = 0; i < this.finalStrategies.length; i++) {
                                          if (this.finalStrategies[i].type == "Investment") {
                                              this.finalStrategies[i] = obj
                                          }
                                      }
                                  }
                                  else {
                                      this.finalStrategies.push(obj);

                                  }
                              }
                              else {
                                  var t = this.finalStrategies.filter((y: any) => y.status === "Existing").filter((a: any) => a.id === x.id)

                                  if (t != null && t.length > 0) {

                                      for (i = 0; i < this.finalStrategies.length; i++) {
                                          if (this.finalStrategies[i].id == x.id && this.finalStrategies[i].status == "Existing") {
                                              this.finalStrategies[i] = obj
                                          }
                                      }
                                  }
                                  else {
                                      this.finalStrategies.push(obj);

                                  }
                              }
                          }
                      });

                    


                      for (var i = w; i < 1; i++) {

                          //Add new investment
                          var newInvestmentStrategy = strategyOrder.filter(c => c.type === "Investment");
                          if (newInvestmentStrategy.length > 0 && (newInvestmentStrategy[0].AllocatedValue > 0)) {
                              var clientGrowth = this.assetAssumptions.filter((a: any) => a.name == this.clientDetails.clientRiskProfile)[0].growth;
                              var clientIncome = this.assetAssumptions.filter((a: any) => a.name == this.clientDetails.clientRiskProfile)[0].income;
                              var clientFranked = this.assetAssumptions.filter((a: any) => a.name == this.clientDetails.clientRiskProfile)[0].franking;
                              var clientProductFees = this.assetAssumptions.filter((a: any) => a.name == this.clientDetails.clientRiskProfile)[0].productFees;
                              var clientid = Math.max.apply(Math, this.investmentClientOptimized.map(function (o: any) { return o.investmentId }));
                              var investmentDetails: any = {
                                  investmentId: Number(clientid) + 1,
                                  clientId: 0,
                                  type: this.clientDetails.clientRiskProfile,
                                  name: 'Investment Portfolio',
                                  owner: 'Client',
                                  value: Number(newInvestmentStrategy[0].AllocatedValue),
                                  growth: clientGrowth,
                                  income: clientIncome,
                                  franked: clientFranked,
                                  productFees: clientProductFees,
                                  costBase: 0,
                                  reinvest: 'Y',
                                  centrelink: 'N',
                                  startDateType: 'Year',
                                  startDate: Number(this.clientDetails.startDate + i),
                                  endDateType: 'Retain',
                                  endDate: 0
                              };

                              this.investmentClientOptimized.push(investmentDetails);

                          }



                          //Client LifeStyles
                          this.lifestyleClient.forEach((x: any) => { // client

                              var obj = this.lifestylesOptimized.find((y: any) => y.id === x.lassetId);
                              var obj1: any = {};
                              var purchaseOfAssets: any = {};
                              var saleOfAssets: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  purchaseOfAssets = obj.purchaseOfAssetValues;
                                  saleOfAssets = obj.saleOfAssetValues;
                                  j = obj.increment;
                              }

                              obj["owner"] = x.owner;
                              obj["name"] = x.name;

                              obj["id"] = x.lassetId;
                              obj["type"] = x.lassetType;

                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate;
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                            

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                           

                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              else if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (x.lassetType == "PrimaryResidence") {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }

                              //Purchase of assets
                              if (x.startDateType != "Existing") {

                                  if (x.startDate == this.clientDetails.startDate + i) {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Sale of assets
                              if (x.endDateType != "Retain") {

                                  if (x.endDate == this.clientDetails.startDate + i) {
                                      if (x.lassetType == "PrimaryResidence") {
                                          if (j == 0) {
                                              saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();

                                          }
                                          else {
                                              saleOfAssets[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                          }
                                          j++;
                                      }
                                      else {
                                          saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }

                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }


                              obj["values"] = obj1;
                              obj["increment"] = j;
                              obj["purchaseOfAssetValues"] = purchaseOfAssets;
                              obj["saleOfAssetValues"] = saleOfAssets;


                              if (this.lifestylesOptimized.find((y: any) => y.id === x.lassetId) != null) {
                                  this.lifestylesOptimized[this.lifestylesOptimized.findIndex((c: any) => c.id === x.lassetId)] = obj;
                              }
                              else {
                                  this.lifestylesOptimized.push(obj);
                              }

                          })
                          this.lifestylePartner.forEach((x: any) => {

                              var obj = this.lifestylesOptimized.find((y: any) => y.id === x.lassetId);
                              var obj1: any = {};
                              var purchaseOfAssets: any = {};
                              var saleOfAssets: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  purchaseOfAssets = obj.purchaseOfAssetValues;
                                  saleOfAssets = obj.saleOfAssetValues;
                                  j = obj.increment;
                              }

                              obj["owner"] = x.owner;
                              obj["name"] = x.name;

                              obj["id"] = x.lassetId;
                              obj["type"] = x.lassetType;

                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              else if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (x.lassetType == "PrimaryResidence") {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }

                              //Purchase of assets
                              if (x.startDateType != "Existing") {

                                  if (x.startDate == this.clientDetails.startDate + i) {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Sale of assets
                              if (x.endDateType != "Retain") {

                                  if (x.endDate == this.clientDetails.startDate + i) {
                                      if (x.lassetType == "PrimaryResidence") {
                                          if (j == 0) {
                                              saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();

                                          }
                                          else {
                                              saleOfAssets[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                          }
                                          j++;
                                      }
                                      else {
                                          saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }

                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }


                              obj["values"] = obj1;
                              obj["increment"] = j;
                              obj["purchaseOfAssetValues"] = purchaseOfAssets;
                              obj["saleOfAssetValues"] = saleOfAssets;


                              if (this.lifestylesOptimized.find((y: any) => y.id === x.lassetId) != null) {
                                  this.lifestylesOptimized[this.lifestylesOptimized.findIndex((c: any) => c.id === x.lassetId)] = obj;
                              }
                              else {
                                  this.lifestylesOptimized.push(obj);
                              }

                          })
                          this.lifestyleJoint.forEach((x: any) => {

                              var obj = this.lifestylesOptimized.find((y: any) => y.id === x.lassetId);
                              var obj1: any = {};
                              var purchaseOfAssets: any = {};
                              var saleOfAssets: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  purchaseOfAssets = obj.purchaseOfAssetValues;
                                  saleOfAssets = obj.saleOfAssetValues;
                                  j = obj.increment;
                              }

                              obj["owner"] = x.owner;
                              obj["name"] = x.name;

                              obj["id"] = x.lassetId;
                              obj["type"] = x.lassetType;

                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate;
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              else if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (x.lassetType == "PrimaryResidence") {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }

                              //Purchase of assets
                              if (x.startDateType != "Existing") {

                                  if (x.startDate == this.clientDetails.startDate + i) {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Sale of assets
                              if (x.endDateType != "Retain") {

                                  if (x.endDate == this.clientDetails.startDate + i) {
                                      if (x.lassetType == "PrimaryResidence") {
                                          if (j == 0) {
                                              saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();

                                          }
                                          else {
                                              saleOfAssets[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                          }
                                          j++;
                                      }
                                      else {
                                          saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }

                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }


                              obj["values"] = obj1;
                              obj["increment"] = j;
                              obj["purchaseOfAssetValues"] = purchaseOfAssets;
                              obj["saleOfAssetValues"] = saleOfAssets;


                              if (this.lifestylesOptimized.find((y: any) => y.id === x.lassetId) != null) {
                                  this.lifestylesOptimized[this.lifestylesOptimized.findIndex((c: any) => c.id === x.lassetId)] = obj;
                              }
                              else {
                                  this.lifestylesOptimized.push(obj);
                              }

                          })
                          this.calculateTotalLASaleProceedsOptimized("TotalLASales", i);
                          this.calculateTotalLAPropertyExpensesOptimized("TotalLAPurchase", i);


                          this.cfiClient.forEach((x: any) => { // client
                              var obj = indexRangeInflowOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;
                              obj["type"] = x.type;
                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                            

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }

                                  j++;

                              }

                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }

                              obj["values"] = obj1;
                              obj["increment"] = j;

                              if (indexRangeInflowOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  indexRangeInflowOptimized[indexRangeInflowOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                                  clientEmploymentIncomeOptimized[clientEmploymentIncomeOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                                  this.IncomeOptimized[this.IncomeOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  indexRangeInflowOptimized.push(obj);
                                  this.IncomeOptimized.push(obj);
                                  clientEmploymentIncomeOptimized.push(obj);
                              }
                          });
                          this.cfiPartner.forEach((x: any) => { // partner
                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = indexRangeInflowOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }


                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;
                              obj["type"] = x.type;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;

                              if (indexRangeInflowOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  indexRangeInflowOptimized[indexRangeInflowOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                                  partnerEmploymentIncomeOptimized[partnerEmploymentIncomeOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                                  this.IncomeOptimized[this.IncomeOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  indexRangeInflowOptimized.push(obj);
                                  this.IncomeOptimized.push(obj);
                                  partnerEmploymentIncomeOptimized.push(obj);
                              }

                          })
                          //    //Todo -TaxIncome Total
                          this.cfiClient.forEach((x: any) => { // client

                              if (x.type != "Non-Taxable") {
                                  if (x.startDateType == "Start") {
                                      x.startDate = this.clientDetails.startDate
                                  }
                                  else if (x.startDateType == "Client Retirement") {
                                      x.startDate = this.clientDetails.clientRetirementYear - 1;
                                  }
                                 
                                  //TODO : Reconfirm end date
                                  if (x.endDateType == "End") {
                                      x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }
                                  else if (x.endDateType == "Client Retirement") {
                                      x.endDate = this.clientDetails.clientRetirementYear - 1;
                                  }
                                 

                                  var obj = indexRangeInflowOptimized.find((y: any) => y.id === "Tax" + x.cflowId);
                                  var obj1: any = {};
                                  var j: number = 0;
                                  if (obj == null) {
                                      obj = {};
                                      j = 0;
                                  }
                                  else {
                                      obj1 = obj.values;
                                      j = obj.increment;
                                  }
                                  obj["owner"] = "ClientIncome-tax";
                                  obj["name"] = x.cfname;
                                  obj["id"] = "Tax" + x.cflowId;


                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                                  obj["values"] = obj1;
                                  obj["increment"] = j;

                                  if (indexRangeInflowOptimized.find((y: any) => y.id === "Tax" + x.cflowId) != null) {
                                      indexRangeInflowOptimized[indexRangeInflowOptimized.findIndex((c: any) => c.id === "Tax" + x.cflowId)] = obj;
                                      this.IncomeOptimized[this.IncomeOptimized.findIndex((c: any) => c.id === "Tax" + x.cflowId)] = obj;
                                  }
                                  else {
                                      indexRangeInflowOptimized.push(obj);
                                      this.IncomeOptimized.push(obj);
                                  }
                              }

                          })
                          this.cfiPartner.forEach((x: any) => { // partner
                              if (x.type != "Non-Taxable") {
                                  if (x.startDateType == "Start") {
                                      x.startDate = this.clientDetails.startDate
                                  }
                                  else if (x.startDateType == "Partner Retirement") {
                                      x.startDate = this.clientDetails.partnerRetirementYear - 1;
                                  }

                                  if (x.endDateType == "End") {
                                      x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }
                                  else if (x.endDateType == "Partner Retirement") {
                                      x.endDate = this.clientDetails.partnerRetirementYear - 1;
                                  }

                                  var obj = indexRangeInflowOptimized.find((y: any) => y.id === "Tax" + x.cflowId);
                                  var obj1: any = {};
                                  var j: number = 0;
                                  if (obj == null) {
                                      obj = {};
                                      j = 0;
                                  }
                                  else {
                                      obj1 = obj.values;
                                      j = obj.increment;
                                  }
                                  obj["owner"] = "PartnerIncome-tax";
                                  obj["name"] = x.cfname;
                                  obj["id"] = "Tax" + x.cflowId;



                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                                  obj["values"] = obj1;
                                  obj["increment"] = j;


                                  if (indexRangeInflowOptimized.find((y: any) => y.id === "Tax" + x.cflowId) != null) {
                                      indexRangeInflowOptimized[indexRangeInflowOptimized.findIndex((c: any) => c.id === "Tax" + x.cflowId)] = obj;
                                      this.IncomeOptimized[this.IncomeOptimized.findIndex((c: any) => c.id === "Tax" + x.cflowId)] = obj;
                                  }
                                  else {
                                      indexRangeInflowOptimized.push(obj);
                                      this.IncomeOptimized.push(obj);
                                  }
                              }

                          })
                          this.inflowOptimized = indexRangeInflowOptimized;

                          //Calculate Outflow Values
                          this.cfeClient.forEach((x: any) => { // client

                              var obj = indexRangeOutflowOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;

                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                            

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;


                              if (indexRangeOutflowOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  indexRangeOutflowOptimized[indexRangeOutflowOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  indexRangeOutflowOptimized.push(obj);
                              }

                          })
                          this.cfePartner.forEach((x: any) => { // partner
                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = indexRangeOutflowOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;


                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;


                              if (indexRangeOutflowOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  indexRangeOutflowOptimized[indexRangeOutflowOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  indexRangeOutflowOptimized.push(obj);
                              }


                          })
                          this.cfeJoint.forEach((x: any) => { // joint
                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }
                              var obj = indexRangeOutflowOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;


                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;

                              if (indexRangeOutflowOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  indexRangeOutflowOptimized[indexRangeOutflowOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  indexRangeOutflowOptimized.push(obj);
                              }

                          })
                          this.outflowOptimized = indexRangeOutflowOptimized;


                          //Calculate Client Investment
                          this.investmentClientOptimized.forEach((x: any) => {

                              var investmentStrategy = strategyOrder.filter(c => c.id === x.investmentId).filter(c => c.status === "Existing");

                              console.log(investmentStrategy);

                              this.investmentContribution = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "C");
                              this.investmentWithdrawal = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "W");


                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                            

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                             

                              var obj = this.BeginningValueOptimized.find((y: any) => y.owner === x.investmentId);
                              var begVal: any = {};
                              var growth: any = {};
                              var income: any = {};
                              var incomePaidOut: any = {};
                              var frankingCredits: any = {};
                              var earnings: any = {};
                              var purchaseOfAssets: any = {};
                              var regularContributions: any = {};
                              var contributions: any = {};
                              var saleOfAssets: any = {};
                              var regularWithdrawals: any = {};
                              var withdrawals: any = {};
                              var endingVal: any = {};
                              var endingValPV: any = {};
                              var realCG: any = {};
                              var unrealCG: any = {};
                              var cashFlow: any = {};

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  obj.values;
                                  begVal = obj.BegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  incomePaidOut = obj.incomePaidOutValues;
                                  frankingCredits = obj.frankingCreditsValues;
                                  earnings = obj.earningsValues;
                                  purchaseOfAssets = obj.purchaseOfAssetValues;
                                  regularContributions = obj.regularContributionsValues;
                                  contributions = obj.contributionsValues;
                                  saleOfAssets = obj.saleOfAssetValues;
                                  regularWithdrawals = obj.regularWithdrawalsValues;
                                  withdrawals = obj.withdrawalsValues;
                                  endingVal = obj.endingValues;
                                  endingValPV = obj.endingValuesPV;
                                  realCG = obj.realCGValues;
                                  unrealCG = obj.unrealCGValues;
                                  cashFlow = obj.cashFlowValues;
                              }



                              obj["owner"] = x.investmentId;
                              obj["type"] = "Client";
                              obj["name"] = "Opening Value";

                              //BeginningValue
                              if (n == 1) {
                                  if (x.startDateType == "Existing") {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {


                                  if ((this.clientDetails.startDate + i) == x.startDate) {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.startDate) {

                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                                  }

                              }



                              cashFlow[(this.clientDetails.startDate + i)] = 0;


                              //growth & income
                              var growthUnAdj = (x.growth / 100) * (Number(begVal[this.clientDetails.startDate + i]));
                              var incomeUnAdj = (x.income / 100) * (Number(begVal[this.clientDetails.startDate + i]));

                              var ICR = (x.productFees / 100) * (Number(begVal[this.clientDetails.startDate + i]));


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }


                              //incomePaidOut

                              if (x.reinvest == "N") {
                                  incomePaidOut[this.clientDetails.startDate + i] = income[this.clientDetails.startDate + i];

                              }
                              else {
                                  incomePaidOut[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //Earnings
                              earnings[this.clientDetails.startDate + i] = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])).toFixed();

                              if ((investmentStrategy.length > 0) && (investmentStrategy[0].AllocatedValue > (Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])))) {
                                  regularContributions[this.clientDetails.startDate + i] = Number(investmentStrategy[0].AllocatedValue) - (Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i]));
                              }
                              else {
                                  //List of Contributions
                                  let ContributionSum: number = 0;
                                  this.investmentContribution.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          var t = parseInt(y.value);
                                          ContributionSum = ContributionSum + t;
                                      }

                                  });

                                  regularContributions[this.clientDetails.startDate + i] = ContributionSum;
                              }


                              //Purchase of assets
                              if (x.startDateType != "Existing") {

                                  if (x.startDate == this.clientDetails.startDate + i) {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Contributions
                              contributions[this.clientDetails.startDate + i] = regularContributions[this.clientDetails.startDate + i] + Number(purchaseOfAssets[this.clientDetails.startDate + i]);



                              if ((investmentStrategy.length > 0) && (investmentStrategy[0].AllocatedValue < (Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])))) {
                                  regularWithdrawals[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])) - Number(investmentStrategy[0].AllocatedValue);
                                  console.log(regularWithdrawals[this.clientDetails.startDate + i]);
                              }
                              else {
                                  //List of Withdrawals
                                  //TODO: only if main date started
                                  let WithdrawalSum: number = 0;
                                  this.investmentWithdrawal.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          var t = parseInt(y.value);
                                          WithdrawalSum = WithdrawalSum + t;
                                      }

                                  });

                                  regularWithdrawals[this.clientDetails.startDate + i] = WithdrawalSum;
                              }

                              //Sale of assets
                              if (x.endDateType != "Retain") {

                                  if (x.endDate == this.clientDetails.startDate + i) {
                                      saleOfAssets[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(regularWithdrawals[this.clientDetails.startDate + i]);
                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Withdrawals
                              withdrawals[this.clientDetails.startDate + i] = Number(regularWithdrawals[this.clientDetails.startDate + i]) + Number(saleOfAssets[this.clientDetails.startDate + i]);


                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(cashFlow[(this.clientDetails.startDate + i)]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(withdrawals[this.clientDetails.startDate + i])).toFixed();

                              //Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();


                              if (x.type == "Domestic Cash" || x.type == "Domestic Fixed Interest") {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  if ((begVal[this.clientDetails.startDate + i]) != 0) {
                                      //Real and Unreal CG
                                      var TotalCG = 0;
                                      var RateCG = 0


                                      if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                          TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(growth[this.clientDetails.startDate + i])));
                                      }
                                      else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                          TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(growth[this.clientDetails.startDate + i]);
                                      }

                                      if (endingVal[this.clientDetails.startDate + i] == 0) {
                                          realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                      }
                                      else {
                                          if (Number(withdrawals[this.clientDetails.startDate + i]) != 0) {
                                              realCG[this.clientDetails.startDate + i] = ((Number(withdrawals[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                          }
                                          else {
                                              realCG[this.clientDetails.startDate + i] = 0;
                                          }
                                      }

                                      unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                                  }
                                  else {
                                      realCG[this.clientDetails.startDate + i] = 0;
                                      unrealCG[this.clientDetails.startDate + i] = 0;
                                  }
                              }


                              obj["BegValues"] = begVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["incomePaidOutValues"] = incomePaidOut;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["earningsValues"] = earnings;
                              obj["purchaseOfAssetValues"] = purchaseOfAssets;
                              obj["regularContributionsValues"] = regularContributions;
                              obj["contributionsValues"] = contributions;
                              obj["saleOfAssetValues"] = saleOfAssets;
                              obj["regularWithdrawalsValues"] = regularWithdrawals;
                              obj["withdrawalsValues"] = withdrawals;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["realCGValues"] = realCG;
                              obj["unrealCGValues"] = unrealCG;
                              obj["cashFlowValues"] = cashFlow;


                              if (this.BeginningValueOptimized.find((y: any) => y.owner === x.investmentId) != null) {
                                  this.BeginningValueOptimized[this.BeginningValueOptimized.findIndex((c: any) => c.owner === x.investmentId)] = obj;
                              }
                              else {
                                  this.BeginningValueOptimized.push(obj);
                              }
                          })
;
                          //Calculate Partner Investment
                          this.investmentPartner.forEach((x: any) => { // client

                              this.investmentContribution = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "C");
                              this.investmentWithdrawal = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "W");


                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }


                              var obj = this.BeginningValueOptimized.find((y: any) => y.owner === x.investmentId);
                              var begVal: any = {};
                              var growth: any = {};
                              var income: any = {};
                              var incomePaidOut: any = {};
                              var frankingCredits: any = {};
                              var earnings: any = {};
                              var purchaseOfAssets: any = {};
                              var regularContributions: any = {};
                              var contributions: any = {};
                              var saleOfAssets: any = {};
                              var regularWithdrawals: any = {};
                              var withdrawals: any = {};
                              var endingVal: any = {};
                              var endingValPV: any = {};
                              var realCG: any = {};
                              var unrealCG: any = {};
                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  obj.values;
                                  begVal = obj.BegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  incomePaidOut = obj.incomePaidOutValues;
                                  frankingCredits = obj.frankingCreditsValues;
                                  earnings = obj.earningsValues;
                                  purchaseOfAssets = obj.purchaseOfAssetValues;
                                  regularContributions = obj.regularContributionsValues;
                                  contributions = obj.contributionsValues;
                                  saleOfAssets = obj.saleOfAssetValues;
                                  regularWithdrawals = obj.regularWithdrawalsValues;
                                  withdrawals = obj.withdrawalsValues;
                                  endingVal = obj.endingValues;
                                  endingValPV = obj.endingValuesPV;
                                  realCG = obj.realCGValues;
                                  unrealCG = obj.unrealCGValues;
                              }

                              obj["owner"] = x.investmentId;
                              obj["type"] = "Partner";
                              obj["name"] = "Opening Value";

                              //BeginningValue
                              if (n == 1) {
                                  if (x.startDateType == "Existing") {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  if ((this.clientDetails.startDate + i) == x.startDate) {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.startDate) {

                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                                  }
                              }

                              //growth & income
                              var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                              var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                              var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }


                              //incomePaidOut

                              if (x.reinvest == "N") {
                                  incomePaidOut[this.clientDetails.startDate + i] = income[this.clientDetails.startDate + i];

                              }
                              else {
                                  incomePaidOut[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //Earnings
                              earnings[this.clientDetails.startDate + i] = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])).toFixed();

                              //List of Contributions
                              let ContributionSum: number = 0;
                              this.investmentContribution.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      var t = parseInt(y.value);
                                      ContributionSum = ContributionSum + t;
                                  }

                              });

                              regularContributions[this.clientDetails.startDate + i] = ContributionSum;



                              //Purchase of assets
                              if (x.startDateType != "Existing") {

                                  if (x.startDate == this.clientDetails.startDate + i) {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Contributions
                              contributions[this.clientDetails.startDate + i] = regularContributions[this.clientDetails.startDate + i] + Number(purchaseOfAssets[this.clientDetails.startDate + i]);

                              //List of Withdrawals
                              let WithdrawalSum: number = 0;
                              this.investmentWithdrawal.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      var t = parseInt(y.value);
                                      WithdrawalSum = WithdrawalSum + t;
                                  }

                              });

                              regularWithdrawals[this.clientDetails.startDate + i] = WithdrawalSum;

                              //Sale of assets
                              if (x.endDateType != "Retain") {

                                  if (x.endDate == this.clientDetails.startDate + i) {
                                      saleOfAssets[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(regularWithdrawals[this.clientDetails.startDate + i]);
                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Withdrawals
                              withdrawals[this.clientDetails.startDate + i] = Number(regularWithdrawals[this.clientDetails.startDate + i]) + Number(saleOfAssets[this.clientDetails.startDate + i]);

                              //Ending Value
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(withdrawals[this.clientDetails.startDate + i])).toFixed();

                              //Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              if (x.type == "Domestic Cash" || x.type == "Domestic Fixed Interest") {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  if (begVal[this.clientDetails.startDate + i] != 0) {
                                      //Real and Unreal CG
                                      var TotalCG = 0;
                                      var RateCG = 0


                                      if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                          TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(growth[this.clientDetails.startDate + i])));
                                      }
                                      else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                          TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(growth[this.clientDetails.startDate + i]);
                                      }

                                      if (endingVal[this.clientDetails.startDate + i] == 0) {
                                          realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                      }
                                      else {
                                          if (Number(withdrawals[this.clientDetails.startDate + i]) != 0) {
                                              realCG[this.clientDetails.startDate + i] = ((Number(withdrawals[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                          }
                                          else {
                                              realCG[this.clientDetails.startDate + i] = 0;
                                          }
                                      }

                                      unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                                  }
                                  else {
                                      realCG[this.clientDetails.startDate + i] = 0;
                                      unrealCG[this.clientDetails.startDate + i] = 0;
                                  }
                              }


                              obj["BegValues"] = begVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["incomePaidOutValues"] = incomePaidOut;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["earningsValues"] = earnings;
                              obj["purchaseOfAssetValues"] = purchaseOfAssets;
                              obj["regularContributionsValues"] = regularContributions;
                              obj["contributionsValues"] = contributions;
                              obj["saleOfAssetValues"] = saleOfAssets;
                              obj["regularWithdrawalsValues"] = regularWithdrawals;
                              obj["withdrawalsValues"] = withdrawals;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["realCGValues"] = realCG;
                              obj["unrealCGValues"] = unrealCG;


                              if (this.BeginningValueOptimized.find((y: any) => y.owner === x.investmentId) != null) {
                                  this.BeginningValueOptimized[this.BeginningValueOptimized.findIndex((c: any) => c.owner === x.investmentId)] = obj;
                              }
                              else {
                                  this.BeginningValueOptimized.push(obj);
                              }

                          })

                          //Calculate Joint Investment
                          this.investmentJoint.forEach((x: any) => { // client

                              this.investmentContribution = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "C");
                              this.investmentWithdrawal = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "W");


                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.BeginningValueOptimized.find((y: any) => y.owner === x.investmentId);
                              var begVal: any = {};
                              var growth: any = {};
                              var income: any = {};
                              var incomePaidOut: any = {};
                              var frankingCredits: any = {};
                              var earnings: any = {};
                              var purchaseOfAssets: any = {};
                              var regularContributions: any = {};
                              var contributions: any = {};
                              var saleOfAssets: any = {};
                              var regularWithdrawals: any = {};
                              var withdrawals: any = {};
                              var endingVal: any = {};
                              var endingValPV: any = {};
                              var realCG: any = {};
                              var unrealCG: any = {};
                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  obj.values;
                                  begVal = obj.BegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  incomePaidOut = obj.incomePaidOutValues;
                                  frankingCredits = obj.frankingCreditsValues;
                                  earnings = obj.earningsValues;
                                  purchaseOfAssets = obj.purchaseOfAssetValues;
                                  regularContributions = obj.regularContributionsValues;
                                  contributions = obj.contributionsValues;
                                  saleOfAssets = obj.saleOfAssetValues;
                                  regularWithdrawals = obj.regularWithdrawalsValues;
                                  withdrawals = obj.withdrawalsValues;
                                  endingVal = obj.endingValues;
                                  endingValPV = obj.endingValuesPV;
                                  realCG = obj.realCGValues;
                                  unrealCG = obj.unrealCGValues;
                              }

                              obj["owner"] = x.investmentId;
                              obj["type"] = "Joint";
                              obj["name"] = "Opening Value";

                              //BeginningValue
                              if (n == 1) {
                                  if (x.startDateType == "Existing") {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  if ((this.clientDetails.startDate + i) == x.startDate) {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.startDate) {

                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                                  }
                              }

                              //growth & income
                              var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                              var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                              var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }


                              //incomePaidOut

                              if (x.reinvest == "N") {
                                  incomePaidOut[this.clientDetails.startDate + i] = income[this.clientDetails.startDate + i];

                              }
                              else {
                                  incomePaidOut[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //Earnings
                              earnings[this.clientDetails.startDate + i] = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])).toFixed();

                              //List of Contributions
                              let ContributionSum: number = 0;
                              this.investmentContribution.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      var t = parseInt(y.value);
                                      ContributionSum = ContributionSum + t;
                                  }

                              });

                              regularContributions[this.clientDetails.startDate + i] = ContributionSum;



                              //Purchase of assets
                              if (x.startDateType != "Existing") {

                                  if (x.startDate == this.clientDetails.startDate + i) {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Contributions
                              contributions[this.clientDetails.startDate + i] = regularContributions[this.clientDetails.startDate + i] + Number(purchaseOfAssets[this.clientDetails.startDate + i]);

                              //List of Withdrawals
                              let WithdrawalSum: number = 0;
                              this.investmentWithdrawal.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      var t = parseInt(y.value);
                                      WithdrawalSum = WithdrawalSum + t;
                                  }

                              });

                              regularWithdrawals[this.clientDetails.startDate + i] = WithdrawalSum;

                              //Sale of assets
                              if (x.endDateType != "Retain") {

                                  if (x.endDate == this.clientDetails.startDate + i) {
                                      saleOfAssets[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(regularWithdrawals[this.clientDetails.startDate + i]);
                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Withdrawals
                              withdrawals[this.clientDetails.startDate + i] = Number(regularWithdrawals[this.clientDetails.startDate + i]) + Number(saleOfAssets[this.clientDetails.startDate + i]);

                              //Ending Value
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(withdrawals[this.clientDetails.startDate + i])).toFixed();

                              //Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = inflation[0].percentage;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              if (x.type == "Domestic Cash" || x.type == "Domestic Fixed Interest") {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  if (begVal[this.clientDetails.startDate + i] != 0) {
                                      //Real and Unreal CG
                                      var TotalCG = 0;
                                      var RateCG = 0


                                      if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                          TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(growth[this.clientDetails.startDate + i])));
                                      }
                                      else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                          TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(growth[this.clientDetails.startDate + i]);
                                      }

                                      if (endingVal[this.clientDetails.startDate + i] == 0) {
                                          realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                      }
                                      else {
                                          if (Number(withdrawals[this.clientDetails.startDate + i]) != 0) {
                                              realCG[this.clientDetails.startDate + i] = ((Number(withdrawals[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                          }
                                          else {
                                              realCG[this.clientDetails.startDate + i] = 0;
                                          }
                                      }

                                      unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                                  }
                                  else {
                                      realCG[this.clientDetails.startDate + i] = 0;
                                      unrealCG[this.clientDetails.startDate + i] = 0;
                                  }
                              }

                              obj["BegValues"] = begVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["incomePaidOutValues"] = incomePaidOut;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["earningsValues"] = earnings;
                              obj["purchaseOfAssetValues"] = purchaseOfAssets;
                              obj["regularContributionsValues"] = regularContributions;
                              obj["contributionsValues"] = contributions;
                              obj["saleOfAssetValues"] = saleOfAssets;
                              obj["regularWithdrawalsValues"] = regularWithdrawals;
                              obj["withdrawalsValues"] = withdrawals;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["realCGValues"] = realCG;
                              obj["unrealCGValues"] = unrealCG;

                              if (this.BeginningValueOptimized.find((y: any) => y.owner === x.investmentId) != null) {
                                  this.BeginningValueOptimized[this.BeginningValueOptimized.findIndex((c: any) => c.owner === x.investmentId)] = obj;
                              }
                              else {
                                  this.BeginningValueOptimized.push(obj);
                              }

                          })

                          //Calculate Financial Assets Totals
                          this.calculateTotalInvestmentPaidOutOptimized("TotalIPO", i);
                          this.calculateTotalInvestmentWithdrawalsOptimized("TotalIW", i);
                          this.calculateTotalInvestmentContributionsOptimized("TotalIC", i);
                          this.calculateTotalInvestmentEarningsOptimized("TotalTaxIE-client", "Client", i);
                          this.calculateTotalInvestmentEarningsOptimized("TotalTaxIE-partner", "Partner", i);
                          this.calculateRealizedCGFAOptimized("RCGFA-client", "Client", i);
                          this.calculateRealizedCGFAOptimized("RCGFA-partner", "Partner", i);
                          this.calculateFrankingCreditsOptimized("FrankingCredits-client", "Client", i);
                          this.calculateFrankingCreditsOptimized("FrankingCredits-partner", "Partner", i);


                          //Calculate Client Properties
                          this.propertiesClient.forEach((x: any) => { // client

                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate;
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                            


                              var obj = this.PropertiesValueOptimized.find((y: any) => y.owner === x.propertyId);
                              var begVal: any = {};
                              var propertyPurchase: any = {};
                              var propertySale: any = {};
                              var capitalGrowth: any = {};
                              var endingVal: any = {};
                              var endingValPV: any = {};
                              var rent: any = {};
                              var expenses: any = {};
                              var realCG: any = {};
                              var unrealCG: any = {};
                              var propPurchase: number = 0;
                              var propSale: number = 0;

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  begVal = obj.BegValues;
                                  propertyPurchase = obj.PropertyPurchaseValues;
                                  propertySale = obj.PropertySaleValues;
                                  capitalGrowth = obj.capitalGrowthValues;
                                  endingVal = obj.endingValues;
                                  endingValPV = obj.endingValuesPV;
                                  rent = obj.rentValues;
                                  expenses = obj.expensesValues;
                                  realCG = obj.realCGValues;
                                  unrealCG = obj.unrealCGValues;
                              }


                              obj["owner"] = x.propertyId;
                              obj["type"] = "Client";
                              obj["name"] = x.name;
                              obj["startDateType"] = x.startDateType;

                              //BeginningValue
                              if (n == 1 && x.startDateType == "Existing") {
                                  begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else if ((this.clientDetails.startDate + i) <= x.startDate) {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                              }

                              //capital growth
                              capitalGrowth[this.clientDetails.startDate + i] = ((x.growth / 100) * Number(begVal[this.clientDetails.startDate + i])).toFixed();

                              ////Ending Value


                              if ((this.clientDetails.startDate + i) == x.startDate) {
                                  endingVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  propertyPurchase[this.clientDetails.startDate + i] = x.value.toFixed();
                                  propPurchase = this.clientDetails.startDate + i;
                                  propertySale[this.clientDetails.startDate + i] = 0;

                              }
                              else if ((this.clientDetails.startDate + i) < x.startDate) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                                  propertyPurchase[this.clientDetails.startDate + i] = 0;


                              }


                              if ((this.clientDetails.startDate + i) == x.endDate) {
                                  propertySale[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();
                                  endingVal[this.clientDetails.startDate + i] = 0;
                              }
                              else if ((this.clientDetails.startDate + i) > x.startDate && (this.clientDetails.startDate + i) < x.endDate) {
                                  propSale = this.clientDetails.startDate + i;
                                  propertySale[this.clientDetails.startDate + i] = 0;
                                  endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();

                              }
                              else if ((this.clientDetails.startDate + i) > x.endDate) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                                  propertyPurchase[this.clientDetails.startDate + i] = 0;
                                  propertySale[this.clientDetails.startDate + i] = 0;
                              }




                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              //rent
                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  rent[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  let rentVal: number = 0;

                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      rentVal = parseInt(x.rent);
                                  }

                                  rent[this.clientDetails.startDate + i] = rentVal;
                              }


                              //expenses
                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  expenses[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  let expensesVal: number = 0;
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      expensesVal = parseInt(x.expenses);
                                  }
                                  expenses[this.clientDetails.startDate + i] = expensesVal;
                              }

                              if (begVal[this.clientDetails.startDate + i] != 0) {
                                  //Real and Unreal CG
                                  var TotalCG = 0;
                                  var RateCG = 0


                                  if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                      TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(capitalGrowth[this.clientDetails.startDate + i])));
                                  }
                                  else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                      TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(capitalGrowth[this.clientDetails.startDate + i]);
                                  }

                                  if (endingVal[this.clientDetails.startDate + i] == 0) {
                                      realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                  }
                                  else {
                                      if (Number(propertySale[this.clientDetails.startDate + i]) != 0) {
                                          realCG[this.clientDetails.startDate + i] = ((Number(propertySale[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                      }
                                      else {
                                          realCG[this.clientDetails.startDate + i] = 0;
                                      }
                                  }

                                  unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                              }
                              else {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }


                              obj["BegValues"] = begVal;
                              obj["PropertyPurchaseValues"] = propertyPurchase;
                              obj["PropertySaleValues"] = propertySale;
                              obj["capitalGrowthValues"] = capitalGrowth;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["rentValues"] = rent;
                              obj["expensesValues"] = expenses;
                              obj["realCGValues"] = realCG;
                              obj["unrealCGValues"] = unrealCG;
                              obj["propPurchase"] = propPurchase;

                              if (this.PropertiesValueOptimized.find((y: any) => y.owner === x.propertyId) != null) {
                                  this.PropertiesValueOptimized[this.PropertiesValueOptimized.findIndex((c: any) => c.owner === x.propertyId)] = obj;
                              }
                              else {
                                  this.PropertiesValueOptimized.push(obj);
                              }

                          })

                          //Calculate Partner Properties
                          this.propertiesPartner.forEach((x: any) => { // client

                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }
                              //TODO : Confirm retain end date value
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.PropertiesValueOptimized.find((y: any) => y.owner === x.propertyId);
                              var begVal: any = {};
                              var propertyPurchase: any = {};
                              var propertySale: any = {};
                              var capitalGrowth: any = {};
                              var endingVal: any = {};
                              var endingValPV: any = {};
                              var rent: any = {};
                              var expenses: any = {};
                              var realCG: any = {};
                              var unrealCG: any = {};
                              var propPurchase: number = 0;
                              var propSale: number = 0;

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  begVal = obj.BegValues;
                                  propertyPurchase = obj.PropertyPurchaseValues;
                                  propertySale = obj.PropertySaleValues;
                                  capitalGrowth = obj.capitalGrowthValues;
                                  endingVal = obj.endingValues;
                                  endingValPV = obj.endingValuesPV;
                                  rent = obj.rentValues;
                                  expenses = obj.expensesValues;
                                  realCG = obj.realCGValues;
                                  unrealCG = obj.unrealCGValues;
                              }

                              obj["owner"] = x.propertyId;
                              obj["type"] = "Partner";
                              obj["name"] = x.name;
                              obj["startDateType"] = x.startDateType;

                              //BeginningValue
                              if (n == 1 && x.startDateType == "Existing") {
                                  begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else if ((this.clientDetails.startDate + i) <= x.startDate) {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                              }

                              //capital growth
                              capitalGrowth[this.clientDetails.startDate + i] = ((x.growth / 100) * Number(begVal[this.clientDetails.startDate + i])).toFixed();

                              ////Ending Value


                              if ((this.clientDetails.startDate + i) == x.startDate) {
                                  endingVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  propertyPurchase[this.clientDetails.startDate + i] = x.value.toFixed();
                                  propPurchase = this.clientDetails.startDate + i;
                                  propertySale[this.clientDetails.startDate + i] = 0;

                              }
                              else if ((this.clientDetails.startDate + i) < x.startDate) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                                  propertyPurchase[this.clientDetails.startDate + i] = 0;


                              }


                              if ((this.clientDetails.startDate + i) == x.endDate) {
                                  propertySale[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();
                                  endingVal[this.clientDetails.startDate + i] = 0;
                              }
                              else if ((this.clientDetails.startDate + i) > x.startDate && (this.clientDetails.startDate + i) < x.endDate) {
                                  propSale = this.clientDetails.startDate + i;
                                  propertySale[this.clientDetails.startDate + i] = 0;
                                  endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();

                              }
                              else if ((this.clientDetails.startDate + i) > x.endDate) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                                  propertyPurchase[this.clientDetails.startDate + i] = 0;
                                  propertySale[this.clientDetails.startDate + i] = 0;
                              }




                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              //rent
                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  rent[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  let rentVal: number = 0;

                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      rentVal = parseInt(x.rent);
                                  }

                                  rent[this.clientDetails.startDate + i] = rentVal;
                              }


                              //expenses
                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  expenses[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  let expensesVal: number = 0;
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      expensesVal = parseInt(x.expenses);
                                  }
                                  expenses[this.clientDetails.startDate + i] = expensesVal;
                              }

                              if (begVal[this.clientDetails.startDate + i] != 0) {
                                  //Real and Unreal CG
                                  var TotalCG = 0;
                                  var RateCG = 0


                                  if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                      TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(capitalGrowth[this.clientDetails.startDate + i])));
                                  }
                                  else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                      TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(capitalGrowth[this.clientDetails.startDate + i]);
                                  }

                                  if (endingVal[this.clientDetails.startDate + i] == 0) {
                                      realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                  }
                                  else {
                                      if (Number(propertySale[this.clientDetails.startDate + i]) != 0) {
                                          realCG[this.clientDetails.startDate + i] = ((Number(propertySale[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                      }
                                      else {
                                          realCG[this.clientDetails.startDate + i] = 0;
                                      }
                                  }

                                  unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                              }
                              else {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }


                              obj["BegValues"] = begVal;
                              obj["PropertyPurchaseValues"] = propertyPurchase;
                              obj["PropertySaleValues"] = propertySale;
                              obj["capitalGrowthValues"] = capitalGrowth;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["rentValues"] = rent;
                              obj["expensesValues"] = expenses;
                              obj["realCGValues"] = realCG;
                              obj["unrealCGValues"] = unrealCG;
                              obj["propPurchase"] = propPurchase;

                              if (this.PropertiesValueOptimized.find((y: any) => y.owner === x.propertyId) != null) {
                                  this.PropertiesValueOptimized[this.PropertiesValueOptimized.findIndex((c: any) => c.owner === x.propertyId)] = obj;
                              }
                              else {
                                  this.PropertiesValueOptimized.push(obj);
                              }
                          })
                          //Calculate Joint Properties
                          this.propertiesJoint.forEach((x: any) => { // client

                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate;
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              //TODO : Confirm retain end date value
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.PropertiesValueOptimized.find((y: any) => y.owner === x.propertyId);
                              var begVal: any = {};
                              var propertyPurchase: any = {};
                              var propertySale: any = {};
                              var capitalGrowth: any = {};
                              var endingVal: any = {};
                              var endingValPV: any = {};
                              var rent: any = {};
                              var expenses: any = {};
                              var realCG: any = {};
                              var unrealCG: any = {};
                              var propPurchase: number = 0;
                              var propSale: number = 0;

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  begVal = obj.BegValues;
                                  propertyPurchase = obj.PropertyPurchaseValues;
                                  propertySale = obj.PropertySaleValues;
                                  capitalGrowth = obj.capitalGrowthValues;
                                  endingVal = obj.endingValues;
                                  endingValPV = obj.endingValuesPV;
                                  rent = obj.rentValues;
                                  expenses = obj.expensesValues;
                                  realCG = obj.realCGValues;
                                  unrealCG = obj.unrealCGValues;
                              }

                              obj["owner"] = x.propertyId;
                              obj["type"] = "Joint";
                              obj["name"] = x.name;
                              obj["startDateType"] = x.startDateType;

                              //BeginningValue
                              if (n == 1 && x.startDateType == "Existing") {
                                  begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else if ((this.clientDetails.startDate + i) <= x.startDate) {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                              }

                              //capital growth
                              capitalGrowth[this.clientDetails.startDate + i] = ((x.growth / 100) * Number(begVal[this.clientDetails.startDate + i])).toFixed();

                              ////Ending Value


                              if ((this.clientDetails.startDate + i) == x.startDate) {
                                  endingVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  propertyPurchase[this.clientDetails.startDate + i] = x.value.toFixed();
                                  propPurchase = this.clientDetails.startDate + i;
                                  propertySale[this.clientDetails.startDate + i] = 0;

                              }
                              else if ((this.clientDetails.startDate + i) < x.startDate) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                                  propertyPurchase[this.clientDetails.startDate + i] = 0;


                              }


                              if ((this.clientDetails.startDate + i) == x.endDate) {
                                  propertySale[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();
                                  endingVal[this.clientDetails.startDate + i] = 0;
                              }
                              else if ((this.clientDetails.startDate + i) > x.startDate && (this.clientDetails.startDate + i) < x.endDate) {
                                  propSale = this.clientDetails.startDate + i;
                                  propertySale[this.clientDetails.startDate + i] = 0;
                                  endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();

                              }
                              else if ((this.clientDetails.startDate + i) > x.endDate) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                                  propertyPurchase[this.clientDetails.startDate + i] = 0;
                                  propertySale[this.clientDetails.startDate + i] = 0;
                              }




                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              //rent
                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  rent[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  let rentVal: number = 0;

                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      rentVal = parseInt(x.rent);
                                  }

                                  rent[this.clientDetails.startDate + i] = rentVal;
                              }


                              //expenses
                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  expenses[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  let expensesVal: number = 0;
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      expensesVal = parseInt(x.expenses);
                                  }
                                  expenses[this.clientDetails.startDate + i] = expensesVal;
                              }

                              if (begVal[this.clientDetails.startDate + i] != 0) {
                                  //Real and Unreal CG
                                  var TotalCG = 0;
                                  var RateCG = 0


                                  if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                      TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(capitalGrowth[this.clientDetails.startDate + i])));
                                  }
                                  else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                      TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(capitalGrowth[this.clientDetails.startDate + i]);
                                  }

                                  if (endingVal[this.clientDetails.startDate + i] == 0) {
                                      realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                  }
                                  else {
                                      if (Number(propertySale[this.clientDetails.startDate + i]) != 0) {
                                          realCG[this.clientDetails.startDate + i] = ((Number(propertySale[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                      }
                                      else {
                                          realCG[this.clientDetails.startDate + i] = 0;
                                      }
                                  }

                                  unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                              }
                              else {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }


                              obj["BegValues"] = begVal;
                              obj["PropertyPurchaseValues"] = propertyPurchase;
                              obj["PropertySaleValues"] = propertySale;
                              obj["capitalGrowthValues"] = capitalGrowth;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["rentValues"] = rent;
                              obj["expensesValues"] = expenses;
                              obj["realCGValues"] = realCG;
                              obj["unrealCGValues"] = unrealCG;
                              obj["propPurchase"] = propPurchase;

                              if (this.PropertiesValueOptimized.find((y: any) => y.owner === x.propertyId) != null) {
                                  this.PropertiesValueOptimized[this.PropertiesValueOptimized.findIndex((c: any) => c.owner === x.propertyId)] = obj;
                              }
                              else {
                                  this.PropertiesValueOptimized.push(obj);
                              }

                          })


                          //Calculate PropertyTotal
                          this.calculateTotalRentOptimized("TotalRent", i);
                          this.calculateTotalSaleProceedsOptimized("TotalSaleProceeds", i);
                          this.calculateTotalPropertyExpensesOptimized("TotalPropertyExpenses", i);
                          this.calculateInvestmentPropertyExpensesOptimized("InvestmentPropertyExpenses-client", "Client", i);
                          this.calculateInvestmentPropertyExpensesOptimized("InvestmentPropertyExpenses-partner", "Partner", i);
                          this.calculateRealizedCGPOptimized("RCGP-client", "Client", i);
                          this.calculateRealizedCGPOptimized("RCGP-partner", "Partner", i);

                          ////Calculate Client Liability
                          this.liabilityClient.forEach((x: any) => { // client
                              var debtStrategy = strategyOrder.filter(c => c.id === x.liabilityId).filter(c => c.type === "Debt");


                              this.liabilityDrawDown = this.liabilityDD.filter((c: any) => c.liabilityId === x.liabilityId);


                              if (x.commenceOnDateType == "Start" || x.commenceOnDateType == "Existing") {
                                  x.commenceOnDate = this.clientDetails.startDate;
                              }
                              if (x.repaymentDateType == "End") {
                                  x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.repaymentDateType == "Retain") {
                                  x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }


                              var obj = this.LBValueOptimized.find((y: any) => y.owner === x.liabilityId);
                              var begVal: any = {};
                              var accruedInterest: any = {};
                              var repmt: any = {};
                              var endingVal: any = {};

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  begVal = obj.BegValues;
                                  accruedInterest = obj.accruedInterestValues;
                                  repmt = obj.repmtValues;
                                  endingVal = obj.endingValues;
                              }

                              obj["owner"] = x.liabilityId;
                              obj["type"] = "Client";
                              obj["name"] = "Opening Value";
                              obj["deductibility"] = x.deductibility;

                              if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.commenceOnDateType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.commenceOnDate) {
                                          begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.commenceOnDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = Number(endingVal[Number(this.clientDetails.startDate + i) - 1]);
                                      }
                                  }
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }

                              //accrued Interest
                              accruedInterest[this.clientDetails.startDate + i] = (begVal[this.clientDetails.startDate + i] * (x.interestRate / 100)).toFixed();

                              //Optimize Debt
                              if (debtStrategy.length > 0 && debtStrategy[0].AllocatedValue > 0) {
                                  repmt[this.clientDetails.startDate + i] = Number(debtStrategy[0].AllocatedValue);
                              }
                              else {
                                  var PMT: number = 0;
                                  if (x.repaymentType == "IO") {
                                      PMT = Number(accruedInterest[this.clientDetails.startDate + i]);
                                  }
                                  else {
                                      PMT = Number(x.principal) * (x.interestRate / 100) * (Math.pow((1 + (x.interestRate / 100)), x.term) / (Math.pow((1 + (x.interestRate / 100)), x.term) - 1));
                                  }
                                  if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {

                                      //Repayment Value
                                      var Repmt: number = 0;
                                      if (x.repaymentDateType == "Retain") {
                                          Repmt = Math.max(x.repayment, PMT);
                                      }
                                      else if ((this.clientDetails.startDate + i) == x.repaymentDate) {
                                          Repmt = Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]);
                                      }
                                      else {
                                          Repmt = Math.max(x.repayment, PMT);
                                      }
                                      var repayment = Math.min((begVal[this.clientDetails.startDate + i] + accruedInterest[this.clientDetails.startDate + i]), Repmt);
                                      repmt[this.clientDetails.startDate + i] = repayment.toFixed();
                                  }
                                  else {
                                      repmt[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              ////Ending Value

                              if (Number(repmt[this.clientDetails.startDate + i]) > (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]))) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]) - Number(repmt[this.clientDetails.startDate + i])).toFixed();
                              }
                             
                              obj["BegValues"] = begVal;
                              obj["accruedInterestValues"] = accruedInterest;
                              obj["repmtValues"] = repmt;
                              obj["endingValues"] = endingVal;


                              if (this.LBValueOptimized.find((y: any) => y.owner === x.liabilityId) != null) {
                                  this.LBValueOptimized[this.LBValueOptimized.findIndex((c: any) => c.owner === x.liabilityId)] = obj;
                              }
                              else {
                                  this.LBValueOptimized.push(obj);
                              }
                          })

                          //Calculate Partner Liability
                          this.liabilityPartner.forEach((x: any) => { // client

                              this.liabilityDrawDown = this.liabilityDD.filter((c: any) => c.liabilityId === x.liabilityId);


                              if (x.commenceOnDateType == "Start" || x.commenceOnDateType == "Existing") {
                                  x.commenceOnDate = this.clientDetails.startDate;
                              }
                              if (x.repaymentDateType == "End") {
                                  x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.repaymentDateType == "Retain") {
                                  x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }


                              var obj = this.LBValueOptimized.find((y: any) => y.owner === x.liabilityId);
                              var begVal: any = {};
                              var accruedInterest: any = {};
                              var repmt: any = {};
                              var endingVal: any = {};

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  begVal = obj.BegValues;
                                  accruedInterest = obj.accruedInterestValues;
                                  repmt = obj.repmtValues;
                                  endingVal = obj.endingValues;
                              }


                              obj["owner"] = x.liabilityId;
                              obj["type"] = "Partner";
                              obj["name"] = "Opening Value";
                              obj["deductibility"] = x.deductibility;

                              if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.commenceOnDateType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.commenceOnDate) {
                                          begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.commenceOnDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = Number(endingVal[Number(this.clientDetails.startDate + i) - 1]);
                                      }
                                  }
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }

                              //accrued Interest
                              accruedInterest[this.clientDetails.startDate + i] = (begVal[this.clientDetails.startDate + i] * (x.interestRate / 100)).toFixed();

                              //Minimum repayment

                              var PMT: number = 0;
                              if (x.repaymentType == "IO") {
                                  PMT = Number(accruedInterest[this.clientDetails.startDate + i]);
                              }
                              else {
                                  PMT = Number(x.principal) * (x.interestRate / 100) * (Math.pow((1 + (x.interestRate / 100)), x.term) / (Math.pow((1 + (x.interestRate / 100)), x.term) - 1));
                              }
                              if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {

                                  //Repayment Value
                                  var Repmt: number = 0;
                                  if (x.repaymentDateType == "Retain") {
                                      Repmt = Math.max(x.repayment, PMT);
                                  }
                                  else if ((this.clientDetails.startDate + i) == x.repaymentDate) {
                                      Repmt = Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]);
                                  }
                                  else {
                                      Repmt = Math.max(x.repayment, PMT);
                                  }
                                  var repayment = Math.min((begVal[this.clientDetails.startDate + i] + accruedInterest[this.clientDetails.startDate + i]), Repmt);
                                  repmt[this.clientDetails.startDate + i] = repayment.toFixed();
                              }
                              else {
                                  repmt[this.clientDetails.startDate + i] = 0;
                              }
                              ////Ending Value
                              if (Number(repmt[this.clientDetails.startDate + i]) > (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]))) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]) - Number(repmt[this.clientDetails.startDate + i])).toFixed();
                              }

                              obj["BegValues"] = begVal;
                              obj["accruedInterestValues"] = accruedInterest;
                              obj["repmtValues"] = repmt;
                              obj["endingValues"] = endingVal;

                              if (this.LBValueOptimized.find((y: any) => y.owner === x.liabilityId) != null) {
                                  this.LBValueOptimized[this.LBValueOptimized.findIndex((c: any) => c.owner === x.liabilityId)] = obj;
                              }
                              else {
                                  this.LBValueOptimized.push(obj);
                              }

                          })
                          //Calculate Joint Liability
                          this.liabilityJoint.forEach((x: any) => { // client

                              this.liabilityDrawDown = this.liabilityDD.filter((c: any) => c.liabilityId === x.liabilityId);


                              if (x.commenceOnDateType == "Start" || x.commenceOnDateType == "Existing") {
                                  x.commenceOnDate = this.clientDetails.startDate;
                              }
                              if (x.repaymentDateType == "End") {
                                  x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.repaymentDateType == "Retain") {
                                  x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }



                              var obj = this.LBValueOptimized.find((y: any) => y.owner === x.liabilityId);
                              var begVal: any = {};
                              var accruedInterest: any = {};
                              var repmt: any = {};
                              var endingVal: any = {};

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  begVal = obj.BegValues;
                                  accruedInterest = obj.accruedInterestValues;
                                  repmt = obj.repmtValues;
                                  endingVal = obj.endingValues;
                              }


                              obj["owner"] = x.liabilityId;
                              obj["type"] = "Joint";
                              obj["name"] = "Opening Value";
                              obj["deductibility"] = x.deductibility;

                              if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.commenceOnDateType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.commenceOnDate) {
                                          begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.commenceOnDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = Number(endingVal[Number(this.clientDetails.startDate + i) - 1]);
                                      }
                                  }
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }

                              //accrued Interest
                              accruedInterest[this.clientDetails.startDate + i] = (begVal[this.clientDetails.startDate + i] * (x.interestRate / 100)).toFixed();

                              //Minimum repayment

                              var PMT: number = 0;
                              if (x.repaymentType == "IO") {
                                  PMT = Number(accruedInterest[this.clientDetails.startDate + i]);
                              }
                              else {
                                  PMT = Number(x.principal) * (x.interestRate / 100) * (Math.pow((1 + (x.interestRate / 100)), x.term) / (Math.pow((1 + (x.interestRate / 100)), x.term) - 1));
                              }
                              if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {

                                  //Repayment Value
                                  var Repmt: number = 0;
                                  if (x.repaymentDateType == "Retain") {
                                      Repmt = Math.max(x.repayment, PMT);
                                  }
                                  else if ((this.clientDetails.startDate + i) == x.repaymentDate) {
                                      Repmt = Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]);
                                  }
                                  else {
                                      Repmt = Math.max(x.repayment, PMT);
                                  }
                                  var repayment = Math.min((begVal[this.clientDetails.startDate + i] + accruedInterest[this.clientDetails.startDate + i]), Repmt);
                                  repmt[this.clientDetails.startDate + i] = repayment.toFixed();
                              }
                              else {
                                  repmt[this.clientDetails.startDate + i] = 0;
                              }
                              ////Ending Value

                              if (Number(repmt[this.clientDetails.startDate + i]) > (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]))) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]) - Number(repmt[this.clientDetails.startDate + i])).toFixed();
                              }

                              obj["BegValues"] = begVal;
                              obj["accruedInterestValues"] = accruedInterest;
                              obj["repmtValues"] = repmt;
                              obj["endingValues"] = endingVal;

                              if (this.LBValueOptimized.find((y: any) => y.owner === x.liabilityId) != null) {
                                  this.LBValueOptimized[this.LBValueOptimized.findIndex((c: any) => c.owner === x.liabilityId)] = obj;
                              }
                              else {
                                  this.LBValueOptimized.push(obj);
                              }

                          })

                          //Calculate Liability Total

                          this.calculateTotalDebtRepaymentOptimized("TotalDebtRepayment", i);
                          this.calculateAccruedLiabilitiesOptimized("Accruedliability-client", "Client", i);
                          this.calculateAccruedLiabilitiesOptimized("Accruedliability-partner", "Partner", i);


                          //Pension - Client
                          this.pensionClient.forEach((x: any) => {

                              this.pensionDrawDown = this.pensionDD.filter((c: any) => c.pensionId === x.pensionId);


                              if (x.pensionRebootFromType == "Start" || x.pensionRebootFromType == "Existing") {
                                  x.pensionRebootFromDate = this.clientDetails.startDate
                              }
                              else if (x.pensionRebootFromType == "Client Retirement") {
                                  x.pensionRebootFromDate = this.clientDetails.clientRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.PensionValueOptimized.find((y: any) => y.owner === x.pensionId);
                              var begVal: any = {};
                              var TaxableBegVal: any = {};
                              var TaxFreeBegVal: any = {};

                              var growth: any = {};
                              var income: any = {};
                              var frankingCredits: any = {};

                              var pensionIncome: any = {};
                              var pITaxAssessable: any = {};
                              var pITaxExempt: any = {};

                              var endingVal: any = {};
                              var TaxableEndingVal: any = {};
                              var TaxFreeEndingVal: any = {};
                              var endingValPV: any = {};
                              var TaxableProp: number = 0;
                              var TaxFreeProp: number = 0;

                              if (obj == null) {
                                  obj = {};
                                  TaxableProp = 0;
                                  TaxFreeProp = 0;
                              }
                              else {
                                  begVal = obj.BegValues;
                                  TaxableBegVal = obj.TaxableBegValues;
                                  TaxFreeBegVal = obj.TaxFreeBegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  frankingCredits = obj.frankingCreditsValues;
                                  pensionIncome = obj.pensionIncomeValues;
                                  pITaxAssessable = obj.pITaxAssessableValues;
                                  pITaxExempt = obj.pITaxExemptValues;
                                  endingVal = obj.endingValues;
                                  TaxableEndingVal = obj.TaxableEndingValues;
                                  TaxFreeEndingVal = obj.TaxFreeEndingValues;
                                  endingValPV = obj.endingValuesPV;
                                  TaxableProp = obj.taxableProp;
                                  TaxFreeProp = obj.taxfreeProp;

                              }

                              obj["owner"] = x.pensionId;
                              obj["type"] = "Client";
                              obj["name"] = "Opening Value";


                              if (x.pensionRebootFromDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.pensionRebootFromType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.pensionRebootFromDate) {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.pensionRebootFromDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {

                                          begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                                      }
                                  }


                                  if ((this.clientDetails.startDate + i) == x.pensionRebootFromDate || x.pensionRebootFromType == "Existing") {
                                      //TODO Confirm negative
                                      if (x.taxableComponent != 0 && x.value != 0) {
                                          TaxableProp = (Number(x.taxableComponent) / Number(x.value));
                                      }
                                      else {
                                          TaxableProp = 0;
                                      }
                                      TaxFreeProp = 1 - TaxableProp;

                                      TaxableBegVal[this.clientDetails.startDate + i] = x.taxableComponent.toFixed();
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = x.taxFreeComponent.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.pensionRebootFromDate) {

                                      TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {

                                      TaxableBegVal[this.clientDetails.startDate + i] = Number(TaxableEndingVal[Number(this.clientDetails.startDate + i) - 1]);
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = Number(TaxFreeEndingVal[Number(this.clientDetails.startDate + i) - 1]);
                                  }
                              }
                              else {
                                  TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }


                              ////growth & income
                              var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                              var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                              var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (Number(income[this.clientDetails.startDate + i]) * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //pension Income
                              var preservation = this.preservationAge.sort((a: any, b: any) => a.dob - b.dob);
                              var minPendionDD = this.minimumPensionDrawdown.sort((a: any, b: any) => a.age - b.age);
                              var currentYear = this.clientDetails.startDate + i;
                              var pAge: number = 0;
                              var minRate: number = 0;

                              for (var k = 0; k < preservation.length; k++) {


                                  if ((k == (preservation.length - 1)) && (this.clientDetails.clientDob >= preservation[k].dob)) {
                                      pAge = preservation[k].age;

                                  }
                                  else if (k == 0 && ((this.clientDetails.clientDob) <= preservation[k].dob)) {
                                      pAge = preservation[k].age;
                                      break;

                                  }
                                  else if ((this.clientDetails.clientDob) > preservation[k].dob && (this.clientDetails.clientDob) <= preservation[k + 1].dob) {
                                      pAge = preservation[k + 1].age;
                                      break;

                                  }
                              }
                              var date1 = new Date("7/01/ " + (this.clientDetails.startDate + i));
                              var date2 = new Date(this.clientDetails.clientDob);
                              var timeDiff = Math.abs(date2.getTime() - date1.getTime());
                              var diffDays = (Math.ceil(timeDiff / (1000 * 3600 * 24))) / 365;

                              var clientAge = Math.round(diffDays * 10) / 10;

                              for (var l = 0; l < minPendionDD.length; l++) {


                                  if ((l == (minPendionDD.length - 1)) && (clientAge >= minPendionDD[l].age)) {
                                      minRate = minPendionDD[l].minimumDrawdown;

                                  }
                                  else if (l == 0 && (clientAge <= minPendionDD[l].age)) {
                                      minRate = minPendionDD[l].minimumDrawdown;
                                      break;

                                  }
                                  else if (clientAge > minPendionDD[l].age && clientAge <= minPendionDD[l + 1].age) {
                                      minRate = minPendionDD[l + 1].minimumDrawdown;
                                      break;

                                  }
                              }


                              var minDrawdown: number = 0;
                              var maxDrawdown: number = 0;

                              if (clientAge < pAge) {
                                  minDrawdown = 0;
                                  maxDrawdown = 0;
                              }
                              else if (clientAge >= pAge && clientAge < 65) {
                                  if (this.clientRetirementYear != 0 && this.clientRetirementYear <= (this.clientDetails.startDate + i)) {
                                      minDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (minRate / 100);
                                      maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]);

                                  }
                                  else {
                                      minDrawdown = 0;
                                      maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (10 / 100);
                                  }

                              }
                              else if (clientAge >= 65) {
                                  minDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (minRate / 100);
                                  maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]);
                              }


                              if (x.pensionRebootFromDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {

                                  if (this.pensionDrawDown.length > 0) {
                                  let pIncomeSum: number = 0;
                                  this.pensionDrawDown.forEach((y: any) => {

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.amount == 0) {
                                              if (y.type == "Minimum") {
                                                  pensionIncome[this.clientDetails.startDate + i] = minDrawdown.toFixed();
                                              } else if (y.type == "Maximum") {
                                                  pensionIncome[this.clientDetails.startDate + i] = maxDrawdown.toFixed();
                                              }
                                          }
                                          else {
                                              pensionIncome[this.clientDetails.startDate + i] = (Math.min(maxDrawdown, Math.max(minDrawdown, y.amount))).toFixed();
                                          }
                                          //var t = parseInt(y.amount);
                                          //ContributionSum = ContributionSum + t;
                                      }

                                  });

                                  }
                                  else {
                                      pensionIncome[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  pensionIncome[this.clientDetails.startDate + i] = 0;
                              }


                              if (clientAge >= pAge && clientAge < 60) {
                                  pITaxAssessable[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) * TaxableProp).toFixed();
                                  pITaxExempt[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) - pITaxAssessable[this.clientDetails.startDate + i]).toFixed();
                              }
                              else if (clientAge >= 60) {
                                  pITaxAssessable[this.clientDetails.startDate + i] = 0;
                                  pITaxExempt[this.clientDetails.startDate + i] = Number(pensionIncome[this.clientDetails.startDate + i]).toFixed();
                              }

                              //Ending Value
                              endingVal[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(pensionIncome[this.clientDetails.startDate + i]);

                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              ////Ending Value - Taxable
                              TaxableEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) * TaxableProp).toFixed();

                              TaxFreeEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) - TaxFreeProp).toFixed();


                              obj["BegValues"] = begVal;
                              obj["TaxableBegValues"] = TaxableBegVal;
                              obj["TaxFreeBegValues"] = TaxFreeBegVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["pensionIncomeValues"] = pensionIncome;
                              obj["pITaxAssessableValues"] = pITaxAssessable;
                              obj["pITaxExemptValues"] = pITaxExempt;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["TaxableEndingValues"] = TaxableEndingVal;
                              obj["TaxFreeEndingValues"] = TaxFreeEndingVal;
                              //TODO: Verify
                              obj["taxableProp"] = TaxableProp;
                              obj["taxfreeProp"] = TaxFreeProp;


                              if (this.PensionValueOptimized.find((y: any) => y.owner === x.pensionId) != null) {
                                  this.PensionValueOptimized[this.PensionValueOptimized.findIndex((c: any) => c.owner === x.pensionId)] = obj;
                              }
                              else {
                                  this.PensionValueOptimized.push(obj);

                              }
                          });
                          //Pension - Partner
                          this.pensionPartner.forEach((x: any) => { // client

                              this.pensionDrawDown = this.pensionDD.filter((c: any) => c.pensionId === x.pensionId);


                              if (x.pensionRebootFromType == "Start" || x.pensionRebootFromType == "Existing") {
                                  x.pensionRebootFromDate = this.clientDetails.startDate
                              }
                              else if (x.pensionRebootFromType == "Partner Retirement") {
                                  x.pensionRebootFromDate = this.clientDetails.partnerRetirementYear - 1;
                              }
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.PensionValueOptimized.find((y: any) => y.owner === x.pensionId);
                              var begVal: any = {};
                              var TaxableBegVal: any = {};
                              var TaxFreeBegVal: any = {};

                              var growth: any = {};
                              var income: any = {};
                              var frankingCredits: any = {};

                              var pensionIncome: any = {};
                              var pITaxAssessable: any = {};
                              var pITaxExempt: any = {};

                              var endingVal: any = {};
                              var TaxableEndingVal: any = {};
                              var TaxFreeEndingVal: any = {};
                              var endingValPV: any = {};
                              var TaxableProp: number = 0;
                              var TaxFreeProp: number = 0;

                              if (obj == null) {
                                  obj = {};
                                  TaxableProp = 0;
                                  TaxFreeProp = 0;
                              }
                              else {
                                  begVal = obj.BegValues;
                                  TaxableBegVal = obj.TaxableBegValues;
                                  TaxFreeBegVal = obj.TaxFreeBegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  frankingCredits = obj.frankingCreditsValues;
                                  pensionIncome = obj.pensionIncomeValues;
                                  pITaxAssessable = obj.pITaxAssessableValues;
                                  pITaxExempt = obj.pITaxExemptValues;
                                  endingVal = obj.endingValues;
                                  TaxableEndingVal = obj.TaxableEndingValues;
                                  TaxFreeEndingVal = obj.TaxFreeEndingValues;
                                  endingValPV = obj.endingValuesPV;
                                  TaxableProp = obj.taxableProp;
                                  TaxFreeProp = obj.taxfreeProp;

                              }


                              obj["owner"] = x.pensionId;
                              obj["type"] = "Partner";
                              obj["name"] = "Opening Value";


                              if (x.pensionRebootFromDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.pensionRebootFromType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.pensionRebootFromDate) {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.pensionRebootFromDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {

                                          begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                                      }
                                  }


                                  if ((this.clientDetails.startDate + i) == x.pensionRebootFromDate || x.pensionRebootFromType == "Existing") {
                                      //TODO Confirm negative
                                      if (x.taxableComponent != 0 && x.value != 0) {
                                          TaxableProp = (Number(x.taxableComponent) / Number(x.value));
                                      }
                                      else {
                                          TaxableProp = 0;
                                      }
                                      TaxFreeProp = 1 - TaxableProp;

                                      TaxableBegVal[this.clientDetails.startDate + i] = x.taxableComponent.toFixed();
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = x.taxFreeComponent.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.pensionRebootFromDate) {

                                      TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {

                                      TaxableBegVal[this.clientDetails.startDate + i] = Number(TaxableEndingVal[Number(this.clientDetails.startDate + i) - 1]);
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = Number(TaxFreeEndingVal[Number(this.clientDetails.startDate + i) - 1]);
                                  }
                              }
                              else {
                                  TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }


                              ////growth & income
                              var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                              var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                              var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (Number(income[this.clientDetails.startDate + i]) * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //pension Income
                              var preservation = this.preservationAge.sort((a: any, b: any) => a.dob - b.dob);
                              var minPendionDD = this.minimumPensionDrawdown.sort((a: any, b: any) => a.age - b.age);
                              var currentYear = this.clientDetails.startDate + i;
                              var pAge: number = 0;
                              var minRate: number = 0;

                              for (var k = 0; k < preservation.length; k++) {


                                  if ((k == (preservation.length - 1)) && (this.clientDetails.partnerDob >= preservation[k].dob)) {
                                      pAge = preservation[k].age;

                                  }
                                  else if (k == 0 && ((this.clientDetails.partnerDob) <= preservation[k].dob)) {
                                      pAge = preservation[k].age;
                                      break;

                                  }
                                  else if ((this.clientDetails.partnerDob) > preservation[k].dob && (this.clientDetails.partnerDob) <= preservation[k + 1].dob) {
                                      pAge = preservation[k + 1].age;
                                      break;

                                  }
                              }
                              var date1 = new Date("7/01/ " + (this.clientDetails.startDate + i));
                              var date2 = new Date(this.clientDetails.partnerDob);
                              var timeDiff = Math.abs(date2.getTime() - date1.getTime());
                              var diffDays = (Math.ceil(timeDiff / (1000 * 3600 * 24))) / 365;

                              var partnerAge = Math.round(diffDays * 10) / 10;

                              for (var l = 0; l < minPendionDD.length; l++) {


                                  if ((l == (minPendionDD.length - 1)) && (partnerAge >= minPendionDD[l].age)) {
                                      minRate = minPendionDD[l].minimumDrawdown;

                                  }
                                  else if (l == 0 && (partnerAge <= minPendionDD[l].age)) {
                                      minRate = minPendionDD[l].minimumDrawdown;
                                      break;

                                  }
                                  else if (partnerAge > minPendionDD[l].age && partnerAge <= minPendionDD[l + 1].age) {
                                      minRate = minPendionDD[l + 1].minimumDrawdown;
                                      break;

                                  }
                              }


                              var minDrawdown: number = 0;
                              var maxDrawdown: number = 0;

                              if (partnerAge < pAge) {
                                  minDrawdown = 0;
                                  maxDrawdown = 0;
                              }
                              else if (partnerAge >= pAge && partnerAge < 65) {
                                  if (this.partnerRetirementYear != 0 && this.partnerRetirementYear <= (this.clientDetails.startDate + i)) {
                                      minDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (minRate / 100);
                                      maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]);

                                  }
                                  else {
                                      minDrawdown = 0;
                                      maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (10 / 100);
                                  }

                              }
                              else if (partnerAge >= 65) {
                                  minDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (minRate / 100);
                                  maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]);
                              }


                              if (x.pensionRebootFromDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {

                                  if (this.pensionDrawDown.length > 0) {
                                  let pIncomeSum: number = 0;
                                  this.pensionDrawDown.forEach((y: any) => {

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.amount == 0) {
                                              if (y.type == "Minimum") {
                                                  pensionIncome[this.clientDetails.startDate + i] = minDrawdown.toFixed();
                                              } else if (y.type == "Maximum") {
                                                  pensionIncome[this.clientDetails.startDate + i] = maxDrawdown.toFixed();
                                              }
                                          }
                                          else {
                                              pensionIncome[this.clientDetails.startDate + i] = (Math.min(maxDrawdown, Math.max(minDrawdown, y.amount))).toFixed();
                                          }
                                          //var t = parseInt(y.amount);
                                          //ContributionSum = ContributionSum + t;
                                      }

                                  });
                                  }
                                  else {
                                      pensionIncome[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  pensionIncome[this.clientDetails.startDate + i] = 0;
                              }


                              if (partnerAge >= pAge && partnerAge < 60) {
                                  pITaxAssessable[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) * TaxableProp).toFixed();
                                  pITaxExempt[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) - pITaxAssessable[this.clientDetails.startDate + i]).toFixed();
                              }
                              else if (partnerAge >= 60) {
                                  pITaxAssessable[this.clientDetails.startDate + i] = 0;
                                  pITaxExempt[this.clientDetails.startDate + i] = Number(pensionIncome[this.clientDetails.startDate + i]).toFixed();
                              }

                              //Ending Value
                              endingVal[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(pensionIncome[this.clientDetails.startDate + i]);

                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              ////Ending Value - Taxable
                              TaxableEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) * TaxableProp).toFixed();

                              TaxFreeEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) - TaxFreeProp).toFixed();


                              obj["BegValues"] = begVal;
                              obj["TaxableBegValues"] = TaxableBegVal;
                              obj["TaxFreeBegValues"] = TaxFreeBegVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["pensionIncomeValues"] = pensionIncome;
                              obj["pITaxAssessableValues"] = pITaxAssessable;
                              obj["pITaxExemptValues"] = pITaxExempt;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["TaxableEndingValues"] = TaxableEndingVal;
                              obj["TaxFreeEndingValues"] = TaxFreeEndingVal;
                              //TODO: Verify
                              obj["taxableProp"] = TaxableProp;
                              obj["taxfreeProp"] = TaxFreeProp;


                              if (this.PensionValueOptimized.find((y: any) => y.owner === x.pensionId) != null) {
                                  this.PensionValueOptimized[this.PensionValueOptimized.findIndex((c: any) => c.owner === x.pensionId)] = obj;
                              }
                              else {
                                  this.PensionValueOptimized.push(obj);

                              }


                          });

                          //PensionTotals

                          this.calculateTotalPensionIncomeOptimized("TotalPensionIncome", i);
                          this.calculatePensionIncomeTaxableOptimized("PensionIncome-client", "Client", i);
                          this.calculatePensionIncomeTaxableOptimized("PensionIncome-partner", "Partner", i);
                          this.calculateSuperIncomeTaxOffsetOptimized("SIncomeTaxOffset-client", "Client", i);
                          this.calculateSuperIncomeTaxOffsetOptimized("SIncomeTaxOffset-partner", "Partner", i);



                          //Super Client
                          this.superClient.forEach((x: any) => { // client
                              var superStrategySS = strategyOrder.filter(c => c.id === x.superId).filter(c => c.type === "SS");
                              var superStrategyNCC = strategyOrder.filter(c => c.id === x.superId).filter(c => c.type === "NCC");

                              this.superSS = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "SS");
                              this.superPNC = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "PNC");
                              this.superSpouse = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "Spouse");
                              this.superLumpSum = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "LumpSum");


                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }


                              var obj = this.SuperValueOptimized.find((y: any) => y.owner === x.superId);
                              var begVal: any = {};
                              var TaxableBegVal: any = {};
                              var TaxFreeBegVal: any = {};
                              var growth: any = {};
                              var income: any = {};
                              var frankingCredits: any = {};
                              var insurance: any = {};
                              var sgContr: any = {};
                              var ssContr: any = {};
                              var pncContr: any = {};
                              var spouseContr: any = {};
                              var lumpSum: any = {};
                              var lumpSumTaxable: any = {};
                              var taxPayable: any = {};

                              var endingVal: any = {};
                              var TaxableEndingVal: any = {};
                              var TaxFreeEndingVal: any = {};
                              var endingValPV: any = {};

                              if (obj == null) {
                                  obj = {};

                              }
                              else {
                                  begVal = obj.BegValues;
                                  TaxableBegVal = obj.TaxableBegValues;
                                  TaxFreeBegVal = obj.TaxFreeBegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  frankingCredits = obj.frankingCreditsValues;

                                  insurance = obj.insuranceValues;
                                  sgContr = obj.sgContrValues;
                                  ssContr = obj.ssContrValues;
                                  pncContr = obj.pncContrValues;
                                  spouseContr = obj.spouseContrValues;
                                  lumpSum = obj.lumpSumValues;
                                  lumpSumTaxable = obj.lumpSumTaxableValues;
                                  taxPayable = obj.taxPayableValues;

                                  endingVal = obj.endingValues;
                                  TaxableEndingVal = obj.TaxableEndingValues;
                                  TaxFreeEndingVal = obj.TaxFreeEndingValues;
                                  endingValPV = obj.endingValuesPV;


                              }


                              obj["owner"] = x.superId;
                              obj["type"] = "Client";
                              obj["name"] = "Opening Value";

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.startDateType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.startDate) {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.startDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {

                                          begVal[this.clientDetails.startDate + i] = (Number(endingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                      }
                                  }


                                  if ((this.clientDetails.startDate + i) == x.startDate) {
                                      TaxableBegVal[this.clientDetails.startDate + i] = x.taxableComponent.toFixed();
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = x.taxFreeComponent.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.startDate) {

                                      TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {

                                      TaxableBegVal[this.clientDetails.startDate + i] = (Number(TaxableEndingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = (Number(TaxFreeEndingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                  }
                              }
                              else {
                                  TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }


                              ////growth & income
                              var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                              var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                              var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //insurance

                              let insuranceVal: number = 0;

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  insuranceVal = parseInt(x.insuranceCost);
                              }

                              insurance[this.clientDetails.startDate + i] = insuranceVal;

                              //Super Guarantee

                              var cc_cap = this.superAssumptions.filter((a: any) => a.type == "CC_Cap");
                              var cc_cap_val = cc_cap[0].value;

                              var ncc_cap = this.superAssumptions.filter((a: any) => a.type == "NCC_Cap");
                              var ncc_cap_val = cc_cap[0].value;

                              var mscb = this.superAssumptions.filter((a: any) => a.type == "MSCB");
                              var mscb_val = mscb[0].value;


                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (x.increaseToLimit == "Y") {

                                      let ContributionSum: number = 0;
                                      this.superSS.forEach((y: any) => {

                                          if (y.fromDateType == "Start") {
                                              y.fromDate = this.clientDetails.startDate;
                                          }
                                          if (y.toDateType == "End") {
                                              y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                          }

                                          if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                              var t = parseInt(y.amount);
                                              ContributionSum = ContributionSum + t;
                                          }

                                      });

                                      sgContr[this.clientDetails.startDate + i] = (cc_cap_val - ContributionSum).toFixed();
                                  }
                                  else {
                                      //TODO: get SGCRatev-verify
                                      var sgcRate: number = 1;

                                      if (x.sgrate == "SGC") {
                                          var sgc = this.sgcRates.sort((a: any, b: any) => a.year - b.year);
                                          var currentYear = this.clientDetails.startDate + i;


                                          for (var j = 0; j < sgc.length; j++) {


                                              if ((j == (sgc.length - 1)) && ((this.clientDetails.startDate + i) >= sgc[j].year)) {
                                                  sgcRate = sgc[j].sgcrate1;

                                              }
                                              else if (j == 0 && ((this.clientDetails.startDate + i) <= sgc[j].year)) {
                                                  sgcRate = sgc[j].sgcrate1;
                                                  break;

                                              }
                                              else if ((this.clientDetails.startDate + i) > sgc[j].year && (this.clientDetails.startDate + i) <= sgc[j + 1].year) {
                                                  sgcRate = sgc[j + 1].sgcrate1;
                                                  break;

                                              }
                                          }

                                      }
                                      else {
                                          sgcRate = Number(x.sgrate);
                                      }

                                      var cEmploymentIncome = clientEmploymentIncome.filter((g: any) => g.type === "Employment");

                                      var totalcEmploymentIncome = 0;
                                      for (var k = 0; k < cEmploymentIncome.length; k++) {
                                          if (isNaN(cEmploymentIncome[k].values[this.clientDetails.startDate + i])) {
                                              continue;
                                          }
                                          totalcEmploymentIncome += Number(cEmploymentIncome[k].values[this.clientDetails.startDate + i]);
                                      }




                                      // sgContr[this.clientDetails.startDate + i] = Math.min((x.superSalary * (sgcRate / 100)), mscb_val);
                                      sgContr[this.clientDetails.startDate + i] = (Math.min((totalcEmploymentIncome * (sgcRate / 100)), mscb_val)).toFixed();

                                  }
                              }
                              else {
                                  sgContr[this.clientDetails.startDate + i] = 0;
                              }

                              //Salary Sacrifice
                              if (superStrategySS.length > 0 && superStrategySS[0].AllocatedValue > 0) {
                                  ssContr[this.clientDetails.startDate + i] = Number(superStrategySS[0].AllocatedValue);
                              }
                              else {
                                  let SalarySacrificeSum: number = 0;
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      this.superSS.forEach((y: any) => { // client

                                          if (y.fromDateType == "Start") {
                                              y.fromDate = this.clientDetails.startDate;
                                          }
                                          if (y.toDateType == "End") {
                                              y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                          }

                                          if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                              if (y.increaseToLimit == "Y") {

                                                  var sgContr: number = 0;
                                                  var sgcRate: number = 1;



                                                  if (x.sgrate == "SGC") {
                                                      var sgc = this.sgcRates.sort((a: any, b: any) => a.year - b.year);
                                                      var currentYear = this.clientDetails.startDate + i;
                                                      for (var j = 0; j < sgc.length; j++) {
                                                          if ((j == (sgc.length - 1)) && ((this.clientDetails.startDate + i) >= sgc[j].year)) {
                                                              sgcRate = sgc[j].sgcrate1;

                                                          }
                                                          else if (j == 0 && ((this.clientDetails.startDate + i) <= sgc[j].year)) {
                                                              sgcRate = sgc[j].sgcrate1;
                                                              break;

                                                          }
                                                          else if ((this.clientDetails.startDate + i) > sgc[j].year && (this.clientDetails.startDate + i) <= sgc[j + 1].year) {
                                                              sgcRate = sgc[j + 1].sgcrate1;
                                                              break;

                                                          }
                                                      }

                                                  }
                                                  else {
                                                      sgcRate = Number(x.sgrate);
                                                  }

                                                  var cEmploymentIncome = clientEmploymentIncome.filter((g: any) => g.type === "Employment");

                                                  var totalcEmploymentIncome = 0;
                                                  for (var k = 0; k < cEmploymentIncome.length; k++) {
                                                      if (isNaN(cEmploymentIncome[k].values[this.clientDetails.startDate + i])) {
                                                          continue;
                                                      }
                                                      totalcEmploymentIncome += Number(cEmploymentIncome[k].values[this.clientDetails.startDate + i]);
                                                  }

                                                  //sgContr = Math.min((x.superSalary * (sgcRate / 100)), mscb_val);
                                                  sgContr = Math.min((totalcEmploymentIncome * (sgcRate / 100)), mscb_val);
                                                  SalarySacrificeSum = cc_cap_val - sgContr;
                                              }
                                              else {
                                                  var t = parseInt(y.amount);
                                                  SalarySacrificeSum = SalarySacrificeSum + t;
                                              }



                                          }

                                      });

                                      ssContr[this.clientDetails.startDate + i] = (SalarySacrificeSum).toFixed();
                                  }
                                  else {
                                      ssContr[this.clientDetails.startDate + i] = 0;
                                  }
                              }

                              //PNC Contribution
                              if (superStrategyNCC.length > 0 && superStrategyNCC[0].AllocatedValue > 0) {
                                  pncContr[this.clientDetails.startDate + i] = Number(superStrategyNCC[0].AllocatedValue);
                              }
                              else {
                                  let PNCContributionSum: number = 0;
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      this.superPNC.forEach((y: any) => { // client

                                          if (y.fromDateType == "Start") {
                                              y.fromDate = this.clientDetails.startDate;
                                          }
                                          if (y.toDateType == "End") {
                                              y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                          }

                                          if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                              if (y.increaseToLimit == "Y") {
                                                  let SpouseSum: number = 0;
                                                  this.superSpouse.forEach((y: any) => {

                                                      if (y.fromDateType == "Start") {
                                                          y.fromDate = this.clientDetails.startDate;
                                                      }
                                                      if (y.toDateType == "End") {
                                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                                      }

                                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                          var t = parseInt(y.amount);
                                                          SpouseSum = SpouseSum + t;
                                                      }

                                                  });

                                                  PNCContributionSum = ncc_cap_val - SpouseSum;

                                              }
                                              else {
                                                  var t = parseInt(y.amount);
                                                  PNCContributionSum = PNCContributionSum + t;
                                              }
                                          }

                                      });
                                      pncContr[this.clientDetails.startDate + i] = (PNCContributionSum).toFixed();;
                                  }
                                  else {
                                      pncContr[this.clientDetails.startDate + i] = 0;
                                  }
                              }


                              //Spouse Contribution
                              let SpouseContributionSum: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  this.superSpouse.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.increaseToLimit == "Y") {
                                              let PNCSum: number = 0;
                                              this.superPNC.forEach((y: any) => {

                                                  if (y.fromDateType == "Start") {
                                                      y.fromDate = this.clientDetails.startDate;
                                                  }
                                                  if (y.toDateType == "End") {
                                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                                  }

                                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                      var t = parseInt(y.amount);
                                                      PNCSum = PNCSum + t;
                                                  }

                                              });

                                              SpouseContributionSum = ncc_cap_val - PNCSum;

                                          }
                                          else {
                                              var t = parseInt(y.amount);
                                              SpouseContributionSum = SpouseContributionSum + t;
                                          }
                                      }

                                  });
                                  spouseContr[this.clientDetails.startDate + i] = (SpouseContributionSum).toFixed();
                              }
                              else {
                                  spouseContr[this.clientDetails.startDate + i] = 0;
                              }
                              //Lumpsum Withdrawals
                              let LumpsumWithdrawalsSum: number = 0;
                              let LumpsumTaxableSum: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  this.superLumpSum.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          var t = parseInt(y.amount);
                                          LumpsumWithdrawalsSum = LumpsumWithdrawalsSum + t;
                                      }

                                  });
                                  lumpSum[this.clientDetails.startDate + i] = LumpsumWithdrawalsSum;


                                  if (LumpsumWithdrawalsSum > 0) {
                                      var TaxableBeforLS = Number(TaxableBegVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]);
                                      //TODO: Add govtContr
                                      var ValueBeforeLS = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) + Number(pncContr[this.clientDetails.startDate + i]) + Number(spouseContr[this.clientDetails.startDate + i]);
                                      if (TaxableBeforLS != 0 && ValueBeforeLS != 0) {
                                          lumpSumTaxable[this.clientDetails.startDate + i] = LumpsumWithdrawalsSum * (TaxableBeforLS / ValueBeforeLS);
                                      }
                                      else {
                                          lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                                  else {
                                      lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  lumpSum[this.clientDetails.startDate + i] = 0;
                                  lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                              }


                              //Taxes Payable
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  var earningsTax = this.superAssumptions.filter((a: any) => a.type == "EarningsTaxRate");
                                  var earningsTax_val = earningsTax[0].value;

                                  var ccTaxRate = this.superAssumptions.filter((a: any) => a.type == "CCTaxRate");
                                  var ccTaxRate_val = ccTaxRate[0].value;

                                  var addTaxRate = this.superAssumptions.filter((a: any) => a.type == "AddTaxRate");
                                  var addTaxRate_val = addTaxRate[0].value;

                                  let ccTax: number = 0;
                                  var EarningsTax = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i])) * (earningsTax_val / 100);

                                  //var taxableIncome: any = {};
                                  //taxableIncome = this.clientTaxableIncome.filter(c => c.owner === "ClientTaxableIncome");
                                  //let taxableIncomeVal: number = Number(taxableIncome[0].values[this.clientDetails.startDate + i]);
                                  //if (taxableIncomeVal <= 250000) {
                                  ccTax = (Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i])) * (ccTaxRate_val / 100);
                                  //}
                                  //else {
                                  //    ccTax = (sgContr[this.clientDetails.startDate + i] + ssContr[this.clientDetails.startDate + i]) * ((ccTaxRate_val / 100) + (addTaxRate_val / 100));

                                  //}
                                  taxPayable[this.clientDetails.startDate + i] = (EarningsTax + ccTax).toFixed()
                              }
                              else {
                                  taxPayable[this.clientDetails.startDate + i] = 0;
                              }




                              //Ending Value
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) + Number(pncContr[this.clientDetails.startDate + i]) + Number(spouseContr[this.clientDetails.startDate + i]) - Number(taxPayable[this.clientDetails.startDate + i]) - Number(lumpSum[this.clientDetails.startDate + i])).toFixed()

                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              //Ending Value - Taxable
                              TaxableEndingVal[this.clientDetails.startDate + i] = (Number(TaxableBegVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) - Number(taxPayable[this.clientDetails.startDate + i]) - Number(lumpSum[this.clientDetails.startDate + i])).toFixed();

                              TaxFreeEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) - Number(TaxableEndingVal[this.clientDetails.startDate + i])).toFixed();


                              obj["BegValues"] = begVal;
                              obj["TaxableBegValues"] = TaxableBegVal;
                              obj["TaxFreeBegValues"] = TaxFreeBegVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["insuranceValues"] = insurance;
                              obj["sgContrValues"] = sgContr;
                              obj["ssContrValues"] = ssContr;
                              obj["pncContrValues"] = pncContr;
                              obj["spouseContrValues"] = spouseContr;
                              obj["lumpSumValues"] = lumpSum;
                              obj["lumpSumTaxableValues"] = lumpSumTaxable;
                              obj["taxPayableValues"] = taxPayable;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["TaxableEndingValues"] = TaxableEndingVal;
                              obj["TaxFreeEndingValues"] = TaxFreeEndingVal;

                              if (this.SuperValueOptimized.find((y: any) => y.owner === x.superId) != null) {
                                  this.SuperValueOptimized[this.SuperValueOptimized.findIndex((c: any) => c.owner === x.superId)] = obj;
                              }
                              else {
                                  this.SuperValueOptimized.push(obj);

                              }

                          });
                          this.superPartner.forEach((x: any) => { // client

                              this.superSS = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "SS");
                              this.superPNC = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "PNC");
                              this.superSpouse = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "Spouse");
                              this.superLumpSum = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "LumpSum");


                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.SuperValueOptimized.find((y: any) => y.owner === x.superId);
                              var begVal: any = {};
                              var TaxableBegVal: any = {};
                              var TaxFreeBegVal: any = {};
                              var growth: any = {};
                              var income: any = {};
                              var frankingCredits: any = {};
                              var insurance: any = {};
                              var sgContr: any = {};
                              var ssContr: any = {};
                              var pncContr: any = {};
                              var spouseContr: any = {};
                              var lumpSum: any = {};
                              var lumpSumTaxable: any = {};
                              var taxPayable: any = {};

                              var endingVal: any = {};
                              var TaxableEndingVal: any = {};
                              var TaxFreeEndingVal: any = {};
                              var endingValPV: any = {};

                              if (obj == null) {
                                  obj = {};

                              }
                              else {
                                  begVal = obj.BegValues;
                                  TaxableBegVal = obj.TaxableBegValues;
                                  TaxFreeBegVal = obj.TaxFreeBegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  frankingCredits = obj.frankingCreditsValues;

                                  insurance = obj.insuranceValues;
                                  sgContr = obj.sgContrValues;
                                  ssContr = obj.ssContrValues;
                                  pncContr = obj.pncContrValues;
                                  spouseContr = obj.spouseContrValues;
                                  lumpSum = obj.lumpSumValues;
                                  lumpSumTaxable = obj.lumpSumTaxableValues;
                                  taxPayable = obj.taxPayableValues;

                                  endingVal = obj.endingValues;
                                  TaxableEndingVal = obj.TaxableEndingValues;
                                  TaxFreeEndingVal = obj.TaxFreeEndingValues;
                                  endingValPV = obj.endingValuesPV;


                              }


                              obj["owner"] = x.superId;
                              obj["type"] = "Partner";
                              obj["name"] = "Opening Value";

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.startDateType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.startDate) {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.startDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {

                                          begVal[this.clientDetails.startDate + i] = (Number(endingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                      }
                                  }


                                  if ((this.clientDetails.startDate + i) == x.startDate) {
                                      TaxableBegVal[this.clientDetails.startDate + i] = x.taxableComponent.toFixed();
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = x.taxFreeComponent.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.startDate) {

                                      TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {

                                      TaxableBegVal[this.clientDetails.startDate + i] = (Number(TaxableEndingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = (Number(TaxFreeEndingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                  }
                              }
                              else {
                                  TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }


                              ////growth & income
                              var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                              var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                              var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //insurance

                              let insuranceVal: number = 0;

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  insuranceVal = parseInt(x.insuranceCost);
                              }

                              insurance[this.clientDetails.startDate + i] = insuranceVal;

                              //Super Guarantee

                              var cc_cap = this.superAssumptions.filter((a: any) => a.type == "CC_Cap");
                              var cc_cap_val = cc_cap[0].value;

                              var ncc_cap = this.superAssumptions.filter((a: any) => a.type == "NCC_Cap");
                              var ncc_cap_val = cc_cap[0].value;

                              var mscb = this.superAssumptions.filter((a: any) => a.type == "MSCB");
                              var mscb_val = mscb[0].value;


                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (x.increaseToLimit == "Y") {

                                      let ContributionSum: number = 0;
                                      this.superSS.forEach((y: any) => {

                                          if (y.fromDateType == "Start") {
                                              y.fromDate = this.clientDetails.startDate;
                                          }
                                          if (y.toDateType == "End") {
                                              y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                          }

                                          if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                              var t = parseInt(y.amount);
                                              ContributionSum = ContributionSum + t;
                                          }

                                      });

                                      sgContr[this.clientDetails.startDate + i] = (cc_cap_val - ContributionSum).toFixed();
                                  }
                                  else {
                                      //TODO: get SGCRatev-verify
                                      var sgcRate: number = 1;

                                      if (x.sgrate == "SGC") {
                                          var sgc = this.sgcRates.sort((a: any, b: any) => a.year - b.year);
                                          var currentYear = this.clientDetails.startDate + i;


                                          for (var j = 0; j < sgc.length; j++) {


                                              if ((j == (sgc.length - 1)) && ((this.clientDetails.startDate + i) >= sgc[j].year)) {
                                                  sgcRate = sgc[j].sgcrate1;

                                              }
                                              else if (j == 0 && ((this.clientDetails.startDate + i) <= sgc[j].year)) {
                                                  sgcRate = sgc[j].sgcrate1;
                                                  break;

                                              }
                                              else if ((this.clientDetails.startDate + i) > sgc[j].year && (this.clientDetails.startDate + i) <= sgc[j + 1].year) {
                                                  sgcRate = sgc[j + 1].sgcrate1;
                                                  break;

                                              }
                                          }

                                      }
                                      else {
                                          sgcRate = Number(x.sgrate);
                                      }

                                      var pEmploymentIncome = partnerEmploymentIncome.filter((g: any) => g.type === "Employment");

                                      var totalpEmploymentIncome = 0;
                                      for (var k = 0; k < pEmploymentIncome.length; k++) {
                                          if (isNaN(pEmploymentIncome[k].values[this.clientDetails.startDate + i])) {
                                              continue;
                                          }
                                          totalpEmploymentIncome += Number(pEmploymentIncome[k].values[this.clientDetails.startDate + i]);
                                      }

                                      //TODO: Verify if correct
                                      //sgContr[this.clientDetails.startDate + i] = Math.min((x.superSalary * (sgcRate / 100)), mscb_val);
                                      sgContr[this.clientDetails.startDate + i] = (Math.min((totalpEmploymentIncome * (sgcRate / 100)), mscb_val)).toFixed();

                                  }
                              }
                              else {
                                  sgContr[this.clientDetails.startDate + i] = 0;
                              }

                              //Salary Sacrifice

                              let SalarySacrificeSum: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  this.superSS.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.increaseToLimit == "Y") {

                                              var sgContr: number = 0;
                                              var sgcRate: number = 1;



                                              if (x.sgrate == "SGC") {
                                                  var sgc = this.sgcRates.sort((a: any, b: any) => a.year - b.year);
                                                  var currentYear = this.clientDetails.startDate + i;
                                                  for (var j = 0; j < sgc.length; j++) {
                                                      if ((j == (sgc.length - 1)) && ((this.clientDetails.startDate + i) >= sgc[j].year)) {
                                                          sgcRate = sgc[j].sgcrate1;

                                                      }
                                                      else if (j == 0 && ((this.clientDetails.startDate + i) <= sgc[j].year)) {
                                                          sgcRate = sgc[j].sgcrate1;
                                                          break;

                                                      }
                                                      else if ((this.clientDetails.startDate + i) > sgc[j].year && (this.clientDetails.startDate + i) <= sgc[j + 1].year) {
                                                          sgcRate = sgc[j + 1].sgcrate1;
                                                          break;

                                                      }
                                                  }

                                              }
                                              else {
                                                  sgcRate = Number(x.sgrate);
                                              }

                                              var pEmploymentIncome = partnerEmploymentIncome.filter((g: any) => g.type === "Employment");

                                              var totalpEmploymentIncome = 0;
                                              for (var k = 0; k < pEmploymentIncome.length; k++) {
                                                  if (isNaN(pEmploymentIncome[k].values[this.clientDetails.startDate + i])) {
                                                      continue;
                                                  }
                                                  totalpEmploymentIncome += Number(pEmploymentIncome[k].values[this.clientDetails.startDate + i]);
                                              }

                                              //TODO: Verify if correct
                                              sgContr = Math.min((totalpEmploymentIncome * (sgcRate / 100)), mscb_val);
                                              SalarySacrificeSum = cc_cap_val - sgContr;
                                          }
                                          else {
                                              var t = parseInt(y.amount);
                                              SalarySacrificeSum = SalarySacrificeSum + t;
                                          }



                                      }

                                  });

                                  ssContr[this.clientDetails.startDate + i] = (SalarySacrificeSum).toFixed();
                              }
                              else {
                                  ssContr[this.clientDetails.startDate + i] = 0;
                              }

                              //PNC Contribution
                              let PNCContributionSum: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  this.superPNC.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.increaseToLimit == "Y") {
                                              let SpouseSum: number = 0;
                                              this.superSpouse.forEach((y: any) => {

                                                  if (y.fromDateType == "Start") {
                                                      y.fromDate = this.clientDetails.startDate;
                                                  }
                                                  if (y.toDateType == "End") {
                                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                                  }

                                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                      var t = parseInt(y.amount);
                                                      SpouseSum = SpouseSum + t;
                                                  }

                                              });

                                              PNCContributionSum = ncc_cap_val - SpouseSum;

                                          }
                                          else {
                                              var t = parseInt(y.amount);
                                              PNCContributionSum = PNCContributionSum + t;
                                          }
                                      }

                                  });
                                  pncContr[this.clientDetails.startDate + i] = (PNCContributionSum).toFixed();
                              }
                              else {
                                  pncContr[this.clientDetails.startDate + i] = 0;
                              }

                              //Spouse Contribution
                              let SpouseContributionSum: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  this.superSpouse.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.increaseToLimit == "Y") {
                                              let PNCSum: number = 0;
                                              this.superPNC.forEach((y: any) => {

                                                  if (y.fromDateType == "Start") {
                                                      y.fromDate = this.clientDetails.startDate;
                                                  }
                                                  if (y.toDateType == "End") {
                                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                                  }

                                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                      var t = parseInt(y.amount);
                                                      PNCSum = PNCSum + t;
                                                  }

                                              });

                                              SpouseContributionSum = ncc_cap_val - PNCSum;

                                          }
                                          else {
                                              var t = parseInt(y.amount);
                                              SpouseContributionSum = SpouseContributionSum + t;
                                          }
                                      }

                                  });
                                  spouseContr[this.clientDetails.startDate + i] = (SpouseContributionSum).toFixed();
                              }
                              else {
                                  spouseContr[this.clientDetails.startDate + i] = 0;
                              }
                              //Lumpsum Withdrawals
                              let LumpsumWithdrawalsSum: number = 0;
                              let LumpsumTaxableSum: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  this.superLumpSum.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          var t = parseInt(y.amount);
                                          LumpsumWithdrawalsSum = LumpsumWithdrawalsSum + t;
                                      }

                                  });
                                  lumpSum[this.clientDetails.startDate + i] = LumpsumWithdrawalsSum;


                                  if (LumpsumWithdrawalsSum > 0) {
                                      var TaxableBeforLS = Number(TaxableBegVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]);
                                      //TODO: Add govtContr
                                      var ValueBeforeLS = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) + Number(pncContr[this.clientDetails.startDate + i]) + Number(spouseContr[this.clientDetails.startDate + i]);
                                      if (TaxableBeforLS != 0 && ValueBeforeLS != 0) {
                                          lumpSumTaxable[this.clientDetails.startDate + i] = LumpsumWithdrawalsSum * (TaxableBeforLS / ValueBeforeLS);
                                      }
                                      else {
                                          lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                                  else {
                                      lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  lumpSum[this.clientDetails.startDate + i] = 0;
                                  lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                              }


                              //Taxes Payable
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  var earningsTax = this.superAssumptions.filter((a: any) => a.type == "EarningsTaxRate");
                                  var earningsTax_val = earningsTax[0].value;

                                  var ccTaxRate = this.superAssumptions.filter((a: any) => a.type == "CCTaxRate");
                                  var ccTaxRate_val = ccTaxRate[0].value;

                                  var addTaxRate = this.superAssumptions.filter((a: any) => a.type == "AddTaxRate");
                                  var addTaxRate_val = addTaxRate[0].value;

                                  let ccTax: number = 0;
                                  var EarningsTax = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i])) * (earningsTax_val / 100);

                                  //var taxableIncome: any = {};
                                  //taxableIncome = this.clientTaxableIncome.filter(c => c.owner === "ClientTaxableIncome");
                                  //let taxableIncomeVal: number = Number(taxableIncome[0].values[this.clientDetails.startDate + i]);
                                  //if (taxableIncomeVal <= 250000) {
                                  ccTax = (Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i])) * (ccTaxRate_val / 100);
                                  //}
                                  //else {
                                  //    ccTax = (sgContr[this.clientDetails.startDate + i] + ssContr[this.clientDetails.startDate + i]) * ((ccTaxRate_val / 100) + (addTaxRate_val / 100));

                                  //}
                                  taxPayable[this.clientDetails.startDate + i] = (EarningsTax + ccTax).toFixed()
                              }
                              else {
                                  taxPayable[this.clientDetails.startDate + i] = 0;
                              }




                              //Ending Value
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) + Number(pncContr[this.clientDetails.startDate + i]) + Number(spouseContr[this.clientDetails.startDate + i]) - Number(taxPayable[this.clientDetails.startDate + i]) - Number(lumpSum[this.clientDetails.startDate + i])).toFixed()

                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              //Ending Value - Taxable
                              TaxableEndingVal[this.clientDetails.startDate + i] = (Number(TaxableBegVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) - Number(taxPayable[this.clientDetails.startDate + i]) - Number(lumpSum[this.clientDetails.startDate + i])).toFixed();

                              TaxFreeEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) - Number(TaxableEndingVal[this.clientDetails.startDate + i])).toFixed();


                              obj["BegValues"] = begVal;
                              obj["TaxableBegValues"] = TaxableBegVal;
                              obj["TaxFreeBegValues"] = TaxFreeBegVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["insuranceValues"] = insurance;
                              obj["sgContrValues"] = sgContr;
                              obj["ssContrValues"] = ssContr;
                              obj["pncContrValues"] = pncContr;
                              obj["spouseContrValues"] = spouseContr;
                              obj["lumpSumValues"] = lumpSum;
                              obj["lumpSumTaxableValues"] = lumpSumTaxable;
                              obj["taxPayableValues"] = taxPayable;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["TaxableEndingValues"] = TaxableEndingVal;
                              obj["TaxFreeEndingValues"] = TaxFreeEndingVal;

                              if (this.SuperValueOptimized.find((y: any) => y.owner === x.superId) != null) {
                                  this.SuperValueOptimized[this.SuperValueOptimized.findIndex((c: any) => c.owner === x.superId)] = obj;
                              }
                              else {
                                  this.SuperValueOptimized.push(obj);

                              }


                          });

                          //SuperTotals
                          this.calculateTotalLumpSumWithdrawalsOptimized("TotalLumpSumWithdrawals", i);
                          this.calculateTotalSalarySacrificeContributionOptimized("TotalSalarySacrificeContributions", i);
                          this.calculateTotalPNCContibutionOptimized("TotalPNCContributions", i);
                          this.calculateTotalSpouseContibutionOptimized("TotalSpouseContributions", i);
                          this.calculateLumpSumTaxOptimized("LumpSum-client", "Client", i);
                          this.calculateSalarySacrificeTaxOptimized("SalarySacrifice-client", "Client", i);
                          this.calculateLumpSumTaxOptimized("LumpSum-partner", "Partner", i);
                          this.calculateSalarySacrificeTaxOptimized("SalarySacrifice-partner", "Partner", i);


                          //Calculate Tax Deductions
                          this.EPRTClient.forEach((x: any) => { // client

                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }



                              var obj = this.ClientDeductionsOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;



                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;


                              if (this.ClientDeductionsOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  this.ClientDeductionsOptimized[this.ClientDeductionsOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  this.ClientDeductionsOptimized.push(obj);
                              }

                          })
                          this.EPRTPartner.forEach((x: any) => { // client

                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.PartnerDeductionsOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;


                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;


                              if (this.PartnerDeductionsOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  this.PartnerDeductionsOptimized[this.PartnerDeductionsOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  this.PartnerDeductionsOptimized.push(obj);
                              }

                          })
                          this.EPRTJoint.forEach((x: any) => { // joint

                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.ClientDeductionsOptimized.find((y: any) => y.id === "ClientJoint" + x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = "Client";
                              obj["name"] = x.cfname;
                              obj["id"] = "ClientJoint" + x.cflowId;


                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = (x.value / 2).toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = ((x.value * (Math.pow((1 + x.indexation / 100), j))) / 2).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;


                              if (this.ClientDeductionsOptimized.find((y: any) => y.id === "ClientJoint" + x.cflowId) != null) {
                                  this.ClientDeductionsOptimized[this.ClientDeductionsOptimized.findIndex((c: any) => c.id === "ClientJoint" + x.cflowId)] = obj;
                              }
                              else {
                                  this.ClientDeductionsOptimized.push(obj);
                              }

                          })
                          this.EPRTJoint.forEach((x: any) => { // joint

                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.PartnerDeductionsOptimized.find((y: any) => y.id === "PartnerJoint" + x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = "Partner";
                              obj["name"] = x.cfname;
                              obj["id"] = "PartnerJoint" + x.cflowId;


                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (j == 0) {
                                      obj1[this.clientDetails.startDate + i] = (x.value / 2).toFixed();

                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = ((x.value * (Math.pow((1 + x.indexation / 100), j))) / 2).toFixed();
                                  }
                                  j++;
                              }
                              else {
                                  obj1[this.clientDetails.startDate + i] = 0;
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;

                              if (this.PartnerDeductionsOptimized.find((y: any) => y.id === "PartnerJoint" + x.cflowId) != null) {
                                  this.PartnerDeductionsOptimized[this.PartnerDeductionsOptimized.findIndex((c: any) => c.id === "PartnerJoint" + x.cflowId)] = obj;
                              }
                              else {
                                  this.PartnerDeductionsOptimized.push(obj);
                              }

                          })


                          ////Calculate Tax Totals

                          this.calculateTotalTaxIncomeOptimized("TotalTax-client", "Client", i);
                          this.calculateCapitalLossAdjustmentOptimized("CLA-client", "Client", i);
                          this.calculateTotalAssessibleIncomeOptimized("ClientAssessibleIncome", "TotalTax-client", "Client", i);
                          this.calculateClientTotalDeductionsOptimized("ClientDeductions", "Client", i);
                          this.calculateClientTaxableIncomeOptimized(i);
                          this.calculateLowIncomeTOOptimized("ClientLowIncomeTO", "ClientTaxableIncome", "Client", i);
                          this.calculateRefundableTaxOffsetOptimized("ClientFrankingCredits", "Client", i);

                          this.calculateClientTotalNRTaxOffsetOptimized("ClientTotalTO", "ClientLowIncomeTO", i);
                          this.calculateGrossTaxOptimized("ClientGrossTax", "ClientTaxableIncome", "Client", i);
                          this.calculateMedicareLevyOptimized("ClientMedicareLevy", "ClientTaxableIncome", "Client", i);

                          this.calculateTaxPayableNonRefundableOptimized("ClientTPNonRefundable", "ClientGrossTax", "ClientTotalTO", "Client", i);
                          this.calculateTaxPayableRefundableOptimized("ClientTPRefundable", "ClientTPNonRefundable", "ClientFrankingCredits", "Client", i);
                          this.calculateTotalTaxesPayableOptimized("ClientTotalTaxPayable", "ClientTPRefundable", "ClientMedicareLevy", "Client", i);
                          this.calculateAverageTaxRateOptimized("ClientAverageTaxRate", "ClientTotalTaxPayable", "ClientAssessibleIncome", "Client", i);
                          this.calculateMarginalTaxRateOptimized("ClientMarginalTaxRate", "ClientTaxableIncome", "Client", i);


                          this.calculateTotalTaxIncomeOptimized("TotalTax-partner", "Partner", i);

                          this.calculateCapitalLossAdjustmentOptimized("CLA-partner", "Partner", i);
                          this.calculateTotalAssessibleIncomeOptimized("PartnerAssessibleIncome", "TotalTax-partner", "Partner", i);
                          this.calculatePartnerTotalDeductionsOptimized("PartnerDeductions", "Partner", i);
                          this.calculatePartnerTaxableIncomeOptimized(i);
                          this.calculateLowIncomeTOOptimized("PartnerLowIncomeTO", "PartnerTaxableIncome", "Partner", i);
                          this.calculateRefundableTaxOffsetOptimized("PartnerFrankingCredits", "Partner", i);

                          this.calculatePartnerTotalNRTaxOffsetOptimized("PartnerTotalTO", "PartnerLowIncomeTO", i);
                          this.calculateGrossTaxOptimized("PartnerGrossTax", "PartnerTaxableIncome", "Partner", i);
                          this.calculateMedicareLevyOptimized("PartnerMedicareLevy", "PartnerTaxableIncome", "Partner", i);

                          this.calculateTaxPayableNonRefundableOptimized("PartnerTPNonRefundable", "PartnerGrossTax", "PartnerTotalTO", "Partner", i);
                          this.calculateTaxPayableRefundableOptimized("PartnerTPRefundable", "PartnerTPNonRefundable", "PartnerFrankingCredits", "Partner", i);
                          this.calculateTotalTaxesPayableOptimized("PartnerTotalTaxPayable", "PartnerTPRefundable", "PartnerMedicareLevy", "Partner", i);
                          this.calculateAverageTaxRateOptimized("PartnerAverageTaxRate", "PartnerTotalTaxPayable", "PartnerAssessibleIncome", "Partner", i);
                          this.calculateMarginalTaxRateOptimized("PartnerMarginalTaxRate", "PartnerTaxableIncome", "Partner", i);
                          this.calculateTotalIncomeTaxPayableOptimized("TotalITPayable", i);



                          //Calculate Cashflow Totals
                          this.calculateTotalIncomeOptimized("Total-client", "Client", i);
                          this.calculateTotalIncomeOptimized("Total-partner", "Partner", i);
                          this.calculateTotalExpenditureOptimized("Total-client", "Client", i);
                          this.calculateTotalExpenditureOptimized("Total-partner", "Partner", i);
                          this.calculateTotalExpenditureOptimized("Total-joint", "Joint", i);

                          this.calculateTotalInflowsOptimized(i);
                          this.calculateTotalOutflowsOptimized(i);
                          this.calculateNetCashflowOptimized(i);
                          this.calculateNetAssetOptimized(i);


                          n++;

                      }
                  }
                  //Following years
                  else {
                      var incr = w + 1;
                      for (var i = w; i < incr ; i++) {  

                  

                          var clientCurrentAge = Number(this.clientAge + w);

                          for (var p = 0; p <= 1; p++) {

                              //Recheck strategies
                              if (p == 1) {
                                  var marginalTaxRate: number = 0;

                                  if (this.TotalPayableOptimized.filter(c => c.owner === "ClientMarginalTaxRate")[0].values[this.clientDetails.startDate + w] != 0) {
                                      marginalTaxRate = Number(this.TotalPayableOptimized.filter(c => c.owner === "ClientMarginalTaxRate")[0].values[this.clientDetails.startDate + w]) / 100;
                                  }
                                  else {
                                      marginalTaxRate = 0;
                                  }
                                  var openingVal: any[] = [];
                                  var cashSurplus: any = {};
                                  var existingCashSurplus = this.netCashFlowOptimized.filter(c => c.owner === "NetCashflow");
                                  cashSurplus["name"] = "Cash Surplus";
                                  cashSurplus["value"] = Number(existingCashSurplus[0].values[this.clientDetails.startDate + w]);
                                  if (this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].growth != 0) {
                                      cashSurplus["growth"] = Number(this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].growth) / 100;
                                  }
                                  else {
                                      cashSurplus["growth"] = 0;
                                  }
                                  if (this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].income != 0) {
                                      cashSurplus["income"] = Number(this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].income) / 100;
                                  }
                                  else {
                                      cashSurplus["income"] = 0;
                                  }

                                  cashSurplus["reinvest"] = "Y";
                                  cashSurplus["status"] = "Existing";
                                  cashSurplus["type"] = "CashSurplus";
                                  cashSurplus["id"] = 0;

                                  let varCSNRR = (Number(cashSurplus["growth"]) + Number(cashSurplus["income"])) * (1 - marginalTaxRate);
                                  cashSurplus["NRR"] = varCSNRR;

                                  openingVal.push(cashSurplus);

                                  this.investmentClientOptimized.forEach((x: any) => {
                                      var inclient = this.BeginningValueOptimized.filter(c => c.owner === x.investmentId);
                                      var obj: any = {};
                                      obj["name"] = x.name;
                                      obj["id"] = x.investmentId;
                                      obj["owner"] = x.owner;
                                      if (x.reinvest == "Y") {
                                          obj["value"] = Number(inclient[0].BegValues[this.clientDetails.startDate + w]) + Number(inclient[0].growthValues[this.clientDetails.startDate + w]) + Number(inclient[0].incomeValues[this.clientDetails.startDate + w]);
                                      }
                                      else {
                                          obj["value"] = Number(inclient[0].BegValues[this.clientDetails.startDate + w]) + Number(inclient[0].growthValues[this.clientDetails.startDate + w]);
                                      }
                                      obj["growth"] = Number(x.growth) / 100;
                                      obj["income"] = Number(x.income) / 100;
                                      obj["reinvest"] = x.reinvest;
                                      obj["status"] = "Existing";
                                      obj["type"] = 0;

                                      var NRR: number = 0;
                                      NRR = ((Number(x.growth) / 100) + (Number(x.income) / 100)) * (1 - marginalTaxRate);
                                      //NRR = ((Number(x.growth) / 100) + ((Number(x.income) / 100) * (1 - marginalTaxRate)));
                                      obj["NRR"] = NRR;
                                      openingVal.push(obj);

                                  });

                                  let cash: number = 0;
                                  openingVal.forEach((x: any) => {
                                      var t = parseInt(x.value);
                                      cash = cash + t;
                                  });






                                  //Check Eigibility

                                  var SalarySacrifice: any = {};
                                  var NCC: any = {};
                                  var Debt: any = {};
                                  var Investment: any = {};
                                  var strategies: any[] = [];

                                  //SS eligibiltiy

                                  if (clientCurrentAge < 65) {
                                      SalarySacrifice["type"] = "SS";
                                      strategies.push(SalarySacrifice);
                                  }
                                  else if (clientCurrentAge >= 65 && clientCurrentAge < 75) {
                                      var cEmploymentIncome = clientEmploymentIncome.filter((g: any) => g.type === "Employment");
                                      for (var j = 0; j < cEmploymentIncome.length; j++) {

                                          if (Number(cEmploymentIncome[j].values[this.clientDetails.startDate + w]) > 0) {
                                              SalarySacrifice["type"] = "SS";
                                              strategies.push(SalarySacrifice);
                                              break;
                                          }
                                      }

                                  }

                                  //NCC eligibility

                                  if (clientCurrentAge < 65) {
                                      NCC["type"] = "NCC";
                                      strategies.push(NCC);
                                  }
                                  else if (clientCurrentAge >= 65 && clientCurrentAge < 75) {
                                      var cEmploymentIncome = clientEmploymentIncome.filter((g: any) => g.type === "Employment");
                                      for (var j = 0; j < cEmploymentIncome.length; j++) {

                                          if (Number(cEmploymentIncome[j].values[this.clientDetails.startDate + w]) > 0) {
                                              NCC["type"] = "NCC";
                                              strategies.push(NCC);
                                              break;
                                          }
                                      }

                                  }

                                  //Investment eligibilty
                                  Investment["type"] = "Investment";
                                  strategies.push(Investment);

                                  //Debt eligibility

                                  for (var j = 0; j < this.liabilityClient.length; j++) {
                                      var lbclient = this.LBValueOptimized.filter(c => c.owner === this.liabilityClient[j].liabilityId);
                                      if (Number(lbclient[0].BegValues[this.clientDetails.startDate + w]) > 0) {
                                          Debt["type"] = "Debt";
                                          strategies.push(Debt);
                                          break;
                                      }
                                  }

                                  //Net Impact
                                  var NRR: any[] = [];
                                  strategies.forEach((x: any) => {

                                      if (x.type == "SS") {
                                          this.superClient.forEach((x: any) => {
                                              var obj: any = {};
                                              obj["name"] = "Salary Sacrifice";
                                              obj["id"] = x.superId;
                                              obj["type"] = "SS";
                                              obj["status"] = "Strategy";
                                              var val: number = 0;
                                              val = (marginalTaxRate - (15 / 100)) + (((Number(x.growth) / 100) + (Number(x.income) / 100)) * (1 - (15 / 100)));
                                              //val = (marginalTaxRate - (15 / 100)) + (Number(x.growth) / 100) + (((Number(x.income) / 100)) * (1 - (15 / 100)));
                                              obj["NRR"] = val;
                                              NRR.push(obj);

                                          });
                                      }
                                      else if (x.type == "NCC") {
                                          this.superClient.forEach((x: any) => {
                                              var obj: any = {};
                                              obj["name"] = "Non-concessional Contribution";
                                              obj["id"] = x.superId;
                                              obj["type"] = "NCC";
                                              obj["status"] = "Strategy";
                                              var val: number = 0;
                                              val = ((Number(x.growth) / 100) + (Number(x.income) / 100)) * (1 - (15 / 100));
                                              //val = (Number(x.growth) / 100) + ((Number(x.income) / 100) * (1 - (15 / 100)));
                                              obj["NRR"] = val;
                                              NRR.push(obj);

                                          });
                                      }
                                      else if (x.type == "Investment") {
                                          var growth = Number(this.assetAssumptions.filter((a: any) => a.name == this.clientDetails.clientRiskProfile)[0].growth) / 100;
                                          var income = Number(this.assetAssumptions.filter((a: any) => a.name == this.clientDetails.clientRiskProfile)[0].income) / 100;
                                          var obj: any = {};
                                          //obj["NRR"] = Number(growth + (income * (1 - marginalTaxRate)));
                                          obj["NRR"] = Number((growth + income) * (1 - marginalTaxRate));
                                          obj["type"] = "Investment";
                                          obj["status"] = "Strategy";
                                          obj["name"] = "Investment";
                                          obj["id"] = 0;
                                          NRR.push(obj);

                                      }
                                      else if (x.type == "Debt") {

                                          this.liabilityClient.forEach((x: any) => {
                                              var obj: any = {};
                                              obj["name"] = x.name;
                                              obj["id"] = x.liabilityId;
                                              obj["type"] = "Debt";
                                              obj["status"] = "Strategy";
                                              var val: number = 0;
                                              if (x.type == "Non-Deductible") {
                                                  if (marginalTaxRate != 1) {
                                                      val = ((x.interestRate / 100) / (1 - marginalTaxRate));
                                                  }
                                                  else {
                                                      val = 0;
                                                  }
                                              }
                                              else {
                                                  val = (x.interestRate / 100);
                                              }
                                              obj["NRR"] = val;
                                              NRR.push(obj);
                                          });
                                      }
                                  });


                                  NRR.forEach((x: any) => {
                                      strategyOrder.push(x);
                                  });
                                  openingVal.forEach((x: any) => {
                                      strategyOrder.push(x);
                                  });
                                  strategyOrder = strategyOrder.sort(function (obj1: any, obj2: any) {
                                      return obj2.NRR - obj1.NRR;
                                  });

                                  var existingCash = cash;
                                  strategyOrder.forEach((x: any) => {
                                      if (existingCash > 0 && x.type != "CashSurplus") {

                                          if (x.type == "SS") {
                                              var sg = this.SuperValue.filter(c => c.owner === x.id);
                                              var sgRate = Number(sg[0].sgContrValues[this.clientDetails.startDate + w]);
                                              var cap = 25000 - sgRate;

                                              if (existingCash >= cap) {
                                                  x["AllocatedValue"] = cap;
                                                  existingCash = existingCash - cap;
                                              }
                                              else {
                                                  x["AllocatedValue"] = existingCash;
                                                  existingCash = 0;
                                              }

                                          }
                                          else if (x.type == "NCC") {
                                              var cap = 100000;

                                              if (existingCash >= cap) {
                                                  x["AllocatedValue"] = cap;
                                                  existingCash = existingCash - cap;
                                              }
                                              else {
                                                  x["AllocatedValue"] = existingCash;
                                                  existingCash = 0;
                                              }
                                          }
                                          else if (x.type == "Debt") {
                                              var liability = this.LBValue.filter(c => c.owner === x.id);
                                              var liabilityVal = Number(liability[0].BegValues[this.clientDetails.startDate + w]) + Number(liability[0].accruedInterestValues[this.clientDetails.startDate + w]);


                                              if (existingCash >= liabilityVal) {
                                                  x["AllocatedValue"] = liabilityVal;
                                                  existingCash = existingCash - liabilityVal;
                                              }
                                              else {
                                                  x["AllocatedValue"] = existingCash;
                                                  existingCash = 0;
                                              }
                                          }
                                          else {
                                              if (existingCash >= 0) {
                                                  x["AllocatedValue"] = existingCash;
                                                  existingCash = 0;
                                              }

                                          }
                                      }
                                      else {
                                          x["AllocatedValue"] = 0;
                                      }
                                  });

                                  strategyOrder.forEach((x: any) => {

                                      if (x.type != "CashSurplus") {
                                          var obj: any = {};

                                          if (x.type == "SS") {

                                              obj = this.finalStrategies.filter((y: any) => y.type === "SS").filter((a: any) => a.id === x.id)[0]

                                          }
                                          else if (x.type == "NCC") {
                                              obj = this.finalStrategies.filter((y: any) => y.type === "NCC").filter((a: any) => a.id === x.id)[0]

                                          }
                                          else if (x.type == "Debt") {
                                              obj = this.finalStrategies.filter((y: any) => y.type === "Debt").filter((a: any) => a.id === x.id)[0]
                                          }
                                          else if (x.type == "Investment") {

                                              obj = this.finalStrategies.filter((y: any) => y.type === "Investment")[0]
                                          }
                                          else {
                                              obj = this.finalStrategies.filter((y: any) => y.status === "Existing").filter((a: any) => a.id === x.id)[0]
                                          }


                                          var obj1: any = {};

                                          if (obj == null || obj.length <= 0) {
                                              obj = {};

                                          }
                                          else {
                                              obj1 = obj.values;

                                          }

                                          obj["name"] = x.name;
                                          obj["id"] = x.id;
                                          obj["type"] = x.type;
                                          obj["status"] = x.status;

                                          obj1[this.clientDetails.startDate + w] = x.AllocatedValue.toFixed();



                                          obj["values"] = obj1;

                                          if (x.type == "SS") {
                                              var t = this.finalStrategies.filter((y: any) => y.type === "SS").filter((a: any) => a.id === x.id)

                                              if (t != null && t.length > 0) {
                                                  // this.finalStrategies[this.finalStrategies.findIndex((y: any) => (y.id === x.id && y.type === "SS"))] = obj;
                                                  for (var g = 0; g < this.finalStrategies.length; g++) {
                                                      if (this.finalStrategies[g].id == x.id && this.finalStrategies[g].type == "SS") {
                                                          this.finalStrategies[g] = obj
                                                      }
                                                  }
                                              }
                                              else {
                                                  this.finalStrategies.push(obj);

                                              }
                                          }
                                          else if (x.type == "NCC") {
                                              var t = this.finalStrategies.filter((y: any) => y.type === "NCC").filter((a: any) => a.id === x.id)



                                              if (t != null && t.length > 0) {

                                                  for (var f = 0; f < this.finalStrategies.length; f++) {
                                                      if (this.finalStrategies[f].id == x.id && this.finalStrategies[f].type == "NCC") {
                                                          this.finalStrategies[f] = obj
                                                      }
                                                  }

                                              }
                                              else {
                                                  this.finalStrategies.push(obj);

                                              }
                                          }
                                          else if (x.type == "Debt") {
                                              var t = this.finalStrategies.filter((y: any) => y.type === "Debt").filter((a: any) => a.id === x.id)

                                              if (t != null && t.length > 0) {
                                                  // this.finalStrategies[this.finalStrategies.findIndex(t:)] = obj;
                                                  for (var d = 0; d < this.finalStrategies.length; d++) {
                                                      if (this.finalStrategies[d].id == x.id && this.finalStrategies[d].type == "Debt") {
                                                          this.finalStrategies[d] = obj
                                                      }
                                                  }
                                              }
                                              else {
                                                  this.finalStrategies.push(obj);

                                              }
                                          }
                                          else if (x.type == "Investment") {
                                              var t = this.finalStrategies.filter((y: any) => y.type === "Investment")

                                              if (t != null && t.length > 0) {
                                                  // this.finalStrategies[this.finalStrategies.findIndex(t:)] = obj;
                                                  for (var b = 0; b < this.finalStrategies.length; b++) {
                                                      if (this.finalStrategies[b].type == "Investment") {
                                                          this.finalStrategies[b] = obj
                                                      }
                                                  }
                                              }
                                              else {
                                                  this.finalStrategies.push(obj);

                                              }
                                          }
                                          else {
                                              var t = this.finalStrategies.filter((y: any) => y.status === "Existing").filter((a: any) => a.id === x.id)

                                              if (t != null && t.length > 0) {

                                                  for (var c = 0; c < this.finalStrategies.length; c++) {
                                                      if (this.finalStrategies[c].id == x.id && this.finalStrategies[c].status == "Existing") {
                                                          this.finalStrategies[c] = obj
                                                      }
                                                  }
                                              }
                                              else {
                                                  this.finalStrategies.push(obj);

                                              }
                                          }
                                      }
                                  });
                              }

                          //Add new investment

                              if (p == 1) {
                                  var  newInvestmentStrategy = strategyOrder.filter(c => c.type === "Investment");
                                  if (newInvestmentStrategy.length > 0 && (newInvestmentStrategy[0].AllocatedValue > 0)) {
                                      var clientGrowth = this.assetAssumptions.filter((a: any) => a.name == this.clientDetails.clientRiskProfile)[0].growth;
                                      var clientIncome = this.assetAssumptions.filter((a: any) => a.name == this.clientDetails.clientRiskProfile)[0].income;
                                      var clientFranked = this.assetAssumptions.filter((a: any) => a.name == this.clientDetails.clientRiskProfile)[0].franking;
                                      var clientProductFees = this.assetAssumptions.filter((a: any) => a.name == this.clientDetails.clientRiskProfile)[0].productFees;
                                      var clientid = Math.max.apply(Math, this.investmentClientOptimized.map(function (o: any) { return o.investmentId }));
                                      var investmentDetails: any = {
                                          investmentId: Number(clientid) + 1,
                                          clientId: 0,
                                          type: this.clientDetails.clientRiskProfile,
                                          name: 'Investment Portfolio',
                                          owner: 'Client',
                                          value: Number(newInvestmentStrategy[0].AllocatedValue),
                                          growth: clientGrowth,
                                          income: clientIncome,
                                          franked: clientFranked,
                                          productFees: clientProductFees,
                                          costBase: 0,
                                          reinvest: 'Y',
                                          centrelink: 'N',
                                          startDateType: 'Year',
                                          startDate: Number(this.clientDetails.startDate + i),
                                          endDateType: 'Retain',
                                          endDate: 0
                                      };

                                      this.investmentClientOptimized.push(investmentDetails);

                                  }
                              }


                          //Client LifeStyles
                          this.lifestyleClient.forEach((x: any) => { // client

                              var obj = this.lifestylesOptimized.find((y: any) => y.id === x.lassetId);
                              var obj1: any = {};
                              var purchaseOfAssets: any = {};
                              var saleOfAssets: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  purchaseOfAssets = obj.purchaseOfAssetValues;
                                  saleOfAssets = obj.saleOfAssetValues;
                                  j = obj.increment;
                              }
                              if (p == 0) {
                                  obj["owner"] = x.owner;
                                  obj["name"] = x.name;

                                  obj["id"] = x.lassetId;
                                  obj["type"] = x.lassetType;

                                  if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                      x.startDate = this.clientDetails.startDate;
                                  }
                                  else if (x.startDateType == "Client Retirement") {
                                      x.startDate = this.clientDetails.clientRetirementYear - 1;
                                  }

                                  if (x.endDateType == "End") {
                                      x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }
                                  else if (x.endDateType == "Retain") {
                                      x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                                  }
                                  else if (x.endDateType == "Client Retirement") {
                                      x.endDate = this.clientDetails.clientRetirementYear - 1;
                                  }

                                  if ((this.clientDetails.startDate + i) >= x.endDate) {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                                  else if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (x.lassetType == "PrimaryResidence") {
                                          if (j == 0) {
                                              obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                          }
                                          else {
                                              obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                          }
                                          j++;
                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }

                                  //Purchase of assets
                                  if (x.startDateType != "Existing") {

                                      if (x.startDate == this.clientDetails.startDate + i) {
                                          purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else {
                                          purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }

                                  //Sale of assets
                                  if (x.endDateType != "Retain") {

                                      if (x.endDate == this.clientDetails.startDate + i) {
                                          if (x.lassetType == "PrimaryResidence") {
                                              if (j == 0) {
                                                  saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();

                                              }
                                              else {
                                                  saleOfAssets[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                              }
                                              j++;
                                          }
                                          else {
                                              saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                          }

                                      }
                                      else {
                                          saleOfAssets[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;
                              obj["purchaseOfAssetValues"] = purchaseOfAssets;
                              obj["saleOfAssetValues"] = saleOfAssets;


                              if (this.lifestylesOptimized.find((y: any) => y.id === x.lassetId) != null) {
                                  this.lifestylesOptimized[this.lifestylesOptimized.findIndex((c: any) => c.id === x.lassetId)] = obj;
                              }
                              else {
                                  this.lifestylesOptimized.push(obj);
                              }

                          })
                          this.lifestylePartner.forEach((x: any) => {

                              var obj = this.lifestylesOptimized.find((y: any) => y.id === x.lassetId);
                              var obj1: any = {};
                              var purchaseOfAssets: any = {};
                              var saleOfAssets: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  purchaseOfAssets = obj.purchaseOfAssetValues;
                                  saleOfAssets = obj.saleOfAssetValues;
                                  j = obj.increment;
                              }

                              if (p == 0) {
                                  obj["owner"] = x.owner;
                                  obj["name"] = x.name;

                                  obj["id"] = x.lassetId;
                                  obj["type"] = x.lassetType;

                                  if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                      x.startDate = this.clientDetails.startDate;
                                  }
                                  else if (x.startDateType == "Partner Retirement") {
                                      x.startDate = this.clientDetails.partnerRetirementYear - 1;
                                  }

                                  if (x.endDateType == "End") {
                                      x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }
                                  else if (x.endDateType == "Retain") {
                                      x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                                  }
                                  else if (x.endDateType == "Partner Retirement") {
                                      x.endDate = this.clientDetails.partnerRetirementYear - 1;
                                  }


                                  if ((this.clientDetails.startDate + i) >= x.endDate) {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                                  else if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (x.lassetType == "PrimaryResidence") {
                                          if (j == 0) {
                                              obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                          }
                                          else {
                                              obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                          }
                                          j++;
                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }

                                  //Purchase of assets
                                  if (x.startDateType != "Existing") {

                                      if (x.startDate == this.clientDetails.startDate + i) {
                                          purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else {
                                          purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }

                                  //Sale of assets
                                  if (x.endDateType != "Retain") {

                                      if (x.endDate == this.clientDetails.startDate + i) {
                                          if (x.lassetType == "PrimaryResidence") {
                                              if (j == 0) {
                                                  saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();

                                              }
                                              else {
                                                  saleOfAssets[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                              }
                                              j++;
                                          }
                                          else {
                                              saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                          }

                                      }
                                      else {
                                          saleOfAssets[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }

                              obj["values"] = obj1;
                              obj["increment"] = j;
                              obj["purchaseOfAssetValues"] = purchaseOfAssets;
                              obj["saleOfAssetValues"] = saleOfAssets;


                              if (this.lifestylesOptimized.find((y: any) => y.id === x.lassetId) != null) {
                                  this.lifestylesOptimized[this.lifestylesOptimized.findIndex((c: any) => c.id === x.lassetId)] = obj;
                              }
                              else {
                                  this.lifestylesOptimized.push(obj);
                              }

                          })
                          this.lifestyleJoint.forEach((x: any) => {

                              var obj = this.lifestylesOptimized.find((y: any) => y.id === x.lassetId);
                              var obj1: any = {};
                              var purchaseOfAssets: any = {};
                              var saleOfAssets: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  purchaseOfAssets = obj.purchaseOfAssetValues;
                                  saleOfAssets = obj.saleOfAssetValues;
                                  j = obj.increment;
                              }

                              if (p == 0) {
                                  obj["owner"] = x.owner;
                                  obj["name"] = x.name;

                                  obj["id"] = x.lassetId;
                                  obj["type"] = x.lassetType;

                                  if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                      x.startDate = this.clientDetails.startDate;
                                  }
                                  else if (x.startDateType == "Client Retirement") {
                                      x.startDate = this.clientDetails.clientRetirementYear - 1;
                                  }
                                  else if (x.startDateType == "Partner Retirement") {
                                      x.startDate = this.clientDetails.partnerRetirementYear - 1;
                                  }

                                  if (x.endDateType == "End") {
                                      x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }
                                  else if (x.endDateType == "Retain") {
                                      x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                                  }
                                  else if (x.endDateType == "Client Retirement") {
                                      x.endDate = this.clientDetails.clientRetirementYear - 1;
                                  }
                                  else if (x.endDateType == "Partner Retirement") {
                                      x.endDate = this.clientDetails.partnerRetirementYear - 1;
                                  }

                                  if ((this.clientDetails.startDate + i) >= x.endDate) {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                                  else if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (x.lassetType == "PrimaryResidence") {
                                          if (j == 0) {
                                              obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                          }
                                          else {
                                              obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                          }
                                          j++;
                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }

                                  //Purchase of assets
                                  if (x.startDateType != "Existing") {

                                      if (x.startDate == this.clientDetails.startDate + i) {
                                          purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else {
                                          purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }

                                  //Sale of assets
                                  if (x.endDateType != "Retain") {

                                      if (x.endDate == this.clientDetails.startDate + i) {
                                          if (x.lassetType == "PrimaryResidence") {
                                              if (j == 0) {
                                                  saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();

                                              }
                                              else {
                                                  saleOfAssets[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.growth / 100), j))).toFixed();
                                              }
                                              j++;
                                          }
                                          else {
                                              saleOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                          }

                                      }
                                      else {
                                          saleOfAssets[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;
                              obj["purchaseOfAssetValues"] = purchaseOfAssets;
                              obj["saleOfAssetValues"] = saleOfAssets;


                              if (this.lifestylesOptimized.find((y: any) => y.id === x.lassetId) != null) {
                                  this.lifestylesOptimized[this.lifestylesOptimized.findIndex((c: any) => c.id === x.lassetId)] = obj;
                              }
                              else {
                                  this.lifestylesOptimized.push(obj);
                              }

                          })
                          this.calculateTotalLASaleProceedsOptimized("TotalLASales", i);
                          this.calculateTotalLAPropertyExpensesOptimized("TotalLAPurchase", i);

                          this.cfiClient.forEach((x: any) => { // client
                              var obj = indexRangeInflowOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;
                              obj["type"] = x.type;
                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                             

                              if (p == 0) {
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                      }

                                      j++;

                                  }

                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                              }

                              obj["values"] = obj1;
                              obj["increment"] = j;

                              if (indexRangeInflowOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  indexRangeInflowOptimized[indexRangeInflowOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                                  clientEmploymentIncomeOptimized[clientEmploymentIncomeOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                                  this.IncomeOptimized[this.IncomeOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  indexRangeInflowOptimized.push(obj);
                                  this.IncomeOptimized.push(obj);
                                  clientEmploymentIncomeOptimized.push(obj);
                              }
                          });
                          this.cfiPartner.forEach((x: any) => { // partner
                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = indexRangeInflowOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }


                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;
                              obj["type"] = x.type;
                              if (p == 0) {
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;

                              if (indexRangeInflowOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  indexRangeInflowOptimized[indexRangeInflowOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                                  partnerEmploymentIncomeOptimized[partnerEmploymentIncomeOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                                  this.IncomeOptimized[this.IncomeOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  indexRangeInflowOptimized.push(obj);
                                  this.IncomeOptimized.push(obj);
                                  partnerEmploymentIncomeOptimized.push(obj);
                              }

                          })
                          this.cfiClient.forEach((x: any) => { // client

                              if (x.type != "Non-Taxable") {
                                  if (x.startDateType == "Start") {
                                      x.startDate = this.clientDetails.startDate
                                  }
                                  else if (x.startDateType == "Client Retirement") {
                                      x.startDate = this.clientDetails.clientRetirementYear - 1;
                                  }
                                  //TODO : Reconfirm end date
                                  if (x.endDateType == "End") {
                                      x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }
                                  else if (x.endDateType == "Client Retirement") {
                                      x.endDate = this.clientDetails.clientRetirementYear - 1;
                                  }


                                  var obj = indexRangeInflowOptimized.find((y: any) => y.id === "Tax" + x.cflowId);
                                  var obj1: any = {};
                                  var j: number = 0;
                                  if (obj == null) {
                                      obj = {};
                                      j = 0;
                                  }
                                  else {
                                      obj1 = obj.values;
                                      j = obj.increment;
                                  }
                                  obj["owner"] = "ClientIncome-tax";
                                  obj["name"] = x.cfname;
                                  obj["id"] = "Tax" + x.cflowId;

                                  if (p == 0) {
                                      if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                          if (j == 0) {
                                              obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                          }
                                          else {
                                              obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                          }
                                          j++;
                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                                  obj["values"] = obj1;
                                  obj["increment"] = j;

                                  if (indexRangeInflowOptimized.find((y: any) => y.id === "Tax" + x.cflowId) != null) {
                                      indexRangeInflowOptimized[indexRangeInflowOptimized.findIndex((c: any) => c.id === "Tax" + x.cflowId)] = obj;
                                      this.IncomeOptimized[this.IncomeOptimized.findIndex((c: any) => c.id === "Tax" + x.cflowId)] = obj;
                                  }
                                  else {
                                      indexRangeInflowOptimized.push(obj);
                                      this.IncomeOptimized.push(obj);
                                  }
                              }

                          })
                          this.cfiPartner.forEach((x: any) => { // partner
                              if (x.type != "Non-Taxable") {
                                  if (x.startDateType == "Start") {
                                      x.startDate = this.clientDetails.startDate
                                  }
                                  else if (x.startDateType == "Partner Retirement") {
                                      x.startDate = this.clientDetails.partnerRetirementYear - 1;
                                  }

                                  if (x.endDateType == "End") {
                                      x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }
                                  else if (x.endDateType == "Partner Retirement") {
                                      x.endDate = this.clientDetails.partnerRetirementYear - 1;
                                  }

                                  var obj = indexRangeInflowOptimized.find((y: any) => y.id === "Tax" + x.cflowId);
                                  var obj1: any = {};
                                  var j: number = 0;
                                  if (obj == null) {
                                      obj = {};
                                      j = 0;
                                  }
                                  else {
                                      obj1 = obj.values;
                                      j = obj.increment;
                                  }
                                  obj["owner"] = "PartnerIncome-tax";
                                  obj["name"] = x.cfname;
                                  obj["id"] = "Tax" + x.cflowId;


                                  if (p == 0) {
                                      if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                          if (j == 0) {
                                              obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                          }
                                          else {
                                              obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                          }
                                          j++;
                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                                  obj["values"] = obj1;
                                  obj["increment"] = j;


                                  if (indexRangeInflowOptimized.find((y: any) => y.id === "Tax" + x.cflowId) != null) {
                                      indexRangeInflowOptimized[indexRangeInflowOptimized.findIndex((c: any) => c.id === "Tax" + x.cflowId)] = obj;
                                      this.IncomeOptimized[this.IncomeOptimized.findIndex((c: any) => c.id === "Tax" + x.cflowId)] = obj;
                                  }
                                  else {
                                      indexRangeInflowOptimized.push(obj);
                                      this.IncomeOptimized.push(obj);
                                  }
                              }

                          })
                          this.inflowOptimized = indexRangeInflowOptimized;

                          //Calculate Outflow Values
                          this.cfeClient.forEach((x: any) => { // client

                              var obj = indexRangeOutflowOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;

                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }

                              if (p == 0) {
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;


                              if (indexRangeOutflowOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  indexRangeOutflowOptimized[indexRangeOutflowOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  indexRangeOutflowOptimized.push(obj);
                              }

                          })
                          this.cfePartner.forEach((x: any) => { // partner
                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }
                              var obj = indexRangeOutflowOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;

                              if (p == 0) {
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;


                              if (indexRangeOutflowOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  indexRangeOutflowOptimized[indexRangeOutflowOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  indexRangeOutflowOptimized.push(obj);
                              }


                          })
                          this.cfeJoint.forEach((x: any) => { // joint
                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }
                              
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }
                              var obj = indexRangeOutflowOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;

                              if (p == 0) {
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;

                              if (indexRangeOutflowOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  indexRangeOutflowOptimized[indexRangeOutflowOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  indexRangeOutflowOptimized.push(obj);
                              }

                          })
                          this.outflowOptimized = indexRangeOutflowOptimized;

                          //Calculate Client Investment
                              //TODO: verify investmentstrategy length on inititalizing
                          this.investmentClientOptimized.forEach((x: any) => {
                              var investmentStrategy: any = [];
                              if (p == 1) {
                                  investmentStrategy = strategyOrder.filter(c => c.id === x.investmentId).filter(c => c.status === "Existing");
                              }

                              this.investmentContribution = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "C");
                              this.investmentWithdrawal = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "W");


                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                             
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }

                          

                              var obj = this.BeginningValueOptimized.find((y: any) => y.owner === x.investmentId);
                              var begVal: any = {};
                              var growth: any = {};
                              var income: any = {};
                              var incomePaidOut: any = {};
                              var frankingCredits: any = {};
                              var earnings: any = {};
                              var purchaseOfAssets: any = {};
                              var regularContributions: any = {};
                              var contributions: any = {};
                              var saleOfAssets: any = {};
                              var regularWithdrawals: any = {};
                              var withdrawals: any = {};
                              var endingVal: any = {};
                              var endingValPV: any = {};
                              var realCG: any = {};
                              var unrealCG: any = {};
                              var cashFlow: any = {};

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  obj.values;
                                  begVal = obj.BegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  incomePaidOut = obj.incomePaidOutValues;
                                  frankingCredits = obj.frankingCreditsValues;
                                  earnings = obj.earningsValues;
                                  purchaseOfAssets = obj.purchaseOfAssetValues;
                                  regularContributions = obj.regularContributionsValues;
                                  contributions = obj.contributionsValues;
                                  saleOfAssets = obj.saleOfAssetValues;
                                  regularWithdrawals = obj.regularWithdrawalsValues;
                                  withdrawals = obj.withdrawalsValues;
                                  endingVal = obj.endingValues;
                                  endingValPV = obj.endingValuesPV;
                                  realCG = obj.realCGValues;
                                  unrealCG = obj.unrealCGValues;
                                  cashFlow = obj.cashFlowValues;
                              }



                              obj["owner"] = x.investmentId;
                              obj["type"] = "Client";
                              obj["name"] = "Opening Value";

                              //BeginningValue
                              if (n == 1) {
                                  if (x.startDateType == "Existing") {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  var t: number = 0;
                                  var cashflow = this.netCashFlowOptimized.find((y: any) => y.owner === "NetCashflow");
                                  if (cashflow.values[(this.clientDetails.startDate + i) -  1] > 0) {
                                      t += cashflow.values[(this.clientDetails.startDate + i) - 1];
                                  }

                                  if (x.type == "Domestic Cash") {
                                      if ((this.clientDetails.startDate + i) == x.startDate) {
                                          begVal[this.clientDetails.startDate + i] = (x.value + t).toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.startDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = Number(endingVal[Number(this.clientDetails.startDate + i) - 1]) + t;
                                      }
                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.startDate) {
                                          begVal[this.clientDetails.startDate + i] = (x.value).toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.startDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = Number(endingVal[Number(this.clientDetails.startDate + i) - 1]);
                                      }
                                  }
                              }



                              cashFlow[(this.clientDetails.startDate + i)] = 0;


                              //growth & income
                              var growthUnAdj = (x.growth / 100) * (Number(begVal[this.clientDetails.startDate + i]));
                              var incomeUnAdj = (x.income / 100) * (Number(begVal[this.clientDetails.startDate + i]));

                              var ICR = (x.productFees / 100) * (Number(begVal[this.clientDetails.startDate + i]));


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }


                              //incomePaidOut

                              if (x.reinvest == "N") {
                                  incomePaidOut[this.clientDetails.startDate + i] = income[this.clientDetails.startDate + i];

                              }
                              else {
                                  incomePaidOut[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //Earnings
                              earnings[this.clientDetails.startDate + i] = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])).toFixed();

                              if (p == 0) {
                                  regularContributions[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  if ((investmentStrategy.length > 0) && (investmentStrategy[0].AllocatedValue > 0) && (investmentStrategy[0].AllocatedValue > (begVal[this.clientDetails.startDate + i] + income[this.clientDetails.startDate + i] + growth[this.clientDetails.startDate + i] - incomePaidOut[this.clientDetails.startDate + i]))) {
                                      regularContributions[this.clientDetails.startDate + i] = Number(investmentStrategy[0].AllocatedValue) - Number(begVal[this.clientDetails.startDate + i] + income[this.clientDetails.startDate + i] + growth[this.clientDetails.startDate + i] -  incomePaidOut[this.clientDetails.startDate + i]);
                                  }
                                  else {
                                      //List of Contributions
                                      let ContributionSum: number = 0;
                                      this.investmentContribution.forEach((y: any) => { // client

                                          if (y.fromDateType == "Start") {
                                              y.fromDate = this.clientDetails.startDate;
                                          }
                                          if (y.toDateType == "End") {
                                              y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                          }

                                          if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                              var t = parseInt(y.value);
                                              ContributionSum = ContributionSum + t;
                                          }

                                      });

                                      regularContributions[this.clientDetails.startDate + i] = ContributionSum;
                                  }
                              }


                              //Purchase of assets
                              if (x.startDateType != "Existing") {

                                  if (x.startDate == this.clientDetails.startDate + i) {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Contributions
                              contributions[this.clientDetails.startDate + i] = regularContributions[this.clientDetails.startDate + i] + Number(purchaseOfAssets[this.clientDetails.startDate + i]);


                              if (p == 0) {
                                  regularWithdrawals[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  if ((investmentStrategy.length > 0) && (investmentStrategy[0].AllocatedValue < (Number(begVal[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])))) {
                                      regularWithdrawals[this.clientDetails.startDate + i] =( Number(begVal[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])) - Number(investmentStrategy[0].AllocatedValue);
                                  }
                                  else {
                                      //List of Withdrawals
                                      //TODO: only if main date started
                                      let WithdrawalSum: number = 0;
                                      this.investmentWithdrawal.forEach((y: any) => { // client

                                          if (y.fromDateType == "Start") {
                                              y.fromDate = this.clientDetails.startDate;
                                          }
                                          if (y.toDateType == "End") {
                                              y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                          }

                                          if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                              var t = parseInt(y.value);
                                              WithdrawalSum = WithdrawalSum + t;
                                          }

                                      });

                                      regularWithdrawals[this.clientDetails.startDate + i] = WithdrawalSum;
                                  }
                              }

                              //Sale of assets
                              if (x.endDateType != "Retain") {

                                  if (x.endDate == this.clientDetails.startDate + i) {
                                      saleOfAssets[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(regularWithdrawals[this.clientDetails.startDate + i]);
                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Withdrawals
                              withdrawals[this.clientDetails.startDate + i] = Number(regularWithdrawals[this.clientDetails.startDate + i]) + Number(saleOfAssets[this.clientDetails.startDate + i]);


                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(cashFlow[(this.clientDetails.startDate + i)]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(withdrawals[this.clientDetails.startDate + i])).toFixed();

                              //Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();


                              if (x.type == "Domestic Cash" || x.type == "Domestic Fixed Interest") {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  if ((begVal[this.clientDetails.startDate + i]) != 0) {
                                      //Real and Unreal CG
                                      var TotalCG = 0;
                                      var RateCG = 0


                                      if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                          TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(growth[this.clientDetails.startDate + i])));
                                      }
                                      else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                          TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(growth[this.clientDetails.startDate + i]);
                                      }

                                      if (endingVal[this.clientDetails.startDate + i] == 0) {
                                          realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                      }
                                      else {
                                          if (Number(withdrawals[this.clientDetails.startDate + i]) != 0) {
                                              realCG[this.clientDetails.startDate + i] = ((Number(withdrawals[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                          }
                                          else {
                                              realCG[this.clientDetails.startDate + i] = 0;
                                          }
                                      }

                                      unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                                  }
                                  else {
                                      realCG[this.clientDetails.startDate + i] = 0;
                                      unrealCG[this.clientDetails.startDate + i] = 0;
                                  }
                              }


                              obj["BegValues"] = begVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["incomePaidOutValues"] = incomePaidOut;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["earningsValues"] = earnings;
                              obj["purchaseOfAssetValues"] = purchaseOfAssets;
                              obj["regularContributionsValues"] = regularContributions;
                              obj["contributionsValues"] = contributions;
                              obj["saleOfAssetValues"] = saleOfAssets;
                              obj["regularWithdrawalsValues"] = regularWithdrawals;
                              obj["withdrawalsValues"] = withdrawals;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["realCGValues"] = realCG;
                              obj["unrealCGValues"] = unrealCG;
                              obj["cashFlowValues"] = cashFlow;


                              if (this.BeginningValueOptimized.find((y: any) => y.owner === x.investmentId) != null) {
                                  this.BeginningValueOptimized[this.BeginningValueOptimized.findIndex((c: any) => c.owner === x.investmentId)] = obj;
                              }
                              else {
                                  this.BeginningValueOptimized.push(obj);
                              }
                          })

                          //Calculate Partner Investment
                          this.investmentPartner.forEach((x: any) => { // client

                              this.investmentContribution = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "C");
                              this.investmentWithdrawal = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "W");


                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.BeginningValueOptimized.find((y: any) => y.owner === x.investmentId);
                              var begVal: any = {};
                              var growth: any = {};
                              var income: any = {};
                              var incomePaidOut: any = {};
                              var frankingCredits: any = {};
                              var earnings: any = {};
                              var purchaseOfAssets: any = {};
                              var regularContributions: any = {};
                              var contributions: any = {};
                              var saleOfAssets: any = {};
                              var regularWithdrawals: any = {};
                              var withdrawals: any = {};
                              var endingVal: any = {};
                              var endingValPV: any = {};
                              var realCG: any = {};
                              var unrealCG: any = {};
                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  obj.values;
                                  begVal = obj.BegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  incomePaidOut = obj.incomePaidOutValues;
                                  frankingCredits = obj.frankingCreditsValues;
                                  earnings = obj.earningsValues;
                                  purchaseOfAssets = obj.purchaseOfAssetValues;
                                  regularContributions = obj.regularContributionsValues;
                                  contributions = obj.contributionsValues;
                                  saleOfAssets = obj.saleOfAssetValues;
                                  regularWithdrawals = obj.regularWithdrawalsValues;
                                  withdrawals = obj.withdrawalsValues;
                                  endingVal = obj.endingValues;
                                  endingValPV = obj.endingValuesPV;
                                  realCG = obj.realCGValues;
                                  unrealCG = obj.unrealCGValues;
                              }

                              obj["owner"] = x.investmentId;
                              obj["type"] = "Partner";
                              obj["name"] = "Opening Value";

                              //BeginningValue
                              if (n == 1) {
                                  if (x.startDateType == "Existing") {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  if ((this.clientDetails.startDate + i) == x.startDate) {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.startDate) {

                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                                  }
                              }

                              //growth & income
                              var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                              var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                              var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }


                              //incomePaidOut

                              if (x.reinvest == "N") {
                                  incomePaidOut[this.clientDetails.startDate + i] = income[this.clientDetails.startDate + i];

                              }
                              else {
                                  incomePaidOut[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //Earnings
                              earnings[this.clientDetails.startDate + i] = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])).toFixed();

                              //List of Contributions
                              let ContributionSum: number = 0;
                              this.investmentContribution.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      var t = parseInt(y.value);
                                      ContributionSum = ContributionSum + t;
                                  }

                              });

                              regularContributions[this.clientDetails.startDate + i] = ContributionSum;



                              //Purchase of assets
                              if (x.startDateType != "Existing") {

                                  if (x.startDate == this.clientDetails.startDate + i) {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Contributions
                              contributions[this.clientDetails.startDate + i] = regularContributions[this.clientDetails.startDate + i] + Number(purchaseOfAssets[this.clientDetails.startDate + i]);

                              //List of Withdrawals
                              let WithdrawalSum: number = 0;
                              this.investmentWithdrawal.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      var t = parseInt(y.value);
                                      WithdrawalSum = WithdrawalSum + t;
                                  }

                              });

                              regularWithdrawals[this.clientDetails.startDate + i] = WithdrawalSum;

                              //Sale of assets
                              if (x.endDateType != "Retain") {

                                  if (x.endDate == this.clientDetails.startDate + i) {
                                      saleOfAssets[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(regularWithdrawals[this.clientDetails.startDate + i]);
                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Withdrawals
                              withdrawals[this.clientDetails.startDate + i] = Number(regularWithdrawals[this.clientDetails.startDate + i]) + Number(saleOfAssets[this.clientDetails.startDate + i]);

                              //Ending Value
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(withdrawals[this.clientDetails.startDate + i])).toFixed();

                              //Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              if (x.type == "Domestic Cash" || x.type == "Domestic Fixed Interest") {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  if (begVal[this.clientDetails.startDate + i] != 0) {
                                      //Real and Unreal CG
                                      var TotalCG = 0;
                                      var RateCG = 0


                                      if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                          TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(growth[this.clientDetails.startDate + i])));
                                      }
                                      else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                          TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(growth[this.clientDetails.startDate + i]);
                                      }

                                      if (endingVal[this.clientDetails.startDate + i] == 0) {
                                          realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                      }
                                      else {
                                          if (Number(withdrawals[this.clientDetails.startDate + i]) != 0) {
                                              realCG[this.clientDetails.startDate + i] = ((Number(withdrawals[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                          }
                                          else {
                                              realCG[this.clientDetails.startDate + i] = 0;
                                          }
                                      }

                                      unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                                  }
                                  else {
                                      realCG[this.clientDetails.startDate + i] = 0;
                                      unrealCG[this.clientDetails.startDate + i] = 0;
                                  }
                              }


                              obj["BegValues"] = begVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["incomePaidOutValues"] = incomePaidOut;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["earningsValues"] = earnings;
                              obj["purchaseOfAssetValues"] = purchaseOfAssets;
                              obj["regularContributionsValues"] = regularContributions;
                              obj["contributionsValues"] = contributions;
                              obj["saleOfAssetValues"] = saleOfAssets;
                              obj["regularWithdrawalsValues"] = regularWithdrawals;
                              obj["withdrawalsValues"] = withdrawals;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["realCGValues"] = realCG;
                              obj["unrealCGValues"] = unrealCG;


                              if (this.BeginningValueOptimized.find((y: any) => y.owner === x.investmentId) != null) {
                                  this.BeginningValueOptimized[this.BeginningValueOptimized.findIndex((c: any) => c.owner === x.investmentId)] = obj;
                              }
                              else {
                                  this.BeginningValueOptimized.push(obj);
                              }

                          })
                          //Calculate Joint Investment
                          this.investmentJoint.forEach((x: any) => { // client

                              this.investmentContribution = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "C");
                              this.investmentWithdrawal = this.investmentCW.filter((c: any) => c.investmentId === x.investmentId).filter((r: any) => r.type === "W");


                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.BeginningValueOptimized.find((y: any) => y.owner === x.investmentId);
                              var begVal: any = {};
                              var growth: any = {};
                              var income: any = {};
                              var incomePaidOut: any = {};
                              var frankingCredits: any = {};
                              var earnings: any = {};
                              var purchaseOfAssets: any = {};
                              var regularContributions: any = {};
                              var contributions: any = {};
                              var saleOfAssets: any = {};
                              var regularWithdrawals: any = {};
                              var withdrawals: any = {};
                              var endingVal: any = {};
                              var endingValPV: any = {};
                              var realCG: any = {};
                              var unrealCG: any = {};
                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  obj.values;
                                  begVal = obj.BegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  incomePaidOut = obj.incomePaidOutValues;
                                  frankingCredits = obj.frankingCreditsValues;
                                  earnings = obj.earningsValues;
                                  purchaseOfAssets = obj.purchaseOfAssetValues;
                                  regularContributions = obj.regularContributionsValues;
                                  contributions = obj.contributionsValues;
                                  saleOfAssets = obj.saleOfAssetValues;
                                  regularWithdrawals = obj.regularWithdrawalsValues;
                                  withdrawals = obj.withdrawalsValues;
                                  endingVal = obj.endingValues;
                                  endingValPV = obj.endingValuesPV;
                                  realCG = obj.realCGValues;
                                  unrealCG = obj.unrealCGValues;
                              }

                              obj["owner"] = x.investmentId;
                              obj["type"] = "Joint";
                              obj["name"] = "Opening Value";

                              //BeginningValue
                              if (n == 1) {
                                  if (x.startDateType == "Existing") {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  if ((this.clientDetails.startDate + i) == x.startDate) {
                                      begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.startDate) {

                                      begVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {
                                      begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                                  }
                              }

                              //growth & income
                              var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                              var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                              var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }


                              //incomePaidOut

                              if (x.reinvest == "N") {
                                  incomePaidOut[this.clientDetails.startDate + i] = income[this.clientDetails.startDate + i];

                              }
                              else {
                                  incomePaidOut[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //Earnings
                              earnings[this.clientDetails.startDate + i] = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(incomePaidOut[this.clientDetails.startDate + i])).toFixed();

                              //List of Contributions
                              let ContributionSum: number = 0;
                              this.investmentContribution.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      var t = parseInt(y.value);
                                      ContributionSum = ContributionSum + t;
                                  }

                              });

                              regularContributions[this.clientDetails.startDate + i] = ContributionSum;



                              //Purchase of assets
                              if (x.startDateType != "Existing") {

                                  if (x.startDate == this.clientDetails.startDate + i) {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = x.value.toFixed();
                                  }
                                  else {
                                      purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  purchaseOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Contributions
                              contributions[this.clientDetails.startDate + i] = regularContributions[this.clientDetails.startDate + i] + Number(purchaseOfAssets[this.clientDetails.startDate + i]);

                              //List of Withdrawals
                              let WithdrawalSum: number = 0;
                              this.investmentWithdrawal.forEach((y: any) => { // client

                                  if (y.fromDateType == "Start") {
                                      y.fromDate = this.clientDetails.startDate;
                                  }
                                  if (y.toDateType == "End") {
                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                  }

                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                      var t = parseInt(y.value);
                                      WithdrawalSum = WithdrawalSum + t;
                                  }

                              });

                              regularWithdrawals[this.clientDetails.startDate + i] = WithdrawalSum;

                              //Sale of assets
                              if (x.endDateType != "Retain") {

                                  if (x.endDate == this.clientDetails.startDate + i) {
                                      saleOfAssets[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(regularWithdrawals[this.clientDetails.startDate + i]);
                                  }
                                  else {
                                      saleOfAssets[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              else {
                                  saleOfAssets[this.clientDetails.startDate + i] = 0;
                              }

                              //Withdrawals
                              withdrawals[this.clientDetails.startDate + i] = Number(regularWithdrawals[this.clientDetails.startDate + i]) + Number(saleOfAssets[this.clientDetails.startDate + i]);

                              //Ending Value
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(earnings[this.clientDetails.startDate + i]) + Number(contributions[this.clientDetails.startDate + i]) - Number(withdrawals[this.clientDetails.startDate + i])).toFixed();

                              //Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = inflation[0].percentage;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              if (x.type == "Domestic Cash" || x.type == "Domestic Fixed Interest") {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  if (begVal[this.clientDetails.startDate + i] != 0) {
                                      //Real and Unreal CG
                                      var TotalCG = 0;
                                      var RateCG = 0


                                      if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                          TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(growth[this.clientDetails.startDate + i])));
                                      }
                                      else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                          TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(growth[this.clientDetails.startDate + i]);
                                      }

                                      if (endingVal[this.clientDetails.startDate + i] == 0) {
                                          realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                      }
                                      else {
                                          if (Number(withdrawals[this.clientDetails.startDate + i]) != 0) {
                                              realCG[this.clientDetails.startDate + i] = ((Number(withdrawals[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                          }
                                          else {
                                              realCG[this.clientDetails.startDate + i] = 0;
                                          }
                                      }

                                      unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                                  }
                                  else {
                                      realCG[this.clientDetails.startDate + i] = 0;
                                      unrealCG[this.clientDetails.startDate + i] = 0;
                                  }
                              }

                              obj["BegValues"] = begVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["incomePaidOutValues"] = incomePaidOut;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["earningsValues"] = earnings;
                              obj["purchaseOfAssetValues"] = purchaseOfAssets;
                              obj["regularContributionsValues"] = regularContributions;
                              obj["contributionsValues"] = contributions;
                              obj["saleOfAssetValues"] = saleOfAssets;
                              obj["regularWithdrawalsValues"] = regularWithdrawals;
                              obj["withdrawalsValues"] = withdrawals;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["realCGValues"] = realCG;
                              obj["unrealCGValues"] = unrealCG;

                              if (this.BeginningValueOptimized.find((y: any) => y.owner === x.investmentId) != null) {
                                  this.BeginningValueOptimized[this.BeginningValueOptimized.findIndex((c: any) => c.owner === x.investmentId)] = obj;
                              }
                              else {
                                  this.BeginningValueOptimized.push(obj);
                              }

                          })

                          //Calculate Financial Assets Totals
                          this.calculateTotalInvestmentPaidOutOptimized("TotalIPO", i);
                          this.calculateTotalInvestmentWithdrawalsOptimized("TotalIW", i);
                          this.calculateTotalInvestmentContributionsOptimized("TotalIC", i);
                          this.calculateTotalInvestmentEarningsOptimized("TotalTaxIE-client", "Client", i);
                          this.calculateTotalInvestmentEarningsOptimized("TotalTaxIE-partner", "Partner", i);
                          this.calculateRealizedCGFAOptimized("RCGFA-client", "Client", i);
                          this.calculateRealizedCGFAOptimized("RCGFA-partner", "Partner", i);
                          this.calculateFrankingCreditsOptimized("FrankingCredits-client", "Client", i);
                          this.calculateFrankingCreditsOptimized("FrankingCredits-partner", "Partner", i);


                          //Calculate Client Properties
                          this.propertiesClient.forEach((x: any) => { // client

                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate;
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }


                              var obj = this.PropertiesValueOptimized.find((y: any) => y.owner === x.propertyId);
                              var begVal: any = {};
                              var propertyPurchase: any = {};
                              var propertySale: any = {};
                              var capitalGrowth: any = {};
                              var endingVal: any = {};
                              var endingValPV: any = {};
                              var rent: any = {};
                              var expenses: any = {};
                              var realCG: any = {};
                              var unrealCG: any = {};
                              var propPurchase: number = 0;
                              var propSale: number = 0;

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  begVal = obj.BegValues;
                                  propertyPurchase = obj.PropertyPurchaseValues;
                                  propertySale = obj.PropertySaleValues;
                                  capitalGrowth = obj.capitalGrowthValues;
                                  endingVal = obj.endingValues;
                                  endingValPV = obj.endingValuesPV;
                                  rent = obj.rentValues;
                                  expenses = obj.expensesValues;
                                  realCG = obj.realCGValues;
                                  unrealCG = obj.unrealCGValues;
                              }


                              obj["owner"] = x.propertyId;
                              obj["type"] = "Client";
                              obj["name"] = x.name;
                              obj["startDateType"] = x.startDateType;

                              //BeginningValue
                              if (n == 1 && x.startDateType == "Existing") {
                                  begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else if ((this.clientDetails.startDate + i) <= x.startDate) {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                              }

                              //capital growth
                              capitalGrowth[this.clientDetails.startDate + i] = ((x.growth / 100) * Number(begVal[this.clientDetails.startDate + i])).toFixed();

                              ////Ending Value


                              if ((this.clientDetails.startDate + i) == x.startDate) {
                                  endingVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  propertyPurchase[this.clientDetails.startDate + i] = x.value.toFixed();
                                  propPurchase = this.clientDetails.startDate + i;
                                  propertySale[this.clientDetails.startDate + i] = 0;

                              }
                              else if ((this.clientDetails.startDate + i) < x.startDate) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                                  propertyPurchase[this.clientDetails.startDate + i] = 0;


                              }


                              if ((this.clientDetails.startDate + i) == x.endDate) {
                                  propertySale[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();
                                  endingVal[this.clientDetails.startDate + i] = 0;
                              }
                              else if ((this.clientDetails.startDate + i) > x.startDate && (this.clientDetails.startDate + i) < x.endDate) {
                                  propSale = this.clientDetails.startDate + i;
                                  propertySale[this.clientDetails.startDate + i] = 0;
                                  endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();

                              }
                              else if ((this.clientDetails.startDate + i) > x.endDate) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                                  propertyPurchase[this.clientDetails.startDate + i] = 0;
                                  propertySale[this.clientDetails.startDate + i] = 0;
                              }




                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              //rent
                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  rent[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  let rentVal: number = 0;

                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      rentVal = parseInt(x.rent);
                                  }

                                  rent[this.clientDetails.startDate + i] = rentVal;
                              }


                              //expenses
                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  expenses[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  let expensesVal: number = 0;
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      expensesVal = parseInt(x.expenses);
                                  }
                                  expenses[this.clientDetails.startDate + i] = expensesVal;
                              }

                              if (begVal[this.clientDetails.startDate + i] != 0) {
                                  //Real and Unreal CG
                                  var TotalCG = 0;
                                  var RateCG = 0


                                  if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                      TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(capitalGrowth[this.clientDetails.startDate + i])));
                                  }
                                  else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                      TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(capitalGrowth[this.clientDetails.startDate + i]);
                                  }

                                  if (endingVal[this.clientDetails.startDate + i] == 0) {
                                      realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                  }
                                  else {
                                      if (Number(propertySale[this.clientDetails.startDate + i]) != 0) {
                                          realCG[this.clientDetails.startDate + i] = ((Number(propertySale[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                      }
                                      else {
                                          realCG[this.clientDetails.startDate + i] = 0;
                                      }
                                  }

                                  unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                              }
                              else {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }


                              obj["BegValues"] = begVal;
                              obj["PropertyPurchaseValues"] = propertyPurchase;
                              obj["PropertySaleValues"] = propertySale;
                              obj["capitalGrowthValues"] = capitalGrowth;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["rentValues"] = rent;
                              obj["expensesValues"] = expenses;
                              obj["realCGValues"] = realCG;
                              obj["unrealCGValues"] = unrealCG;
                              obj["propPurchase"] = propPurchase;

                              if (this.PropertiesValueOptimized.find((y: any) => y.owner === x.propertyId) != null) {
                                  this.PropertiesValueOptimized[this.PropertiesValueOptimized.findIndex((c: any) => c.owner === x.propertyId)] = obj;
                              }
                              else {
                                  this.PropertiesValueOptimized.push(obj);
                              }

                          })
                          //Calculate Partner Properties
                          this.propertiesPartner.forEach((x: any) => { // client

                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }
                              //TODO : Confirm retain end date value
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }
                              var obj = this.PropertiesValueOptimized.find((y: any) => y.owner === x.propertyId);
                              var begVal: any = {};
                              var propertyPurchase: any = {};
                              var propertySale: any = {};
                              var capitalGrowth: any = {};
                              var endingVal: any = {};
                              var endingValPV: any = {};
                              var rent: any = {};
                              var expenses: any = {};
                              var realCG: any = {};
                              var unrealCG: any = {};
                              var propPurchase: number = 0;
                              var propSale: number = 0;

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  begVal = obj.BegValues;
                                  propertyPurchase = obj.PropertyPurchaseValues;
                                  propertySale = obj.PropertySaleValues;
                                  capitalGrowth = obj.capitalGrowthValues;
                                  endingVal = obj.endingValues;
                                  endingValPV = obj.endingValuesPV;
                                  rent = obj.rentValues;
                                  expenses = obj.expensesValues;
                                  realCG = obj.realCGValues;
                                  unrealCG = obj.unrealCGValues;
                              }

                              obj["owner"] = x.propertyId;
                              obj["type"] = "Partner";
                              obj["name"] = x.name;
                              obj["startDateType"] = x.startDateType;

                              //BeginningValue
                              if (n == 1 && x.startDateType == "Existing") {
                                  begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else if ((this.clientDetails.startDate + i) <= x.startDate) {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                              }

                              //capital growth
                              capitalGrowth[this.clientDetails.startDate + i] = ((x.growth / 100) * Number(begVal[this.clientDetails.startDate + i])).toFixed();

                              ////Ending Value


                              if ((this.clientDetails.startDate + i) == x.startDate) {
                                  endingVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  propertyPurchase[this.clientDetails.startDate + i] = x.value.toFixed();
                                  propPurchase = this.clientDetails.startDate + i;
                                  propertySale[this.clientDetails.startDate + i] = 0;

                              }
                              else if ((this.clientDetails.startDate + i) < x.startDate) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                                  propertyPurchase[this.clientDetails.startDate + i] = 0;


                              }


                              if ((this.clientDetails.startDate + i) == x.endDate) {
                                  propertySale[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();
                                  endingVal[this.clientDetails.startDate + i] = 0;
                              }
                              else if ((this.clientDetails.startDate + i) > x.startDate && (this.clientDetails.startDate + i) < x.endDate) {
                                  propSale = this.clientDetails.startDate + i;
                                  propertySale[this.clientDetails.startDate + i] = 0;
                                  endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();

                              }
                              else if ((this.clientDetails.startDate + i) > x.endDate) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                                  propertyPurchase[this.clientDetails.startDate + i] = 0;
                                  propertySale[this.clientDetails.startDate + i] = 0;
                              }




                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              //rent
                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  rent[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  let rentVal: number = 0;

                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      rentVal = parseInt(x.rent);
                                  }

                                  rent[this.clientDetails.startDate + i] = rentVal;
                              }


                              //expenses
                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  expenses[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  let expensesVal: number = 0;
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      expensesVal = parseInt(x.expenses);
                                  }
                                  expenses[this.clientDetails.startDate + i] = expensesVal;
                              }

                              if (begVal[this.clientDetails.startDate + i] != 0) {
                                  //Real and Unreal CG
                                  var TotalCG = 0;
                                  var RateCG = 0


                                  if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                      TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(capitalGrowth[this.clientDetails.startDate + i])));
                                  }
                                  else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                      TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(capitalGrowth[this.clientDetails.startDate + i]);
                                  }

                                  if (endingVal[this.clientDetails.startDate + i] == 0) {
                                      realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                  }
                                  else {
                                      if (Number(propertySale[this.clientDetails.startDate + i]) != 0) {
                                          realCG[this.clientDetails.startDate + i] = ((Number(propertySale[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                      }
                                      else {
                                          realCG[this.clientDetails.startDate + i] = 0;
                                      }
                                  }

                                  unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                              }
                              else {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }


                              obj["BegValues"] = begVal;
                              obj["PropertyPurchaseValues"] = propertyPurchase;
                              obj["PropertySaleValues"] = propertySale;
                              obj["capitalGrowthValues"] = capitalGrowth;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["rentValues"] = rent;
                              obj["expensesValues"] = expenses;
                              obj["realCGValues"] = realCG;
                              obj["unrealCGValues"] = unrealCG;
                              obj["propPurchase"] = propPurchase;

                              if (this.PropertiesValueOptimized.find((y: any) => y.owner === x.propertyId) != null) {
                                  this.PropertiesValueOptimized[this.PropertiesValueOptimized.findIndex((c: any) => c.owner === x.propertyId)] = obj;
                              }
                              else {
                                  this.PropertiesValueOptimized.push(obj);
                              }
                          })
                          //Calculate Joint Properties
                          this.propertiesJoint.forEach((x: any) => { // client

                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate;
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              //TODO : Confirm retain end date value
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.PropertiesValueOptimized.find((y: any) => y.owner === x.propertyId);
                              var begVal: any = {};
                              var propertyPurchase: any = {};
                              var propertySale: any = {};
                              var capitalGrowth: any = {};
                              var endingVal: any = {};
                              var endingValPV: any = {};
                              var rent: any = {};
                              var expenses: any = {};
                              var realCG: any = {};
                              var unrealCG: any = {};
                              var propPurchase: number = 0;
                              var propSale: number = 0;

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  begVal = obj.BegValues;
                                  propertyPurchase = obj.PropertyPurchaseValues;
                                  propertySale = obj.PropertySaleValues;
                                  capitalGrowth = obj.capitalGrowthValues;
                                  endingVal = obj.endingValues;
                                  endingValPV = obj.endingValuesPV;
                                  rent = obj.rentValues;
                                  expenses = obj.expensesValues;
                                  realCG = obj.realCGValues;
                                  unrealCG = obj.unrealCGValues;
                              }

                              obj["owner"] = x.propertyId;
                              obj["type"] = "Joint";
                              obj["name"] = x.name;
                              obj["startDateType"] = x.startDateType;

                              //BeginningValue
                              if (n == 1 && x.startDateType == "Existing") {
                                  begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                              }
                              else if ((this.clientDetails.startDate + i) <= x.startDate) {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                              }

                              //capital growth
                              capitalGrowth[this.clientDetails.startDate + i] = ((x.growth / 100) * Number(begVal[this.clientDetails.startDate + i])).toFixed();

                              ////Ending Value


                              if ((this.clientDetails.startDate + i) == x.startDate) {
                                  endingVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                  propertyPurchase[this.clientDetails.startDate + i] = x.value.toFixed();
                                  propPurchase = this.clientDetails.startDate + i;
                                  propertySale[this.clientDetails.startDate + i] = 0;

                              }
                              else if ((this.clientDetails.startDate + i) < x.startDate) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                                  propertyPurchase[this.clientDetails.startDate + i] = 0;


                              }


                              if ((this.clientDetails.startDate + i) == x.endDate) {
                                  propertySale[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();
                                  endingVal[this.clientDetails.startDate + i] = 0;
                              }
                              else if ((this.clientDetails.startDate + i) > x.startDate && (this.clientDetails.startDate + i) < x.endDate) {
                                  propSale = this.clientDetails.startDate + i;
                                  propertySale[this.clientDetails.startDate + i] = 0;
                                  endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(capitalGrowth[this.clientDetails.startDate + i])).toFixed();

                              }
                              else if ((this.clientDetails.startDate + i) > x.endDate) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                                  propertyPurchase[this.clientDetails.startDate + i] = 0;
                                  propertySale[this.clientDetails.startDate + i] = 0;
                              }




                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              //rent
                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  rent[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  let rentVal: number = 0;

                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      rentVal = parseInt(x.rent);
                                  }

                                  rent[this.clientDetails.startDate + i] = rentVal;
                              }


                              //expenses
                              if ((this.clientDetails.startDate + i) >= x.endDate) {
                                  expenses[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  let expensesVal: number = 0;
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      expensesVal = parseInt(x.expenses);
                                  }
                                  expenses[this.clientDetails.startDate + i] = expensesVal;
                              }

                              if (begVal[this.clientDetails.startDate + i] != 0) {
                                  //Real and Unreal CG
                                  var TotalCG = 0;
                                  var RateCG = 0


                                  if (Number(this.clientDetails.startDate + i) == x.startDate) {
                                      TotalCG = Math.max(0, (Number(x.value) - x.costBase + Number(capitalGrowth[this.clientDetails.startDate + i])));
                                  }
                                  else if (Number(this.clientDetails.startDate + i) > x.startDate) {
                                      TotalCG = Number(unrealCG[Number(this.clientDetails.startDate + i) - 1]) + Number(capitalGrowth[this.clientDetails.startDate + i]);
                                  }

                                  if (endingVal[this.clientDetails.startDate + i] == 0) {
                                      realCG[this.clientDetails.startDate + i] = TotalCG.toFixed();
                                  }
                                  else {
                                      if (Number(propertySale[this.clientDetails.startDate + i]) != 0) {
                                          realCG[this.clientDetails.startDate + i] = ((Number(propertySale[this.clientDetails.startDate + i]) / Number(endingVal[this.clientDetails.startDate + i])) * Number(TotalCG)).toFixed();
                                      }
                                      else {
                                          realCG[this.clientDetails.startDate + i] = 0;
                                      }
                                  }

                                  unrealCG[this.clientDetails.startDate + i] = (Number(TotalCG) - Number(realCG[this.clientDetails.startDate + i])).toFixed();

                              }
                              else {
                                  realCG[this.clientDetails.startDate + i] = 0;
                                  unrealCG[this.clientDetails.startDate + i] = 0;
                              }


                              obj["BegValues"] = begVal;
                              obj["PropertyPurchaseValues"] = propertyPurchase;
                              obj["PropertySaleValues"] = propertySale;
                              obj["capitalGrowthValues"] = capitalGrowth;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["rentValues"] = rent;
                              obj["expensesValues"] = expenses;
                              obj["realCGValues"] = realCG;
                              obj["unrealCGValues"] = unrealCG;
                              obj["propPurchase"] = propPurchase;

                              if (this.PropertiesValueOptimized.find((y: any) => y.owner === x.propertyId) != null) {
                                  this.PropertiesValueOptimized[this.PropertiesValueOptimized.findIndex((c: any) => c.owner === x.propertyId)] = obj;
                              }
                              else {
                                  this.PropertiesValueOptimized.push(obj);
                              }

                          })

                          //Calculate PropertyTotal
                          this.calculateTotalRentOptimized("TotalRent", i);
                          this.calculateTotalSaleProceedsOptimized("TotalSaleProceeds", i);
                          this.calculateTotalPropertyExpensesOptimized("TotalPropertyExpenses", i);
                          this.calculateInvestmentPropertyExpensesOptimized("InvestmentPropertyExpenses-client", "Client", i);
                          this.calculateInvestmentPropertyExpensesOptimized("InvestmentPropertyExpenses-partner", "Partner", i);
                          this.calculateRealizedCGPOptimized("RCGP-client", "Client", i);
                          this.calculateRealizedCGPOptimized("RCGP-partner", "Partner", i);

                          ////Calculate Client Liability
                          this.liabilityClient.forEach((x: any) => { // client

                              var debtStrategy: any = [];
                              if (p == 1) {
                                  debtStrategy = strategyOrder.filter(c => c.id === x.liabilityId).filter(c => c.type === "Debt");
                              }

                              this.liabilityDrawDown = this.liabilityDD.filter((c: any) => c.liabilityId === x.liabilityId);


                              if (x.commenceOnDateType == "Start" || x.commenceOnDateType == "Existing") {
                                  x.commenceOnDate = this.clientDetails.startDate;
                              }
                              if (x.repaymentDateType == "End") {
                                  x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.repaymentDateType == "Retain") {
                                  x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }


                              var obj = this.LBValueOptimized.find((y: any) => y.owner === x.liabilityId);
                              var begVal: any = {};
                              var accruedInterest: any = {};
                              var repmt: any = {};
                              var endingVal: any = {};

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  begVal = obj.BegValues;
                                  accruedInterest = obj.accruedInterestValues;
                                  repmt = obj.repmtValues;
                                  endingVal = obj.endingValues;
                              }

                              obj["owner"] = x.liabilityId;
                              obj["type"] = "Client";
                              obj["name"] = "Opening Value";
                              obj["deductibility"] = x.deductibility;

                              if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.commenceOnDateType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.commenceOnDate) {
                                          begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.commenceOnDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = Number(endingVal[Number(this.clientDetails.startDate + i) - 1]);
                                      }
                                  }
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }

                              //accrued Interest
                              accruedInterest[this.clientDetails.startDate + i] = (begVal[this.clientDetails.startDate + i] * (x.interestRate / 100)).toFixed();

                              //Optimize Debt
                              if (debtStrategy.length > 0 && debtStrategy[0].AllocatedValue > 0) {
                                  repmt[this.clientDetails.startDate + i] = Number(debtStrategy[0].AllocatedValue);
                              }
                              else {
                                  var PMT: number = 0;
                                  if (x.repaymentType == "IO") {
                                      PMT = Number(accruedInterest[this.clientDetails.startDate + i]);
                                  }
                                  else {
                                      PMT = Number(x.principal) * (x.interestRate / 100) * (Math.pow((1 + (x.interestRate / 100)), x.term) / (Math.pow((1 + (x.interestRate / 100)), x.term) - 1));
                                  }
                                  if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {

                                      //Repayment Value
                                      var Repmt: number = 0;
                                      if (x.repaymentDateType == "Retain") {
                                          Repmt = Math.max(x.repayment, PMT);
                                      }
                                      else if ((this.clientDetails.startDate + i) == x.repaymentDate) {
                                          Repmt = Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]);
                                      }
                                      else {
                                          Repmt = Math.max(x.repayment, PMT);
                                      }
                                      var repayment = Math.min((begVal[this.clientDetails.startDate + i] + accruedInterest[this.clientDetails.startDate + i]), Repmt);
                                      repmt[this.clientDetails.startDate + i] = repayment.toFixed();
                                  }
                                  else {
                                      repmt[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              ////Ending Value

                              if (Number(repmt[this.clientDetails.startDate + i]) > (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]))) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]) - Number(repmt[this.clientDetails.startDate + i])).toFixed();
                              }
                              obj["BegValues"] = begVal;
                              obj["accruedInterestValues"] = accruedInterest;
                              obj["repmtValues"] = repmt;
                              obj["endingValues"] = endingVal;


                              if (this.LBValueOptimized.find((y: any) => y.owner === x.liabilityId) != null) {
                                  this.LBValueOptimized[this.LBValueOptimized.findIndex((c: any) => c.owner === x.liabilityId)] = obj;
                              }
                              else {
                                  this.LBValueOptimized.push(obj);
                              }

                          })
                          //Calculate Partner Liability
                          this.liabilityPartner.forEach((x: any) => { // client

                              this.liabilityDrawDown = this.liabilityDD.filter((c: any) => c.liabilityId === x.liabilityId);


                              if (x.commenceOnDateType == "Start" || x.commenceOnDateType == "Existing") {
                                  x.commenceOnDate = this.clientDetails.startDate;
                              }
                              if (x.repaymentDateType == "End") {
                                  x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.repaymentDateType == "Retain") {
                                  x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }


                              var obj = this.LBValueOptimized.find((y: any) => y.owner === x.liabilityId);
                              var begVal: any = {};
                              var accruedInterest: any = {};
                              var repmt: any = {};
                              var endingVal: any = {};

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  begVal = obj.BegValues;
                                  accruedInterest = obj.accruedInterestValues;
                                  repmt = obj.repmtValues;
                                  endingVal = obj.endingValues;
                              }


                              obj["owner"] = x.liabilityId;
                              obj["type"] = "Partner";
                              obj["name"] = "Opening Value";
                              obj["deductibility"] = x.deductibility;

                              if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.commenceOnDateType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.commenceOnDate) {
                                          begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.commenceOnDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = Number(endingVal[Number(this.clientDetails.startDate + i) - 1]);
                                      }
                                  }
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }

                              //accrued Interest
                              accruedInterest[this.clientDetails.startDate + i] = (begVal[this.clientDetails.startDate + i] * (x.interestRate / 100)).toFixed();

                              //Minimum repayment

                              var PMT: number = 0;
                              if (x.repaymentType == "IO") {
                                  PMT = Number(accruedInterest[this.clientDetails.startDate + i]);
                              }
                              else {
                                  PMT = Number(x.principal) * (x.interestRate / 100) * (Math.pow((1 + (x.interestRate / 100)), x.term) / (Math.pow((1 + (x.interestRate / 100)), x.term) - 1));
                              }
                              if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {

                                  //Repayment Value
                                  var Repmt: number = 0;
                                  if (x.repaymentDateType == "Retain") {
                                      Repmt = Math.max(x.repayment, PMT);
                                  }
                                  else if ((this.clientDetails.startDate + i) == x.repaymentDate) {
                                      Repmt = Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]);
                                  }
                                  else {
                                      Repmt = Math.max(x.repayment, PMT);
                                  }
                                  var repayment = Math.min((begVal[this.clientDetails.startDate + i] + accruedInterest[this.clientDetails.startDate + i]), Repmt);
                                  repmt[this.clientDetails.startDate + i] = repayment.toFixed();
                              }
                              else {
                                  repmt[this.clientDetails.startDate + i] = 0;
                              }
                              ////Ending Value
                              if (Number(repmt[this.clientDetails.startDate + i]) > (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]))) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]) - Number(repmt[this.clientDetails.startDate + i])).toFixed();
                              }
                              obj["BegValues"] = begVal;
                              obj["accruedInterestValues"] = accruedInterest;
                              obj["repmtValues"] = repmt;
                              obj["endingValues"] = endingVal;

                              if (this.LBValueOptimized.find((y: any) => y.owner === x.liabilityId) != null) {
                                  this.LBValueOptimized[this.LBValueOptimized.findIndex((c: any) => c.owner === x.liabilityId)] = obj;
                              }
                              else {
                                  this.LBValueOptimized.push(obj);
                              }

                          })
                          //Calculate Joint Liability
                          this.liabilityJoint.forEach((x: any) => { // client

                              this.liabilityDrawDown = this.liabilityDD.filter((c: any) => c.liabilityId === x.liabilityId);


                              if (x.commenceOnDateType == "Start" || x.commenceOnDateType == "Existing") {
                                  x.commenceOnDate = this.clientDetails.startDate;
                              }
                              if (x.repaymentDateType == "End") {
                                  x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.repaymentDateType == "Retain") {
                                  x.repaymentDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }



                              var obj = this.LBValueOptimized.find((y: any) => y.owner === x.liabilityId);
                              var begVal: any = {};
                              var accruedInterest: any = {};
                              var repmt: any = {};
                              var endingVal: any = {};

                              if (obj == null) {
                                  obj = {};
                              }
                              else {
                                  begVal = obj.BegValues;
                                  accruedInterest = obj.accruedInterestValues;
                                  repmt = obj.repmtValues;
                                  endingVal = obj.endingValues;
                              }


                              obj["owner"] = x.liabilityId;
                              obj["type"] = "Joint";
                              obj["name"] = "Opening Value";
                              obj["deductibility"] = x.deductibility;

                              if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.commenceOnDateType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.commenceOnDate) {
                                          begVal[this.clientDetails.startDate + i] = x.principal.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.commenceOnDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = Number(endingVal[Number(this.clientDetails.startDate + i) - 1]);
                                      }
                                  }
                              }
                              else {
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }

                              //accrued Interest
                              accruedInterest[this.clientDetails.startDate + i] = (begVal[this.clientDetails.startDate + i] * (x.interestRate / 100)).toFixed();

                              //Minimum repayment

                              var PMT: number = 0;
                              if (x.repaymentType == "IO") {
                                  PMT = Number(accruedInterest[this.clientDetails.startDate + i]);
                              }
                              else {
                                  PMT = Number(x.principal) * (x.interestRate / 100) * (Math.pow((1 + (x.interestRate / 100)), x.term) / (Math.pow((1 + (x.interestRate / 100)), x.term) - 1));
                              }
                              if (x.commenceOnDate <= this.clientDetails.startDate + i && x.repaymentDate >= this.clientDetails.startDate + i) {

                                  //Repayment Value
                                  var Repmt: number = 0;
                                  if (x.repaymentDateType == "Retain") {
                                      Repmt = Math.max(x.repayment, PMT);
                                  }
                                  else if ((this.clientDetails.startDate + i) == x.repaymentDate) {
                                      Repmt = Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]);
                                  }
                                  else {
                                      Repmt = Math.max(x.repayment, PMT);
                                  }
                                  var repayment = Math.min((begVal[this.clientDetails.startDate + i] + accruedInterest[this.clientDetails.startDate + i]), Repmt);
                                  repmt[this.clientDetails.startDate + i] = repayment.toFixed();
                              }
                              else {
                                  repmt[this.clientDetails.startDate + i] = 0;
                              }
                              ////Ending Value
                              if (Number(repmt[this.clientDetails.startDate + i]) > (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]))) {
                                  endingVal[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(accruedInterest[this.clientDetails.startDate + i]) - Number(repmt[this.clientDetails.startDate + i])).toFixed();
                              }

                              obj["BegValues"] = begVal;
                              obj["accruedInterestValues"] = accruedInterest;
                              obj["repmtValues"] = repmt;
                              obj["endingValues"] = endingVal;

                              if (this.LBValueOptimized.find((y: any) => y.owner === x.liabilityId) != null) {
                                  this.LBValueOptimized[this.LBValueOptimized.findIndex((c: any) => c.owner === x.liabilityId)] = obj;
                              }
                              else {
                                  this.LBValueOptimized.push(obj);
                              }

                          })
                          //Calculate Liability Total

                          this.calculateTotalDebtRepaymentOptimized("TotalDebtRepayment", i);
                          this.calculateAccruedLiabilitiesOptimized("Accruedliability-client", "Client", i);
                          this.calculateAccruedLiabilitiesOptimized("Accruedliability-partner", "Partner", i);


                          //Pension - Client
                          this.pensionClient.forEach((x: any) => {

                              this.pensionDrawDown = this.pensionDD.filter((c: any) => c.pensionId === x.pensionId);


                              if (x.pensionRebootFromType == "Start" || x.pensionRebootFromType == "Existing") {
                                  x.pensionRebootFromDate = this.clientDetails.startDate
                              }
                              else if (x.pensionRebootFromType == "Client Retirement") {
                                  x.pensionRebootFromDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }

                              var obj = this.PensionValueOptimized.find((y: any) => y.owner === x.pensionId);
                              var begVal: any = {};
                              var TaxableBegVal: any = {};
                              var TaxFreeBegVal: any = {};

                              var growth: any = {};
                              var income: any = {};
                              var frankingCredits: any = {};

                              var pensionIncome: any = {};
                              var pITaxAssessable: any = {};
                              var pITaxExempt: any = {};

                              var endingVal: any = {};
                              var TaxableEndingVal: any = {};
                              var TaxFreeEndingVal: any = {};
                              var endingValPV: any = {};
                              var TaxableProp: number = 0;
                              var TaxFreeProp: number = 0;

                              if (obj == null) {
                                  obj = {};
                                  TaxableProp = 0;
                                  TaxFreeProp = 0;
                              }
                              else {
                                  begVal = obj.BegValues;
                                  TaxableBegVal = obj.TaxableBegValues;
                                  TaxFreeBegVal = obj.TaxFreeBegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  frankingCredits = obj.frankingCreditsValues;
                                  pensionIncome = obj.pensionIncomeValues;
                                  pITaxAssessable = obj.pITaxAssessableValues;
                                  pITaxExempt = obj.pITaxExemptValues;
                                  endingVal = obj.endingValues;
                                  TaxableEndingVal = obj.TaxableEndingValues;
                                  TaxFreeEndingVal = obj.TaxFreeEndingValues;
                                  endingValPV = obj.endingValuesPV;
                                  TaxableProp = obj.taxableProp;
                                  TaxFreeProp = obj.taxfreeProp;

                              }

                              obj["owner"] = x.pensionId;
                              obj["type"] = "Client";
                              obj["name"] = "Opening Value";


                              if (x.pensionRebootFromDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.pensionRebootFromType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.pensionRebootFromDate) {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.pensionRebootFromDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {

                                          begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                                      }
                                  }


                                  if ((this.clientDetails.startDate + i) == x.pensionRebootFromDate || x.pensionRebootFromType == "Existing") {
                                      //TODO Confirm negative
                                      if (x.taxableComponent != 0 && x.value != 0) {
                                          TaxableProp = (Number(x.taxableComponent) / Number(x.value));
                                      }
                                      else {
                                          TaxableProp = 0;
                                      }
                                      TaxFreeProp = 1 - TaxableProp;

                                      TaxableBegVal[this.clientDetails.startDate + i] = x.taxableComponent.toFixed();
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = x.taxFreeComponent.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.pensionRebootFromDate) {

                                      TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {

                                      TaxableBegVal[this.clientDetails.startDate + i] = Number(TaxableEndingVal[Number(this.clientDetails.startDate + i) - 1]);
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = Number(TaxFreeEndingVal[Number(this.clientDetails.startDate + i) - 1]);
                                  }
                              }
                              else {
                                  TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }


                              ////growth & income
                              var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                              var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                              var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (Number(income[this.clientDetails.startDate + i]) * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //pension Income
                              var preservation = this.preservationAge.sort((a: any, b: any) => a.dob - b.dob);
                              var minPendionDD = this.minimumPensionDrawdown.sort((a: any, b: any) => a.age - b.age);
                              var currentYear = this.clientDetails.startDate + i;
                              var pAge: number = 0;
                              var minRate: number = 0;

                              for (var k = 0; k < preservation.length; k++) {


                                  if ((k == (preservation.length - 1)) && (this.clientDetails.clientDob >= preservation[k].dob)) {
                                      pAge = preservation[k].age;

                                  }
                                  else if (k == 0 && ((this.clientDetails.clientDob) <= preservation[k].dob)) {
                                      pAge = preservation[k].age;
                                      break;

                                  }
                                  else if ((this.clientDetails.clientDob) > preservation[k].dob && (this.clientDetails.clientDob) <= preservation[k + 1].dob) {
                                      pAge = preservation[k + 1].age;
                                      break;

                                  }
                              }
                              var date1 = new Date("7/01/ " + (this.clientDetails.startDate + i));
                              var date2 = new Date(this.clientDetails.clientDob);
                              var timeDiff = Math.abs(date2.getTime() - date1.getTime());
                              var diffDays = (Math.ceil(timeDiff / (1000 * 3600 * 24))) / 365;

                              var clientAge = Math.round(diffDays * 10) / 10;

                              for (var l = 0; l < minPendionDD.length; l++) {


                                  if ((l == (minPendionDD.length - 1)) && (clientAge >= minPendionDD[l].age)) {
                                      minRate = minPendionDD[l].minimumDrawdown;

                                  }
                                  else if (l == 0 && (clientAge <= minPendionDD[l].age)) {
                                      minRate = minPendionDD[l].minimumDrawdown;
                                      break;

                                  }
                                  else if (clientAge > minPendionDD[l].age && clientAge <= minPendionDD[l + 1].age) {
                                      minRate = minPendionDD[l + 1].minimumDrawdown;
                                      break;

                                  }
                              }


                              var minDrawdown: number = 0;
                              var maxDrawdown: number = 0;

                              if (clientAge < pAge) {
                                  minDrawdown = 0;
                                  maxDrawdown = 0;
                              }
                              else if (clientAge >= pAge && clientAge < 65) {
                                  if (this.clientRetirementYear != 0 && this.clientRetirementYear <= (this.clientDetails.startDate + i)) {
                                      minDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (minRate / 100);
                                      maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]);

                                  }
                                  else {
                                      minDrawdown = 0;
                                      maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (10 / 100);
                                  }

                              }
                              else if (clientAge >= 65) {
                                  minDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (minRate / 100);
                                  maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]);
                              }


                              if (x.pensionRebootFromDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {

                                  if (this.pensionDrawDown.length > 0) {
                                  let pIncomeSum: number = 0;
                                  this.pensionDrawDown.forEach((y: any) => {

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.amount == 0) {
                                              if (y.type == "Minimum") {
                                                  pensionIncome[this.clientDetails.startDate + i] = minDrawdown.toFixed();
                                              } else if (y.type == "Maximum") {
                                                  pensionIncome[this.clientDetails.startDate + i] = maxDrawdown.toFixed();
                                              }
                                          }
                                          else {
                                              pensionIncome[this.clientDetails.startDate + i] = (Math.min(maxDrawdown, Math.max(minDrawdown, y.amount))).toFixed();
                                          }
                                          //var t = parseInt(y.amount);
                                          //ContributionSum = ContributionSum + t;
                                      }

                                  });
                                  }
                                  else {
                                      pensionIncome[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  pensionIncome[this.clientDetails.startDate + i] = 0;
                              }


                              if (clientAge >= pAge && clientAge < 60) {
                                  pITaxAssessable[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) * TaxableProp).toFixed();
                                  pITaxExempt[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) - pITaxAssessable[this.clientDetails.startDate + i]).toFixed();
                              }
                              else if (clientAge >= 60) {
                                  pITaxAssessable[this.clientDetails.startDate + i] = 0;
                                  pITaxExempt[this.clientDetails.startDate + i] = Number(pensionIncome[this.clientDetails.startDate + i]).toFixed();
                              }

                              //Ending Value
                              endingVal[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(pensionIncome[this.clientDetails.startDate + i]);

                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              ////Ending Value - Taxable
                              TaxableEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) * TaxableProp).toFixed();

                              TaxFreeEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) - TaxFreeProp).toFixed();


                              obj["BegValues"] = begVal;
                              obj["TaxableBegValues"] = TaxableBegVal;
                              obj["TaxFreeBegValues"] = TaxFreeBegVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["pensionIncomeValues"] = pensionIncome;
                              obj["pITaxAssessableValues"] = pITaxAssessable;
                              obj["pITaxExemptValues"] = pITaxExempt;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["TaxableEndingValues"] = TaxableEndingVal;
                              obj["TaxFreeEndingValues"] = TaxFreeEndingVal;
                              //TODO: Verify
                              obj["taxableProp"] = TaxableProp;
                              obj["taxfreeProp"] = TaxFreeProp;


                              if (this.PensionValueOptimized.find((y: any) => y.owner === x.pensionId) != null) {
                                  this.PensionValueOptimized[this.PensionValueOptimized.findIndex((c: any) => c.owner === x.pensionId)] = obj;
                              }
                              else {
                                  this.PensionValueOptimized.push(obj);

                              }
                          });
                          //Pension - Partner
                          this.pensionPartner.forEach((x: any) =>  { // client

                              this.pensionDrawDown = this.pensionDD.filter((c: any) => c.pensionId === x.pensionId);


                              if (x.pensionRebootFromType == "Start" || x.pensionRebootFromType == "Existing") {
                                  x.pensionRebootFromDate = this.clientDetails.startDate
                              }
                              else if (x.pensionRebootFromType == "Partner Retirement") {
                                  x.pensionRebootFromDate = this.clientDetails.partnerRetirementYear - 1;
                              }
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.PensionValueOptimized.find((y: any) => y.owner === x.pensionId);
                              var begVal: any = {};
                              var TaxableBegVal: any = {};
                              var TaxFreeBegVal: any = {};

                              var growth: any = {};
                              var income: any = {};
                              var frankingCredits: any = {};

                              var pensionIncome: any = {};
                              var pITaxAssessable: any = {};
                              var pITaxExempt: any = {};

                              var endingVal: any = {};
                              var TaxableEndingVal: any = {};
                              var TaxFreeEndingVal: any = {};
                              var endingValPV: any = {};
                              var TaxableProp: number = 0;
                              var TaxFreeProp: number = 0;

                              if (obj == null) {
                                  obj = {};
                                  TaxableProp = 0;
                                  TaxFreeProp = 0;
                              }
                              else {
                                  begVal = obj.BegValues;
                                  TaxableBegVal = obj.TaxableBegValues;
                                  TaxFreeBegVal = obj.TaxFreeBegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  frankingCredits = obj.frankingCreditsValues;
                                  pensionIncome = obj.pensionIncomeValues;
                                  pITaxAssessable = obj.pITaxAssessableValues;
                                  pITaxExempt = obj.pITaxExemptValues;
                                  endingVal = obj.endingValues;
                                  TaxableEndingVal = obj.TaxableEndingValues;
                                  TaxFreeEndingVal = obj.TaxFreeEndingValues;
                                  endingValPV = obj.endingValuesPV;
                                  TaxableProp = obj.taxableProp;
                                  TaxFreeProp = obj.taxfreeProp;

                              }


                              obj["owner"] = x.pensionId;
                              obj["type"] = "Partner";
                              obj["name"] = "Opening Value";


                              if (x.pensionRebootFromDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.pensionRebootFromType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.pensionRebootFromDate) {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.pensionRebootFromDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {

                                          begVal[this.clientDetails.startDate + i] = endingVal[Number(this.clientDetails.startDate + i) - 1];
                                      }
                                  }


                                  if ((this.clientDetails.startDate + i) == x.pensionRebootFromDate || x.pensionRebootFromType == "Existing") {
                                      //TODO Confirm negative
                                      if (x.taxableComponent != 0 && x.value != 0) {
                                          TaxableProp = (Number(x.taxableComponent) / Number(x.value));
                                      }
                                      else {
                                          TaxableProp = 0;
                                      }
                                      TaxFreeProp = 1 - TaxableProp;

                                      TaxableBegVal[this.clientDetails.startDate + i] = x.taxableComponent.toFixed();
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = x.taxFreeComponent.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.pensionRebootFromDate) {

                                      TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {

                                      TaxableBegVal[this.clientDetails.startDate + i] = Number(TaxableEndingVal[Number(this.clientDetails.startDate + i) - 1]);
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = Number(TaxFreeEndingVal[Number(this.clientDetails.startDate + i) - 1]);
                                  }
                              }
                              else {
                                  TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }


                              ////growth & income
                              var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                              var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                              var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (Number(income[this.clientDetails.startDate + i]) * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //pension Income
                              var preservation = this.preservationAge.sort((a: any, b: any) => a.dob - b.dob);
                              var minPendionDD = this.minimumPensionDrawdown.sort((a: any, b: any) => a.age - b.age);
                              var currentYear = this.clientDetails.startDate + i;
                              var pAge: number = 0;
                              var minRate: number = 0;

                              for (var k = 0; k < preservation.length; k++) {


                                  if ((k == (preservation.length - 1)) && (this.clientDetails.partnerDob >= preservation[k].dob)) {
                                      pAge = preservation[k].age;

                                  }
                                  else if (k == 0 && ((this.clientDetails.partnerDob) <= preservation[k].dob)) {
                                      pAge = preservation[k].age;
                                      break;

                                  }
                                  else if ((this.clientDetails.partnerDob) > preservation[k].dob && (this.clientDetails.partnerDob) <= preservation[k + 1].dob) {
                                      pAge = preservation[k + 1].age;
                                      break;

                                  }
                              }
                              var date1 = new Date("7/01/ " + (this.clientDetails.startDate + i));
                              var date2 = new Date(this.clientDetails.partnerDob);
                              var timeDiff = Math.abs(date2.getTime() - date1.getTime());
                              var diffDays = (Math.ceil(timeDiff / (1000 * 3600 * 24))) / 365;

                              var partnerAge = Math.round(diffDays * 10) / 10;

                              for (var l = 0; l < minPendionDD.length; l++) {


                                  if ((l == (minPendionDD.length - 1)) && (partnerAge >= minPendionDD[l].age)) {
                                      minRate = minPendionDD[l].minimumDrawdown;

                                  }
                                  else if (l == 0 && (partnerAge <= minPendionDD[l].age)) {
                                      minRate = minPendionDD[l].minimumDrawdown;
                                      break;

                                  }
                                  else if (partnerAge > minPendionDD[l].age && partnerAge <= minPendionDD[l + 1].age) {
                                      minRate = minPendionDD[l + 1].minimumDrawdown;
                                      break;

                                  }
                              }


                              var minDrawdown: number = 0;
                              var maxDrawdown: number = 0;

                              if (partnerAge < pAge) {
                                  minDrawdown = 0;
                                  maxDrawdown = 0;
                              }
                              else if (partnerAge >= pAge && partnerAge < 65) {
                                  if (this.partnerRetirementYear != 0 && this.partnerRetirementYear <= (this.clientDetails.startDate + i)) {
                                      minDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (minRate / 100);
                                      maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]);

                                  }
                                  else {
                                      minDrawdown = 0;
                                      maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (10 / 100);
                                  }

                              }
                              else if (partnerAge >= 65) {
                                  minDrawdown = Number(begVal[this.clientDetails.startDate + i]) * (minRate / 100);
                                  maxDrawdown = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]);
                              }


                              if (x.pensionRebootFromDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {

                                  if (this.pensionDrawDown.length > 0) {
                                  let pIncomeSum: number = 0;
                                  this.pensionDrawDown.forEach((y: any) => {

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.amount == 0) {
                                              if (y.type == "Minimum") {
                                                  pensionIncome[this.clientDetails.startDate + i] = minDrawdown.toFixed();
                                              } else if (y.type == "Maximum") {
                                                  pensionIncome[this.clientDetails.startDate + i] = maxDrawdown.toFixed();
                                              }
                                          }
                                          else {
                                              pensionIncome[this.clientDetails.startDate + i] = (Math.min(maxDrawdown, Math.max(minDrawdown, y.amount))).toFixed();
                                          }
                                          //var t = parseInt(y.amount);
                                          //ContributionSum = ContributionSum + t;
                                      }

                                  });

                                  }
                                  else {
                                      pensionIncome[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  pensionIncome[this.clientDetails.startDate + i] = 0;
                              }


                              if (partnerAge >= pAge && partnerAge < 60) {
                                  pITaxAssessable[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) * TaxableProp).toFixed();
                                  pITaxExempt[this.clientDetails.startDate + i] = (Number(pensionIncome[this.clientDetails.startDate + i]) - pITaxAssessable[this.clientDetails.startDate + i]).toFixed();
                              }
                              else if (partnerAge >= 60) {
                                  pITaxAssessable[this.clientDetails.startDate + i] = 0;
                                  pITaxExempt[this.clientDetails.startDate + i] = Number(pensionIncome[this.clientDetails.startDate + i]).toFixed();
                              }

                              //Ending Value
                              endingVal[this.clientDetails.startDate + i] = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(pensionIncome[this.clientDetails.startDate + i]);

                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              ////Ending Value - Taxable
                              TaxableEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) * TaxableProp).toFixed();

                              TaxFreeEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) - TaxFreeProp).toFixed();


                              obj["BegValues"] = begVal;
                              obj["TaxableBegValues"] = TaxableBegVal;
                              obj["TaxFreeBegValues"] = TaxFreeBegVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["pensionIncomeValues"] = pensionIncome;
                              obj["pITaxAssessableValues"] = pITaxAssessable;
                              obj["pITaxExemptValues"] = pITaxExempt;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["TaxableEndingValues"] = TaxableEndingVal;
                              obj["TaxFreeEndingValues"] = TaxFreeEndingVal;
                              //TODO: Verify
                              obj["taxableProp"] = TaxableProp;
                              obj["taxfreeProp"] = TaxFreeProp;


                              if (this.PensionValueOptimized.find((y: any) => y.owner === x.pensionId) != null) {
                                  this.PensionValueOptimized[this.PensionValueOptimized.findIndex((c: any) => c.owner === x.pensionId)] = obj;
                              }
                              else {
                                  this.PensionValueOptimized.push(obj);

                              }


                          });
                          //PensionTotals

                          this.calculateTotalPensionIncomeOptimized("TotalPensionIncome", i);
                          this.calculatePensionIncomeTaxableOptimized("PensionIncome-client", "Client", i);
                          this.calculatePensionIncomeTaxableOptimized("PensionIncome-partner", "Partner", i);
                          this.calculateSuperIncomeTaxOffsetOptimized("SIncomeTaxOffset-client", "Client", i);
                          this.calculateSuperIncomeTaxOffsetOptimized("SIncomeTaxOffset-partner", "Partner", i);

                          //Super Client
                          this.superClient.forEach((x: any) => { // client
                              var superStrategySS: any = [];
                              var superStrategyNCC: any = [];
                              if (p == 1) {
                                   superStrategySS = strategyOrder.filter(c => c.id === x.superId).filter(c => c.type === "SS");
                                   superStrategyNCC = strategyOrder.filter(c => c.id === x.superId).filter(c => c.type === "NCC");
                              }
                              this.superSS = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "SS");
                              this.superPNC = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "PNC");
                              this.superSpouse = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "Spouse");
                              this.superLumpSum = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "LumpSum");


                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }

                              var obj = this.SuperValueOptimized.find((y: any) => y.owner === x.superId);
                              var begVal: any = {};
                              var TaxableBegVal: any = {};
                              var TaxFreeBegVal: any = {};
                              var growth: any = {};
                              var income: any = {};
                              var frankingCredits: any = {};
                              var insurance: any = {};
                              var sgContr: any = {};
                              var ssContr: any = {};
                              var pncContr: any = {};
                              var spouseContr: any = {};
                              var lumpSum: any = {};
                              var lumpSumTaxable: any = {};
                              var taxPayable: any = {};

                              var endingVal: any = {};
                              var TaxableEndingVal: any = {};
                              var TaxFreeEndingVal: any = {};
                              var endingValPV: any = {};

                              if (obj == null) {
                                  obj = {};

                              }
                              else {
                                  begVal = obj.BegValues;
                                  TaxableBegVal = obj.TaxableBegValues;
                                  TaxFreeBegVal = obj.TaxFreeBegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  frankingCredits = obj.frankingCreditsValues;

                                  insurance = obj.insuranceValues;
                                  sgContr = obj.sgContrValues;
                                  ssContr = obj.ssContrValues;
                                  pncContr = obj.pncContrValues;
                                  spouseContr = obj.spouseContrValues;
                                  lumpSum = obj.lumpSumValues;
                                  lumpSumTaxable = obj.lumpSumTaxableValues;
                                  taxPayable = obj.taxPayableValues;

                                  endingVal = obj.endingValues;
                                  TaxableEndingVal = obj.TaxableEndingValues;
                                  TaxFreeEndingVal = obj.TaxFreeEndingValues;
                                  endingValPV = obj.endingValuesPV;


                              }


                              obj["owner"] = x.superId;
                              obj["type"] = "Client";
                              obj["name"] = "Opening Value";

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.startDateType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.startDate) {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.startDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {

                                          begVal[this.clientDetails.startDate + i] = (Number(endingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                      }
                                  }


                                  if ((this.clientDetails.startDate + i) == x.startDate) {
                                      TaxableBegVal[this.clientDetails.startDate + i] = x.taxableComponent.toFixed();
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = x.taxFreeComponent.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.startDate) {

                                      TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {

                                      TaxableBegVal[this.clientDetails.startDate + i] = (Number(TaxableEndingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = (Number(TaxFreeEndingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                  }
                              }
                              else {
                                  TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }


                              ////growth & income
                              var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                              var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                              var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //insurance

                              let insuranceVal: number = 0;

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  insuranceVal = parseInt(x.insuranceCost);
                              }

                              insurance[this.clientDetails.startDate + i] = insuranceVal;

                              //Super Guarantee

                              var cc_cap = this.superAssumptions.filter((a: any) => a.type == "CC_Cap");
                              var cc_cap_val = cc_cap[0].value;

                              var ncc_cap = this.superAssumptions.filter((a: any) => a.type == "NCC_Cap");
                              var ncc_cap_val = cc_cap[0].value;

                              var mscb = this.superAssumptions.filter((a: any) => a.type == "MSCB");
                              var mscb_val = mscb[0].value;


                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (x.increaseToLimit == "Y") {

                                      let ContributionSum: number = 0;
                                      this.superSS.forEach((y: any) => {

                                          if (y.fromDateType == "Start") {
                                              y.fromDate = this.clientDetails.startDate;
                                          }
                                          if (y.toDateType == "End") {
                                              y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                          }

                                          if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                              var t = parseInt(y.amount);
                                              ContributionSum = ContributionSum + t;
                                          }

                                      });

                                      sgContr[this.clientDetails.startDate + i] = (cc_cap_val - ContributionSum).toFixed();
                                  }
                                  else {
                                      //TODO: get SGCRatev-verify
                                      var sgcRate: number = 1;

                                      if (x.sgrate == "SGC") {
                                          var sgc = this.sgcRates.sort((a: any, b: any) => a.year - b.year);
                                          var currentYear = this.clientDetails.startDate + i;


                                          for (var j = 0; j < sgc.length; j++) {


                                              if ((j == (sgc.length - 1)) && ((this.clientDetails.startDate + i) >= sgc[j].year)) {
                                                  sgcRate = sgc[j].sgcrate1;

                                              }
                                              else if (j == 0 && ((this.clientDetails.startDate + i) <= sgc[j].year)) {
                                                  sgcRate = sgc[j].sgcrate1;
                                                  break;

                                              }
                                              else if ((this.clientDetails.startDate + i) > sgc[j].year && (this.clientDetails.startDate + i) <= sgc[j + 1].year) {
                                                  sgcRate = sgc[j + 1].sgcrate1;
                                                  break;

                                              }
                                          }

                                      }
                                      else {
                                          sgcRate = Number(x.sgrate);
                                      }

                                      var cEmploymentIncome = clientEmploymentIncome.filter((g: any) => g.type === "Employment");

                                      var totalcEmploymentIncome = 0;
                                      for (var k = 0; k < cEmploymentIncome.length; k++) {
                                          if (isNaN(cEmploymentIncome[k].values[this.clientDetails.startDate + i])) {
                                              continue;
                                          }
                                          totalcEmploymentIncome += Number(cEmploymentIncome[k].values[this.clientDetails.startDate + i]);
                                      }




                                      // sgContr[this.clientDetails.startDate + i] = Math.min((x.superSalary * (sgcRate / 100)), mscb_val);
                                      sgContr[this.clientDetails.startDate + i] = (Math.min((totalcEmploymentIncome * (sgcRate / 100)), mscb_val)).toFixed();

                                  }
                              }
                              else {
                                  sgContr[this.clientDetails.startDate + i] = 0;
                              }

                              //Salary Sacrifice
                              if (p == 0) {
                                  ssContr[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  if (superStrategySS.length > 0 && superStrategySS[0].AllocatedValue > 0) {
                                      ssContr[this.clientDetails.startDate + i] = Number(superStrategySS[0].AllocatedValue);
                                  }
                                  else {
                                      let SalarySacrificeSum: number = 0;
                                      if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                          this.superSS.forEach((y: any) => { // client

                                              if (y.fromDateType == "Start") {
                                                  y.fromDate = this.clientDetails.startDate;
                                              }
                                              if (y.toDateType == "End") {
                                                  y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                              }

                                              if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                  if (y.increaseToLimit == "Y") {

                                                      var sgContr: number = 0;
                                                      var sgcRate: number = 1;



                                                      if (x.sgrate == "SGC") {
                                                          var sgc = this.sgcRates.sort((a: any, b: any) => a.year - b.year);
                                                          var currentYear = this.clientDetails.startDate + i;
                                                          for (var j = 0; j < sgc.length; j++) {
                                                              if ((j == (sgc.length - 1)) && ((this.clientDetails.startDate + i) >= sgc[j].year)) {
                                                                  sgcRate = sgc[j].sgcrate1;

                                                              }
                                                              else if (j == 0 && ((this.clientDetails.startDate + i) <= sgc[j].year)) {
                                                                  sgcRate = sgc[j].sgcrate1;
                                                                  break;

                                                              }
                                                              else if ((this.clientDetails.startDate + i) > sgc[j].year && (this.clientDetails.startDate + i) <= sgc[j + 1].year) {
                                                                  sgcRate = sgc[j + 1].sgcrate1;
                                                                  break;

                                                              }
                                                          }

                                                      }
                                                      else {
                                                          sgcRate = Number(x.sgrate);
                                                      }

                                                      var cEmploymentIncome = clientEmploymentIncome.filter((g: any) => g.type === "Employment");

                                                      var totalcEmploymentIncome = 0;
                                                      for (var k = 0; k < cEmploymentIncome.length; k++) {
                                                          if (isNaN(cEmploymentIncome[k].values[this.clientDetails.startDate + i])) {
                                                              continue;
                                                          }
                                                          totalcEmploymentIncome += Number(cEmploymentIncome[k].values[this.clientDetails.startDate + i]);
                                                      }

                                                      //sgContr = Math.min((x.superSalary * (sgcRate / 100)), mscb_val);
                                                      sgContr = Math.min((totalcEmploymentIncome * (sgcRate / 100)), mscb_val);
                                                      SalarySacrificeSum = cc_cap_val - sgContr;
                                                  }
                                                  else {
                                                      var t = parseInt(y.amount);
                                                      SalarySacrificeSum = SalarySacrificeSum + t;
                                                  }



                                              }

                                          });

                                          ssContr[this.clientDetails.startDate + i] = (SalarySacrificeSum).toFixed();
                                      }
                                      else {
                                          ssContr[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                              }

                              //PNC Contribution
                              if (p == 0) {
                                  pncContr[this.clientDetails.startDate + i] = 0;
                              }
                              else {
                                  if (superStrategyNCC.length > 0 && superStrategyNCC[0].AllocatedValue > 0) {
                                      pncContr[this.clientDetails.startDate + i] = Number(superStrategyNCC[0].AllocatedValue);
                                  }
                                  else {
                                      let PNCContributionSum: number = 0;
                                      if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                          this.superPNC.forEach((y: any) => { // client

                                              if (y.fromDateType == "Start") {
                                                  y.fromDate = this.clientDetails.startDate;
                                              }
                                              if (y.toDateType == "End") {
                                                  y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                              }

                                              if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                  if (y.increaseToLimit == "Y") {
                                                      let SpouseSum: number = 0;
                                                      this.superSpouse.forEach((y: any) => {

                                                          if (y.fromDateType == "Start") {
                                                              y.fromDate = this.clientDetails.startDate;
                                                          }
                                                          if (y.toDateType == "End") {
                                                              y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                                          }

                                                          if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                              var t = parseInt(y.amount);
                                                              SpouseSum = SpouseSum + t;
                                                          }

                                                      });

                                                      PNCContributionSum = ncc_cap_val - SpouseSum;

                                                  }
                                                  else {
                                                      var t = parseInt(y.amount);
                                                      PNCContributionSum = PNCContributionSum + t;
                                                  }
                                              }

                                          });
                                          pncContr[this.clientDetails.startDate + i] = (PNCContributionSum).toFixed();;
                                      }
                                      else {
                                          pncContr[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                              }


                              //Spouse Contribution
                              let SpouseContributionSum: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  this.superSpouse.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.increaseToLimit == "Y") {
                                              let PNCSum: number = 0;
                                              this.superPNC.forEach((y: any) => {

                                                  if (y.fromDateType == "Start") {
                                                      y.fromDate = this.clientDetails.startDate;
                                                  }
                                                  if (y.toDateType == "End") {
                                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                                  }

                                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                      var t = parseInt(y.amount);
                                                      PNCSum = PNCSum + t;
                                                  }

                                              });

                                              SpouseContributionSum = ncc_cap_val - PNCSum;

                                          }
                                          else {
                                              var t = parseInt(y.amount);
                                              SpouseContributionSum = SpouseContributionSum + t;
                                          }
                                      }

                                  });
                                  spouseContr[this.clientDetails.startDate + i] = (SpouseContributionSum).toFixed();
                              }
                              else {
                                  spouseContr[this.clientDetails.startDate + i] = 0;
                              }
                              //Lumpsum Withdrawals
                              let LumpsumWithdrawalsSum: number = 0;
                              let LumpsumTaxableSum: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  this.superLumpSum.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          var t = parseInt(y.amount);
                                          LumpsumWithdrawalsSum = LumpsumWithdrawalsSum + t;
                                      }

                                  });
                                  lumpSum[this.clientDetails.startDate + i] = LumpsumWithdrawalsSum;


                                  if (LumpsumWithdrawalsSum > 0) {
                                      var TaxableBeforLS = Number(TaxableBegVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]);
                                      //TODO: Add govtContr
                                      var ValueBeforeLS = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) + Number(pncContr[this.clientDetails.startDate + i]) + Number(spouseContr[this.clientDetails.startDate + i]);
                                      if (TaxableBeforLS != 0 && ValueBeforeLS != 0) {
                                          lumpSumTaxable[this.clientDetails.startDate + i] = LumpsumWithdrawalsSum * (TaxableBeforLS / ValueBeforeLS);
                                      }
                                      else {
                                          lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                                  else {
                                      lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  lumpSum[this.clientDetails.startDate + i] = 0;
                                  lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                              }


                              //Taxes Payable
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  var earningsTax = this.superAssumptions.filter((a: any) => a.type == "EarningsTaxRate");
                                  var earningsTax_val = earningsTax[0].value;

                                  var ccTaxRate = this.superAssumptions.filter((a: any) => a.type == "CCTaxRate");
                                  var ccTaxRate_val = ccTaxRate[0].value;

                                  var addTaxRate = this.superAssumptions.filter((a: any) => a.type == "AddTaxRate");
                                  var addTaxRate_val = addTaxRate[0].value;

                                  let ccTax: number = 0;
                                  var EarningsTax = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i])) * (earningsTax_val / 100);

                                  //var taxableIncome: any = {};
                                  //taxableIncome = this.clientTaxableIncome.filter(c => c.owner === "ClientTaxableIncome");
                                  //let taxableIncomeVal: number = Number(taxableIncome[0].values[this.clientDetails.startDate + i]);
                                  //if (taxableIncomeVal <= 250000) {
                                  ccTax = (Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i])) * (ccTaxRate_val / 100);
                                  //}
                                  //else {
                                  //    ccTax = (sgContr[this.clientDetails.startDate + i] + ssContr[this.clientDetails.startDate + i]) * ((ccTaxRate_val / 100) + (addTaxRate_val / 100));

                                  //}
                                  taxPayable[this.clientDetails.startDate + i] = (EarningsTax + ccTax).toFixed()
                              }
                              else {
                                  taxPayable[this.clientDetails.startDate + i] = 0;
                              }




                              //Ending Value
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) + Number(pncContr[this.clientDetails.startDate + i]) + Number(spouseContr[this.clientDetails.startDate + i]) - Number(taxPayable[this.clientDetails.startDate + i]) - Number(lumpSum[this.clientDetails.startDate + i])).toFixed()

                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              //Ending Value - Taxable
                              TaxableEndingVal[this.clientDetails.startDate + i] = (Number(TaxableBegVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) - Number(taxPayable[this.clientDetails.startDate + i]) - Number(lumpSum[this.clientDetails.startDate + i])).toFixed();

                              TaxFreeEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) - Number(TaxableEndingVal[this.clientDetails.startDate + i])).toFixed();


                              obj["BegValues"] = begVal;
                              obj["TaxableBegValues"] = TaxableBegVal;
                              obj["TaxFreeBegValues"] = TaxFreeBegVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["insuranceValues"] = insurance;
                              obj["sgContrValues"] = sgContr;
                              obj["ssContrValues"] = ssContr;
                              obj["pncContrValues"] = pncContr;
                              obj["spouseContrValues"] = spouseContr;
                              obj["lumpSumValues"] = lumpSum;
                              obj["lumpSumTaxableValues"] = lumpSumTaxable;
                              obj["taxPayableValues"] = taxPayable;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["TaxableEndingValues"] = TaxableEndingVal;
                              obj["TaxFreeEndingValues"] = TaxFreeEndingVal;

                              if (this.SuperValueOptimized.find((y: any) => y.owner === x.superId) != null) {
                                  this.SuperValueOptimized[this.SuperValueOptimized.findIndex((c: any) => c.owner === x.superId)] = obj;
                              }
                              else {
                                  this.SuperValueOptimized.push(obj);

                              }

                          });
                          this.superPartner.forEach((x: any) => { // client

                              this.superSS = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "SS");
                              this.superPNC = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "PNC");
                              this.superSpouse = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "Spouse");
                              this.superLumpSum = this.superDetails.filter((c: any) => c.superId === x.superId).filter((r: any) => r.type === "LumpSum");


                              if (x.startDateType == "Start" || x.startDateType == "Existing") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Retain") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period));
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.SuperValueOptimized.find((y: any) => y.owner === x.superId);
                              var begVal: any = {};
                              var TaxableBegVal: any = {};
                              var TaxFreeBegVal: any = {};
                              var growth: any = {};
                              var income: any = {};
                              var frankingCredits: any = {};
                              var insurance: any = {};
                              var sgContr: any = {};
                              var ssContr: any = {};
                              var pncContr: any = {};
                              var spouseContr: any = {};
                              var lumpSum: any = {};
                              var lumpSumTaxable: any = {};
                              var taxPayable: any = {};

                              var endingVal: any = {};
                              var TaxableEndingVal: any = {};
                              var TaxFreeEndingVal: any = {};
                              var endingValPV: any = {};

                              if (obj == null) {
                                  obj = {};

                              }
                              else {
                                  begVal = obj.BegValues;
                                  TaxableBegVal = obj.TaxableBegValues;
                                  TaxFreeBegVal = obj.TaxFreeBegValues;
                                  growth = obj.growthValues;
                                  income = obj.incomeValues;
                                  frankingCredits = obj.frankingCreditsValues;

                                  insurance = obj.insuranceValues;
                                  sgContr = obj.sgContrValues;
                                  ssContr = obj.ssContrValues;
                                  pncContr = obj.pncContrValues;
                                  spouseContr = obj.spouseContrValues;
                                  lumpSum = obj.lumpSumValues;
                                  lumpSumTaxable = obj.lumpSumTaxableValues;
                                  taxPayable = obj.taxPayableValues;

                                  endingVal = obj.endingValues;
                                  TaxableEndingVal = obj.TaxableEndingValues;
                                  TaxFreeEndingVal = obj.TaxFreeEndingValues;
                                  endingValPV = obj.endingValuesPV;


                              }


                              obj["owner"] = x.superId;
                              obj["type"] = "Partner";
                              obj["name"] = "Opening Value";

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  //BeginningValue
                                  if (n == 1) {
                                      if (x.startDateType == "Existing") {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else {
                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }

                                  }
                                  else {
                                      if ((this.clientDetails.startDate + i) == x.startDate) {
                                          begVal[this.clientDetails.startDate + i] = x.value.toFixed();
                                      }
                                      else if ((this.clientDetails.startDate + i) < x.startDate) {

                                          begVal[this.clientDetails.startDate + i] = 0;
                                      }
                                      else {

                                          begVal[this.clientDetails.startDate + i] = (Number(endingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                      }
                                  }


                                  if ((this.clientDetails.startDate + i) == x.startDate) {
                                      TaxableBegVal[this.clientDetails.startDate + i] = x.taxableComponent.toFixed();
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = x.taxFreeComponent.toFixed();
                                  }
                                  else if ((this.clientDetails.startDate + i) < x.startDate) {

                                      TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  }
                                  else {

                                      TaxableBegVal[this.clientDetails.startDate + i] = (Number(TaxableEndingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                      TaxFreeBegVal[this.clientDetails.startDate + i] = (Number(TaxFreeEndingVal[Number(this.clientDetails.startDate + i) - 1])).toFixed();
                                  }
                              }
                              else {
                                  TaxableBegVal[this.clientDetails.startDate + i] = 0;
                                  TaxFreeBegVal[this.clientDetails.startDate + i] = 0;
                                  begVal[this.clientDetails.startDate + i] = 0;
                              }


                              ////growth & income
                              var growthUnAdj = (x.growth / 100) * Number(begVal[this.clientDetails.startDate + i]);
                              var incomeUnAdj = (x.income / 100) * Number(begVal[this.clientDetails.startDate + i]);

                              var ICR = (x.productFees / 100) * Number(begVal[this.clientDetails.startDate + i]);


                              var growthVal = growthUnAdj - (ICR * (growthUnAdj / (growthUnAdj + incomeUnAdj)));
                              var incomeVal = incomeUnAdj - (ICR * (incomeUnAdj / (growthUnAdj + incomeUnAdj)));

                              if (typeof growthVal === "number" && !isNaN(growthVal)) {
                                  growth[this.clientDetails.startDate + i] = growthVal.toFixed();
                              }
                              else {
                                  growth[this.clientDetails.startDate + i] = 0;
                              }

                              if (typeof incomeVal === "number" && !isNaN(incomeVal)) {
                                  income[this.clientDetails.startDate + i] = incomeVal.toFixed();
                              }
                              else {
                                  income[this.clientDetails.startDate + i] = 0;
                              }

                              //FrankingCredits

                              var corporateTaxRate = this.generalAssumptions.filter((a: any) => a.type == "CorporateTaxRate");
                              var ctr = Number(corporateTaxRate[0].percentage) / 100;

                              frankingCredits[this.clientDetails.startDate + i] = (income[this.clientDetails.startDate + i] * (ctr / (1 - ctr)) * (x.franked / 100)).toFixed();

                              //insurance

                              let insuranceVal: number = 0;

                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  insuranceVal = parseInt(x.insuranceCost);
                              }

                              insurance[this.clientDetails.startDate + i] = insuranceVal;

                              //Super Guarantee

                              var cc_cap = this.superAssumptions.filter((a: any) => a.type == "CC_Cap");
                              var cc_cap_val = cc_cap[0].value;

                              var ncc_cap = this.superAssumptions.filter((a: any) => a.type == "NCC_Cap");
                              var ncc_cap_val = cc_cap[0].value;

                              var mscb = this.superAssumptions.filter((a: any) => a.type == "MSCB");
                              var mscb_val = mscb[0].value;


                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  if (x.increaseToLimit == "Y") {

                                      let ContributionSum: number = 0;
                                      this.superSS.forEach((y: any) => {

                                          if (y.fromDateType == "Start") {
                                              y.fromDate = this.clientDetails.startDate;
                                          }
                                          if (y.toDateType == "End") {
                                              y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                          }

                                          if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                              var t = parseInt(y.amount);
                                              ContributionSum = ContributionSum + t;
                                          }

                                      });

                                      sgContr[this.clientDetails.startDate + i] = (cc_cap_val - ContributionSum).toFixed();
                                  }
                                  else {
                                      //TODO: get SGCRatev-verify
                                      var sgcRate: number = 1;

                                      if (x.sgrate == "SGC") {
                                          var sgc = this.sgcRates.sort((a: any, b: any) => a.year - b.year);
                                          var currentYear = this.clientDetails.startDate + i;


                                          for (var j = 0; j < sgc.length; j++) {


                                              if ((j == (sgc.length - 1)) && ((this.clientDetails.startDate + i) >= sgc[j].year)) {
                                                  sgcRate = sgc[j].sgcrate1;

                                              }
                                              else if (j == 0 && ((this.clientDetails.startDate + i) <= sgc[j].year)) {
                                                  sgcRate = sgc[j].sgcrate1;
                                                  break;

                                              }
                                              else if ((this.clientDetails.startDate + i) > sgc[j].year && (this.clientDetails.startDate + i) <= sgc[j + 1].year) {
                                                  sgcRate = sgc[j + 1].sgcrate1;
                                                  break;

                                              }
                                          }

                                      }
                                      else {
                                          sgcRate = Number(x.sgrate);
                                      }

                                      var pEmploymentIncome = partnerEmploymentIncome.filter((g: any) => g.type === "Employment");

                                      var totalpEmploymentIncome = 0;
                                      for (var k = 0; k < pEmploymentIncome.length; k++) {
                                          if (isNaN(pEmploymentIncome[k].values[this.clientDetails.startDate + i])) {
                                              continue;
                                          }
                                          totalpEmploymentIncome += Number(pEmploymentIncome[k].values[this.clientDetails.startDate + i]);
                                      }

                                      //TODO: Verify if correct
                                      //sgContr[this.clientDetails.startDate + i] = Math.min((x.superSalary * (sgcRate / 100)), mscb_val);
                                      sgContr[this.clientDetails.startDate + i] = (Math.min((totalpEmploymentIncome * (sgcRate / 100)), mscb_val)).toFixed();

                                  }
                              }
                              else {
                                  sgContr[this.clientDetails.startDate + i] = 0;
                              }

                              //Salary Sacrifice

                              let SalarySacrificeSum: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  this.superSS.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.increaseToLimit == "Y") {

                                              var sgContr: number = 0;
                                              var sgcRate: number = 1;



                                              if (x.sgrate == "SGC") {
                                                  var sgc = this.sgcRates.sort((a: any, b: any) => a.year - b.year);
                                                  var currentYear = this.clientDetails.startDate + i;
                                                  for (var j = 0; j < sgc.length; j++) {
                                                      if ((j == (sgc.length - 1)) && ((this.clientDetails.startDate + i) >= sgc[j].year)) {
                                                          sgcRate = sgc[j].sgcrate1;

                                                      }
                                                      else if (j == 0 && ((this.clientDetails.startDate + i) <= sgc[j].year)) {
                                                          sgcRate = sgc[j].sgcrate1;
                                                          break;

                                                      }
                                                      else if ((this.clientDetails.startDate + i) > sgc[j].year && (this.clientDetails.startDate + i) <= sgc[j + 1].year) {
                                                          sgcRate = sgc[j + 1].sgcrate1;
                                                          break;

                                                      }
                                                  }

                                              }
                                              else {
                                                  sgcRate = Number(x.sgrate);
                                              }

                                              var pEmploymentIncome = partnerEmploymentIncome.filter((g: any) => g.type === "Employment");

                                              var totalpEmploymentIncome = 0;
                                              for (var k = 0; k < pEmploymentIncome.length; k++) {
                                                  if (isNaN(pEmploymentIncome[k].values[this.clientDetails.startDate + i])) {
                                                      continue;
                                                  }
                                                  totalpEmploymentIncome += Number(pEmploymentIncome[k].values[this.clientDetails.startDate + i]);
                                              }

                                              //TODO: Verify if correct
                                              sgContr = Math.min((totalpEmploymentIncome * (sgcRate / 100)), mscb_val);
                                              SalarySacrificeSum = cc_cap_val - sgContr;
                                          }
                                          else {
                                              var t = parseInt(y.amount);
                                              SalarySacrificeSum = SalarySacrificeSum + t;
                                          }



                                      }

                                  });

                                  ssContr[this.clientDetails.startDate + i] = (SalarySacrificeSum).toFixed();
                              }
                              else {
                                  ssContr[this.clientDetails.startDate + i] = 0;
                              }

                              //PNC Contribution
                              let PNCContributionSum: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  this.superPNC.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.increaseToLimit == "Y") {
                                              let SpouseSum: number = 0;
                                              this.superSpouse.forEach((y: any) => {

                                                  if (y.fromDateType == "Start") {
                                                      y.fromDate = this.clientDetails.startDate;
                                                  }
                                                  if (y.toDateType == "End") {
                                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                                  }

                                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                      var t = parseInt(y.amount);
                                                      SpouseSum = SpouseSum + t;
                                                  }

                                              });

                                              PNCContributionSum = ncc_cap_val - SpouseSum;

                                          }
                                          else {
                                              var t = parseInt(y.amount);
                                              PNCContributionSum = PNCContributionSum + t;
                                          }
                                      }

                                  });
                                  pncContr[this.clientDetails.startDate + i] = (PNCContributionSum).toFixed();
                              }
                              else {
                                  pncContr[this.clientDetails.startDate + i] = 0;
                              }

                              //Spouse Contribution
                              let SpouseContributionSum: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  this.superSpouse.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          if (y.increaseToLimit == "Y") {
                                              let PNCSum: number = 0;
                                              this.superPNC.forEach((y: any) => {

                                                  if (y.fromDateType == "Start") {
                                                      y.fromDate = this.clientDetails.startDate;
                                                  }
                                                  if (y.toDateType == "End") {
                                                      y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                                  }

                                                  if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                                      var t = parseInt(y.amount);
                                                      PNCSum = PNCSum + t;
                                                  }

                                              });

                                              SpouseContributionSum = ncc_cap_val - PNCSum;

                                          }
                                          else {
                                              var t = parseInt(y.amount);
                                              SpouseContributionSum = SpouseContributionSum + t;
                                          }
                                      }

                                  });
                                  spouseContr[this.clientDetails.startDate + i] = (SpouseContributionSum).toFixed();
                              }
                              else {
                                  spouseContr[this.clientDetails.startDate + i] = 0;
                              }
                              //Lumpsum Withdrawals
                              let LumpsumWithdrawalsSum: number = 0;
                              let LumpsumTaxableSum: number = 0;
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  this.superLumpSum.forEach((y: any) => { // client

                                      if (y.fromDateType == "Start") {
                                          y.fromDate = this.clientDetails.startDate;
                                      }
                                      if (y.toDateType == "End") {
                                          y.toDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                                      }

                                      if (y.fromDate <= this.clientDetails.startDate + i && y.toDate >= this.clientDetails.startDate + i) {
                                          var t = parseInt(y.amount);
                                          LumpsumWithdrawalsSum = LumpsumWithdrawalsSum + t;
                                      }

                                  });
                                  lumpSum[this.clientDetails.startDate + i] = LumpsumWithdrawalsSum;


                                  if (LumpsumWithdrawalsSum > 0) {
                                      var TaxableBeforLS = Number(TaxableBegVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]);
                                      //TODO: Add govtContr
                                      var ValueBeforeLS = Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) + Number(pncContr[this.clientDetails.startDate + i]) + Number(spouseContr[this.clientDetails.startDate + i]);
                                      if (TaxableBeforLS != 0 && ValueBeforeLS != 0) {
                                          lumpSumTaxable[this.clientDetails.startDate + i] = LumpsumWithdrawalsSum * (TaxableBeforLS / ValueBeforeLS);
                                      }
                                      else {
                                          lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                                      }
                                  }
                                  else {
                                      lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                                  }

                              }
                              else {
                                  lumpSum[this.clientDetails.startDate + i] = 0;
                                  lumpSumTaxable[this.clientDetails.startDate + i] = 0;
                              }


                              //Taxes Payable
                              if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                  var earningsTax = this.superAssumptions.filter((a: any) => a.type == "EarningsTaxRate");
                                  var earningsTax_val = earningsTax[0].value;

                                  var ccTaxRate = this.superAssumptions.filter((a: any) => a.type == "CCTaxRate");
                                  var ccTaxRate_val = ccTaxRate[0].value;

                                  var addTaxRate = this.superAssumptions.filter((a: any) => a.type == "AddTaxRate");
                                  var addTaxRate_val = addTaxRate[0].value;

                                  let ccTax: number = 0;
                                  var EarningsTax = (Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i])) * (earningsTax_val / 100);

                                  //var taxableIncome: any = {};
                                  //taxableIncome = this.clientTaxableIncome.filter(c => c.owner === "ClientTaxableIncome");
                                  //let taxableIncomeVal: number = Number(taxableIncome[0].values[this.clientDetails.startDate + i]);
                                  //if (taxableIncomeVal <= 250000) {
                                  ccTax = (Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i])) * (ccTaxRate_val / 100);
                                  //}
                                  //else {
                                  //    ccTax = (sgContr[this.clientDetails.startDate + i] + ssContr[this.clientDetails.startDate + i]) * ((ccTaxRate_val / 100) + (addTaxRate_val / 100));

                                  //}
                                  taxPayable[this.clientDetails.startDate + i] = (EarningsTax + ccTax).toFixed()
                              }
                              else {
                                  taxPayable[this.clientDetails.startDate + i] = 0;
                              }




                              //Ending Value
                              endingVal[this.clientDetails.startDate + i] = (Number(begVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) + Number(pncContr[this.clientDetails.startDate + i]) + Number(spouseContr[this.clientDetails.startDate + i]) - Number(taxPayable[this.clientDetails.startDate + i]) - Number(lumpSum[this.clientDetails.startDate + i])).toFixed()

                              ////Ending Value PV
                              var inflation = this.generalAssumptions.filter((a: any) => a.type == "Inflation");
                              var inf = Number(inflation[0].percentage) / 100;
                              var k: number = Number(this.clientDetails.startDate + i) - new Date().getFullYear();
                              endingValPV[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) / Math.pow((1 + inf), (k))).toFixed();

                              //Ending Value - Taxable
                              TaxableEndingVal[this.clientDetails.startDate + i] = (Number(TaxableBegVal[this.clientDetails.startDate + i]) + Number(growth[this.clientDetails.startDate + i]) + Number(income[this.clientDetails.startDate + i]) - Number(insurance[this.clientDetails.startDate + i]) + Number(sgContr[this.clientDetails.startDate + i]) + Number(ssContr[this.clientDetails.startDate + i]) - Number(taxPayable[this.clientDetails.startDate + i]) - Number(lumpSum[this.clientDetails.startDate + i])).toFixed();

                              TaxFreeEndingVal[this.clientDetails.startDate + i] = (Number(endingVal[this.clientDetails.startDate + i]) - Number(TaxableEndingVal[this.clientDetails.startDate + i])).toFixed();


                              obj["BegValues"] = begVal;
                              obj["TaxableBegValues"] = TaxableBegVal;
                              obj["TaxFreeBegValues"] = TaxFreeBegVal;
                              obj["growthValues"] = growth;
                              obj["incomeValues"] = income;
                              obj["frankingCreditsValues"] = frankingCredits;
                              obj["insuranceValues"] = insurance;
                              obj["sgContrValues"] = sgContr;
                              obj["ssContrValues"] = ssContr;
                              obj["pncContrValues"] = pncContr;
                              obj["spouseContrValues"] = spouseContr;
                              obj["lumpSumValues"] = lumpSum;
                              obj["lumpSumTaxableValues"] = lumpSumTaxable;
                              obj["taxPayableValues"] = taxPayable;
                              obj["endingValues"] = endingVal;
                              obj["endingValuesPV"] = endingValPV;
                              obj["TaxableEndingValues"] = TaxableEndingVal;
                              obj["TaxFreeEndingValues"] = TaxFreeEndingVal;

                              if (this.SuperValueOptimized.find((y: any) => y.owner === x.superId) != null) {
                                  this.SuperValueOptimized[this.SuperValueOptimized.findIndex((c: any) => c.owner === x.superId)] = obj;
                              }
                              else {
                                  this.SuperValueOptimized.push(obj);

                              }


                          });
                          //SuperTotals
                          this.calculateTotalLumpSumWithdrawalsOptimized("TotalLumpSumWithdrawals", i);
                          this.calculateTotalSalarySacrificeContributionOptimized("TotalSalarySacrificeContributions", i);
                          this.calculateTotalPNCContibutionOptimized("TotalPNCContributions", i);
                          this.calculateTotalSpouseContibutionOptimized("TotalSpouseContributions", i);
                          this.calculateLumpSumTaxOptimized("LumpSum-client", "Client", i);
                          this.calculateSalarySacrificeTaxOptimized("SalarySacrifice-client", "Client", i);
                          this.calculateLumpSumTaxOptimized("LumpSum-partner", "Partner", i);
                          this.calculateSalarySacrificeTaxOptimized("SalarySacrifice-partner", "Partner", i);

                          //Calculate Tax Deductions
                          this.EPRTClient.forEach((x: any) => { // client

                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }

                              var obj = this.ClientDeductionsOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;


                              if (p == 0) {
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;


                              if (this.ClientDeductionsOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  this.ClientDeductionsOptimized[this.ClientDeductionsOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  this.ClientDeductionsOptimized.push(obj);
                              }

                          })
                          this.EPRTPartner.forEach((x: any) => { // client

                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.PartnerDeductionsOptimized.find((y: any) => y.id === x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = x.owner;
                              obj["name"] = x.cfname;
                              obj["id"] = x.cflowId;

                              if (p == 0) {
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = x.value.toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = (x.value * (Math.pow((1 + x.indexation / 100), j))).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;


                              if (this.PartnerDeductionsOptimized.find((y: any) => y.id === x.cflowId) != null) {
                                  this.PartnerDeductionsOptimized[this.PartnerDeductionsOptimized.findIndex((c: any) => c.id === x.cflowId)] = obj;
                              }
                              else {
                                  this.PartnerDeductionsOptimized.push(obj);
                              }

                          })
                          this.EPRTJoint.forEach((x: any) => { // joint

                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.ClientDeductionsOptimized.find((y: any) => y.id === "ClientJoint" + x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = "Client";
                              obj["name"] = x.cfname;
                              obj["id"] = "ClientJoint" + x.cflowId;

                              if (p == 0) {
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = (x.value / 2).toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = ((x.value * (Math.pow((1 + x.indexation / 100), j))) / 2).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;


                              if (this.ClientDeductionsOptimized.find((y: any) => y.id === "ClientJoint" + x.cflowId) != null) {
                                  this.ClientDeductionsOptimized[this.ClientDeductionsOptimized.findIndex((c: any) => c.id === "ClientJoint" + x.cflowId)] = obj;
                              }
                              else {
                                  this.ClientDeductionsOptimized.push(obj);
                              }

                          })
                          this.EPRTJoint.forEach((x: any) => { // joint

                              if (x.startDateType == "Start") {
                                  x.startDate = this.clientDetails.startDate
                              }
                              else if (x.startDateType == "Client Retirement") {
                                  x.startDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.startDateType == "Partner Retirement") {
                                  x.startDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              if (x.endDateType == "End") {
                                  x.endDate = Number(this.clientDetails.startDate) + (Number(this.clientDetails.period) - 1);
                              }
                              else if (x.endDateType == "Client Retirement") {
                                  x.endDate = this.clientDetails.clientRetirementYear - 1;
                              }
                              else if (x.endDateType == "Partner Retirement") {
                                  x.endDate = this.clientDetails.partnerRetirementYear - 1;
                              }

                              var obj = this.PartnerDeductionsOptimized.find((y: any) => y.id === "PartnerJoint" + x.cflowId);
                              var obj1: any = {};
                              var j: number = 0;
                              if (obj == null) {
                                  obj = {};
                                  j = 0;
                              }
                              else {
                                  obj1 = obj.values;
                                  j = obj.increment;
                              }
                              obj["owner"] = "Partner";
                              obj["name"] = x.cfname;
                              obj["id"] = "PartnerJoint" + x.cflowId;

                              if (p == 0) {
                                  if (x.startDate <= this.clientDetails.startDate + i && x.endDate >= this.clientDetails.startDate + i) {
                                      if (j == 0) {
                                          obj1[this.clientDetails.startDate + i] = (x.value / 2).toFixed();

                                      }
                                      else {
                                          obj1[this.clientDetails.startDate + i] = ((x.value * (Math.pow((1 + x.indexation / 100), j))) / 2).toFixed();
                                      }
                                      j++;
                                  }
                                  else {
                                      obj1[this.clientDetails.startDate + i] = 0;
                                  }
                              }
                              obj["values"] = obj1;
                              obj["increment"] = j;

                              if (this.PartnerDeductionsOptimized.find((y: any) => y.id === "PartnerJoint" + x.cflowId) != null) {
                                  this.PartnerDeductionsOptimized[this.PartnerDeductionsOptimized.findIndex((c: any) => c.id === "PartnerJoint" + x.cflowId)] = obj;
                              }
                              else {
                                  this.PartnerDeductionsOptimized.push(obj);
                              }

                          })

                          ////Calculate Tax Totals

                          this.calculateTotalTaxIncomeOptimized("TotalTax-client", "Client", i);
                          this.calculateCapitalLossAdjustmentOptimized("CLA-client", "Client", i);
                          this.calculateTotalAssessibleIncomeOptimized("ClientAssessibleIncome", "TotalTax-client", "Client", i);
                          this.calculateClientTotalDeductionsOptimized("ClientDeductions", "Client", i);
                          this.calculateClientTaxableIncomeOptimized(i);
                          this.calculateLowIncomeTOOptimized("ClientLowIncomeTO", "ClientTaxableIncome", "Client", i);
                          this.calculateRefundableTaxOffsetOptimized("ClientFrankingCredits", "Client", i);

                          this.calculateClientTotalNRTaxOffsetOptimized("ClientTotalTO", "ClientLowIncomeTO", i);
                          this.calculateGrossTaxOptimized("ClientGrossTax", "ClientTaxableIncome", "Client", i);
                          this.calculateMedicareLevyOptimized("ClientMedicareLevy", "ClientTaxableIncome", "Client", i);

                          this.calculateTaxPayableNonRefundableOptimized("ClientTPNonRefundable", "ClientGrossTax", "ClientTotalTO", "Client", i);
                          this.calculateTaxPayableRefundableOptimized("ClientTPRefundable", "ClientTPNonRefundable", "ClientFrankingCredits", "Client", i);
                          this.calculateTotalTaxesPayableOptimized("ClientTotalTaxPayable", "ClientTPRefundable", "ClientMedicareLevy", "Client", i);
                          this.calculateAverageTaxRateOptimized("ClientAverageTaxRate", "ClientTotalTaxPayable", "ClientAssessibleIncome", "Client", i);
                          this.calculateMarginalTaxRateOptimized("ClientMarginalTaxRate", "ClientTaxableIncome", "Client", i);


                          this.calculateTotalTaxIncomeOptimized("TotalTax-partner", "Partner", i);

                          this.calculateCapitalLossAdjustmentOptimized("CLA-partner", "Partner", i);
                          this.calculateTotalAssessibleIncomeOptimized("PartnerAssessibleIncome", "TotalTax-partner", "Partner", i);
                          this.calculatePartnerTotalDeductionsOptimized("PartnerDeductions", "Partner", i);
                          this.calculatePartnerTaxableIncomeOptimized(i);
                          this.calculateLowIncomeTOOptimized("PartnerLowIncomeTO", "PartnerTaxableIncome", "Partner", i);
                          this.calculateRefundableTaxOffsetOptimized("PartnerFrankingCredits", "Partner", i);

                          this.calculatePartnerTotalNRTaxOffsetOptimized("PartnerTotalTO", "PartnerLowIncomeTO", i);
                          this.calculateGrossTaxOptimized("PartnerGrossTax", "PartnerTaxableIncome", "Partner", i);
                          this.calculateMedicareLevyOptimized("PartnerMedicareLevy", "PartnerTaxableIncome", "Partner", i);

                          this.calculateTaxPayableNonRefundableOptimized("PartnerTPNonRefundable", "PartnerGrossTax", "PartnerTotalTO", "Partner", i);
                          this.calculateTaxPayableRefundableOptimized("PartnerTPRefundable", "PartnerTPNonRefundable", "PartnerFrankingCredits", "Partner", i);
                          this.calculateTotalTaxesPayableOptimized("PartnerTotalTaxPayable", "PartnerTPRefundable", "PartnerMedicareLevy", "Partner", i);
                          this.calculateAverageTaxRateOptimized("PartnerAverageTaxRate", "PartnerTotalTaxPayable", "PartnerAssessibleIncome", "Partner", i);
                          this.calculateMarginalTaxRateOptimized("PartnerMarginalTaxRate", "PartnerTaxableIncome", "Partner", i);
                          this.calculateTotalIncomeTaxPayableOptimized("TotalITPayable", i);



                          //Calculate Cashflow Totals
                          this.calculateTotalIncomeOptimized("Total-client", "Client", i);
                          this.calculateTotalIncomeOptimized("Total-partner", "Partner", i);
                          this.calculateTotalExpenditureOptimized("Total-client", "Client", i);
                          this.calculateTotalExpenditureOptimized("Total-partner", "Partner", i);
                          this.calculateTotalExpenditureOptimized("Total-joint", "Joint", i);

                          this.calculateTotalInflowsOptimized(i);
                          this.calculateTotalOutflowsOptimized(i);
                          this.calculateNetCashflowOptimized(i);
                          this.calculateNetAssetOptimized(i);

                          //p++;
                      }
                      
                          n++;

                  }
                  }
                
              }

             
              for (var i = 0; i < this.clientDetails.period; i++) {
                  this.netAsset.forEach((x: any) => {
                      this.netAssetArray.push(x.values[this.clientDetails.startDate + i]);
                  })
              }

              for (var i = 0; i < this.clientDetails.period; i++) {
                  this.netAssetOptimized.forEach((x: any) => {
                      this.netAssetOptimizedArray.push(x.values[this.clientDetails.startDate + i]);
                  })
              }
             
              

              this.lineChartData = [{ data: this.netAssetArray, label: 'Current' },
                  { data: this.netAssetOptimizedArray, label: 'Proposed' }
             
              ];
             

                 

              //Overview Details
              //Taxable component
              this.cfiClient.forEach((x: any) => {
                  if ((x.type == "Employment" || x.type == "Centrelink" || x.type == "Taxable") && x.startDateType == "Start") {
                      var obj: any = {};
                      obj["name"] = x.cfname;
                      obj["id"] = x.cflowId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.value).toFixed();
                      this.taxableIncomes.push(obj);
                  }
              });
              this.cfiPartner.forEach((x: any) => {
                  if ((x.type == "Employment" || x.type == "Centrelink" || x.type == "Taxable") && x.startDateType == "Start") {

                      var obj: any = {};
                      obj["name"] = x.cfname;
                      obj["id"] = x.cflowId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.value).toFixed();
                      this.taxableIncomes.push(obj);
                  }
              });
              this.propertiesClient.forEach((x: any) => {
                  if ((x.rent > 0) && x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.propertyId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.rent).toFixed();
                      this.taxableIncomes.push(obj);
                  }
              });
              this.propertiesPartner.forEach((x: any) => {
                  if ((x.rent > 0) && x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.propertyId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.rent).toFixed();
                      this.taxableIncomes.push(obj);
                  }
              });
              this.propertiesJoint.forEach((x: any) => {
                  if ((x.rent > 0) && x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.propertyId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.rent).toFixed();
                      this.taxableIncomes.push(obj);
                  }
              });

              var totalTaxable : any = {};
              totalTaxable["owner"] = "TotalTaxable";
              totalTaxable["name"] = "Total Taxable";
              let TaxableSum: number = 0;
              this.taxableIncomes.forEach((x: any) => {                 
                      if (x.value != "-") {
                          var t = parseInt(x.value);
                          TaxableSum = TaxableSum + t;
                      }
              });
              totalTaxable["value"] = TaxableSum;
              this.totaltaxableIncomes.push(totalTaxable);

              //non taxable component
              this.cfiClient.forEach((x: any) => {
                  if ((x.type == "Non-Taxable" ) && x.startDateType == "Start") {
                      var obj: any = {};
                      obj["name"] = x.cfname;
                      obj["id"] = x.cflowId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.value).toFixed();
                      this.nonTaxableIncomes.push(obj);
                  }
              });
              this.cfiPartner.forEach((x: any) => {
                  if ((x.type == "Non-Taxable") && x.startDateType == "Start") {

                      var obj: any = {};
                      obj["name"] = x.cfname;
                      obj["id"] = x.cflowId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.value).toFixed();
                      this.nonTaxableIncomes.push(obj);
                  }
              });
              var totalNonTaxable: any = {};
              totalNonTaxable["owner"] = "TotalNonTaxable";
              totalNonTaxable["name"] = "Total Non-Taxable";
              let NonTaxableSum: number = 0;
              this.nonTaxableIncomes.forEach((x: any) => {
                  if (x.value != "-") {
                      var t = parseInt(x.value);
                      NonTaxableSum = NonTaxableSum + t;
                  }
              });
              totalNonTaxable["value"] = NonTaxableSum;
              this.totalnonTaxableIncomes.push(totalNonTaxable);
             
              //living

              this.cfeClient.forEach((x: any) => {
                  if (x.startDateType == "Start") {
                      var obj: any = {};
                      obj["name"] = x.cfname;
                      obj["id"] = x.cflowId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.value).toFixed();
                      this.living.push(obj);
                  }
              });
              this.cfePartner.forEach((x: any) => {
                  if (x.startDateType == "Start") {
                      var obj: any = {};
                      obj["name"] = x.cfname;
                      obj["id"] = x.cflowId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.value).toFixed();
                      this.living.push(obj);
                  }
              });
              this.cfeJoint.forEach((x: any) => {
                  if (x.startDateType == "Start") {
                      var obj: any = {};
                      obj["name"] = x.cfname;
                      obj["id"] = x.cflowId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.value).toFixed();
                      this.living.push(obj);
                  }
              });
              this.propertiesClient.forEach((x: any) => {
                  if ((x.expenses > 0) && x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.propertyId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.expenses).toFixed();
                      this.living.push(obj);
                  }
              });
              this.propertiesPartner.forEach((x: any) => {
                  if ((x.expenses > 0) && x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.propertyId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.expenses).toFixed();
                      this.living.push(obj);
                  }
              });
              this.propertiesJoint.forEach((x: any) => {
                  if ((x.expenses > 0) && x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.propertyId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.expenses).toFixed();
                      this.living.push(obj);
                  }
              });
              this.liabilityClient.forEach((x: any) => {
                  if ((x.repayment > 0) && x.commenceOnDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name + "Repayments";
                      obj["id"] = x.liabilityId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.repayment).toFixed();
                      this.living.push(obj);
                  }
              });
              this.liabilityPartner.forEach((x: any) => {
                  if ((x.repayment > 0) && x.commenceOnDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name + "Repayments";
                      obj["id"] = x.liabilityId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.repayment).toFixed();
                      this.living.push(obj);
                  }
              });
              this.liabilityJoint.forEach((x: any) => {
                  if ((x.repayment > 0) && x.commenceOnDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name + "Repayments";
                      obj["id"] = x.liabilityId;
                      obj["owner"] = x.owner;
                      obj["value"] = Number(x.repayment).toFixed();
                      this.living.push(obj);
                  }
              });

              //this.TotalPayable.forEach((x: any) => {
              //    if (x.owner == "ClientTotalTaxPayable") {
              //        var obj: any = {};
              //        obj["name"] = x.name + "Repayments";
              //        obj["id"] = x.liabilityId;
              //        obj["owner"] = x.owner;
              //        obj["value"] = Number(x.repayment).toFixed();
              //        this.living.push(obj);
              //    }
              //});

              var totalLiving: any = {};
              totalLiving["owner"] = "TotalLiving";
              totalLiving["name"] = "Total Living";
              let LivingSum: number = 0;
              this.living.forEach((x: any) => {
                  if (x.value != "-") {
                      var t = parseInt(x.value);
                      LivingSum = LivingSum + t;
                  }
              });
              totalLiving["value"] = LivingSum;
              this.totalliving.push(totalLiving);

              //assets

              this.lifestyleClient.forEach((x: any) => {
                  if (x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.lifestyleId;
                      obj["ownerDetail"] = x.owner;
                      obj["owner"] = "lifestyle";
                      obj["value"] = Number(x.value).toFixed();
                      this.lifestyleOverview.push(obj);
                  }
              });
              this.lifestylePartner.forEach((x: any) => {
                  if (x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.lifestyleId;
                      obj["ownerDetail"] = x.owner;
                      obj["owner"] = "lifestyle";
                      obj["value"] = Number(x.value).toFixed();
                      this.lifestyleOverview.push(obj);
                  }
              });
              this.lifestyleJoint.forEach((x: any) => {
                  if (x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.lifestyleId;
                      obj["ownerDetail"] = x.owner;
                      obj["owner"] = "lifestyle";
                      obj["value"] = Number(x.value).toFixed();
                      this.lifestyleOverview.push(obj);
                  }
              });

              var totalLifestyle: any = {};
              totalLifestyle["owner"] = "TotalLifestyle";
              totalLifestyle["name"] = "Total Lifestyle";
              let LifestyleSum: number = 0;
              this.lifestyleOverview.forEach((x: any) => {
                  if (x.value != "-") {
                      var t = parseInt(x.value);
                      LifestyleSum = LifestyleSum + t;
                  }
              });
              totalLifestyle["value"] = LifestyleSum;
              this.totallifestyleOverview.push(totalLifestyle);


              this.investmentClient.forEach((x: any) => {
                  if (x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.investmentId;
                      obj["ownerDetail"] = x.owner;
                      obj["owner"] = "investment";
                      obj["value"] = Number(x.value).toFixed();
                      this.investmentOverview.push(obj);
                  }
              });
              this.investmentPartner.forEach((x: any) => {
                  if (x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.investmentId;
                      obj["ownerDetail"] = x.owner;
                      obj["owner"] = "investment";
                      obj["value"] = Number(x.value).toFixed();
                      this.investmentOverview.push(obj);
                  }
              });
              this.investmentJoint.forEach((x: any) => {
                  if (x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.investmentId;
                      obj["ownerDetail"] = x.owner;
                      obj["owner"] = "investment";
                      obj["value"] = Number(x.value).toFixed();
                      this.investmentOverview.push(obj);
                  }
              });

              var totallinvestment: any = {};
              totallinvestment["owner"] = "TotalInvestment";
              totallinvestment["name"] = "Total Investment";
              let InvestmentSum: number = 0;
              this.investmentOverview.forEach((x: any) => {
                  if (x.value != "-") {
                      var t = parseInt(x.value);
                      InvestmentSum = InvestmentSum + t;
                  }
              });
              totallinvestment["value"] = InvestmentSum;
              this.totalinvestmentOverview.push(totallinvestment);


              this.superClient.forEach((x: any) => {
                  if (x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.superId;
                      obj["ownerDetail"] = x.owner;
                      obj["owner"] = "super";
                      obj["value"] = Number(x.value).toFixed();
                      this.superOverview.push(obj);
                  }
              });
              this.superPartner.forEach((x: any) => {
                  if (x.startDateType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.superId;
                      obj["ownerDetail"] = x.owner;
                      obj["owner"] = "super";
                      obj["value"] = Number(x.value).toFixed();
                      this.superOverview.push(obj);
                  }
              });

              var totalSuper: any = {};
              totalSuper["owner"] = "TotalSuper";
              totalSuper["name"] = "Total Super";
              let SuperSum: number = 0;
              this.superOverview.forEach((x: any) => {
                  if (x.value != "-") {
                      var t = parseInt(x.value);
                      SuperSum = SuperSum + t;
                  }
              });
              totalSuper["value"] = SuperSum;
              this.totalsuperOverview.push(totalSuper);

              this.pensionClient.forEach((x: any) => {
                  if (x.pensionRebootFromType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.pensionId;
                      obj["ownerDetail"] = x.owner;
                      obj["owner"] = "pension";
                      obj["value"] = Number(x.value).toFixed();
                      this.pensionOverview.push(obj);
                  }
              });
              this.pensionPartner.forEach((x: any) => {
                  if (x.pensionRebootFromType == "Existing") {
                      var obj: any = {};
                      obj["name"] = x.name;
                      obj["id"] = x.pensionId;
                      obj["ownerDetail"] = x.owner;
                      obj["owner"] = "pension";
                      obj["value"] = Number(x.value).toFixed();
                      this.pensionOverview.push(obj);
                  }
              });

              var totalPension: any = {};
              totalPension["owner"] = "TotalSuper";
              totalPension["name"] = "Total Super";
              let PensionSum: number = 0;
              this.pensionOverview.forEach((x: any) => {
                  if (x.value != "-") {
                      var t = parseInt(x.value);
                      PensionSum = PensionSum + t;
                  }
              });
              totalPension["value"] = PensionSum;
              this.totalpensionOverview.push(totalPension);

          }

      }, err => {
          if (err.status == 404)
              this.router.navigate(['/home']);
      });




      this.setYear();
      this.setClientAge();
      if (this.clientDetails.maritalStatus == 'M') {
          this.setPartnerAge();
      }

      $(document).ready(function () {
          $('.header').click(function () {
              $(this).nextUntil('tr.header').toggle();
              $(this).find("span:eq(0)").toggleClass("glyphicon-chevron-down").toggleClass("glyphicon-chevron-up");
          });

      });

     
  }

  

  private setFinancialAssetList(owner: string) {

      var indexRange: any = [];
      let List: any;
      if (owner == "Client") {
          List = this.investmentClient;
      }
      else if (owner == "Partner") {
          List = this.investmentPartner;
      }
      else {
          List = this.investmentJoint;
      }
     
     
      for (var i = 0; i < List.length; i++) {
          var obj: any = {};
          obj["id"] = List[i].investmentId;
          obj["name"] = List[i].name;
          indexRange.push(obj);
      }
      this.financialAssetList = indexRange;
     
  }

 
  //Common functions
  private setYear() {
      var range = [];
      range.push(this.clientDetails.startDate);
      for (var i = 1; i < this.clientDetails.period; i++) {
          range.push(this.clientDetails.startDate + i);
      }

      this.years = range;
  }
  private setClientAge() {
      var date1 = new Date("7/01/ " + this.clientDetails.startDate);
      var date2 = new Date(this.clientDetails.clientDob);
      var timeDiff = Math.abs(date2.getTime() - date1.getTime());
      var diffDays = (Math.ceil(timeDiff / (1000 * 3600 * 24))) / 365;

      this.clientAge = Math.round(diffDays * 10) / 10;

  }
  private setPartnerAge() {

      var date1 = new Date("7/01/ " + this.clientDetails.startDate);
      var date2 = new Date(this.clientDetails.partnerDob);
      var timeDiff = Math.abs(date2.getTime() - date1.getTime());
      var diffDays = (Math.ceil(timeDiff / (1000 * 3600 * 24))) / 365;

      this.partnerAge = Math.round(diffDays * 10) / 10;
  }

  //Cashflow functions
  private calculateTotalIncome(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.inflow.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Income";


          let sum: number = 0;
          this.inflow.forEach((x: any) => {
              if (x.owner == filter) {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });
          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;


          if (this.inflow.find((y: any) => y.owner === owner) != null) {
              this.inflow[this.inflow.findIndex((c: any) => c.owner === owner)] = total;
              this.Income[this.Income.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.inflow.push(total);
              this.Income.push(total);
          }
      }
  }
  private calculateTotalExpenditure(owner: string, filter: string , iVal: number) {
           for (var i = 0; i <= iVal; i++) {
          var total = this.outflow.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Expenditure";


          let sum: number = 0;
          this.outflow.forEach((x: any) => {
              if (x.owner == filter) {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });
          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;


          if (this.outflow.find((y: any) => y.owner === owner) != null) {
              this.outflow[this.outflow.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.outflow.push(total);
          }
      }
  }
  private calculateTotalInflows(iVal: number) {

      for (var i = 0; i <= iVal; i++) {
          var total = this.inflow.find((y: any) => y.owner === "Inflow");
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = "Inflow";
          total["name"] = "Inflow";

          let sum: number = 0;
          this.inflow.forEach((x: any) => {
              if (x.owner == "Total-client" || x.owner == "Total-partner") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.FAtotal.forEach((y: any) => {
              if (y.owner == "TotalIPO" || y.owner == "TotalIW") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });

          this.Propertiestotal.forEach((y: any) => {
              if (y.owner == "TotalRent" || y.owner == "TotalSaleProceeds") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });

          this.Pensiontotal.forEach((y: any) => {
              if (y.owner == "TotalPensionIncome") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });

          this.Supertotal.forEach((y: any) => {
              if (y.owner == "TotalLumpSumWithdrawals") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });

          this.LATotal.forEach((y: any) => {
              if (y.owner == "TotalLASales") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.inflow.find((y: any) => y.owner === "Inflow") != null) {
              this.inflow[this.inflow.findIndex((c: any) => c.owner === "Inflow")] = total;
          }
          else {
              this.inflow.push(total);
          }
      }
  }
  private calculateTotalOutflows(iVal: number) {

      for (var i = 0; i <= iVal; i++) {
          var total = this.outflow.find((y: any) => y.owner === "Outflow");
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }

          total["owner"] = "Outflow";
          total["name"] = "Outflow";

          let sum: number = 0;
          this.outflow.forEach((x: any) => {
              if (x.owner == "Total-client" || x.owner == "Total-partner" || x.owner == "Total-joint") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });
          this.FAtotal.forEach((y: any) => {
              if (y.owner == "TotalITPayable" || y.owner == "TotalIC") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });
          this.Propertiestotal.forEach((y: any) => {
              if (y.owner == "TotalPropertyExpenses") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val1 = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val1;
                  }
              }
          });
          this.Supertotal.forEach((y: any) => {
              if (y.owner == "TotalSalarySacrificeContributions" || y.owner == "TotalPNCContributions" || y.owner == "TotalSpouseContributions") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val1 = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val1;
                  }
              }
          });
          this.LBtotal.forEach((y: any) => {
              if (y.owner == "TotalDebtRepayment") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val1 = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val1;
                  }
              }
          });

          this.LATotal.forEach((y: any) => {
              if (y.owner == "TotalLAPurchase") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.outflow.find((y: any) => y.owner === "Outflow") != null) {
              this.outflow[this.outflow.findIndex((c: any) => c.owner === "Outflow")] = total;
          }
          else {
              this.outflow.push(total);
          }
      }



    }
    private calculateNetCashflow(iVal: number, q: number, id: number) {
      var inflow = this.inflow.filter(c => c.name === "Inflow");
      var outflow = this.outflow.filter(c => c.name === "Outflow");


      for (var i = 0; i <= iVal; i++) {
          var total = this.netCashFlow.find((y: any) => y.owner === "NetCashflow");
          var totalVal: any = {};
          var assetAllocation: any = {};
          var unfundedNetCF: any = {};
          if (total == null) {
              total = {};
              assetAllocation = {};
              unfundedNetCF = {};
          }
          else {
              totalVal = total.values;
              assetAllocation = total.assetAllocationValues;
              unfundedNetCF = total.unfundedNetCFValues;
          }

          total["owner"] = "NetCashflow";
          total["name"] = "NetCashflow";

          var diff = 0;
          if (typeof inflow[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(inflow[0].values[this.clientDetails.startDate + i]) && typeof outflow[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(outflow[0].values[this.clientDetails.startDate + i])) {
              diff = inflow[0].values[this.clientDetails.startDate + i] - outflow[0].values[this.clientDetails.startDate + i];
          }




          //Cash Surplus Check

          //if (diff > 0) {
          //    this.investmentDetails.growth = this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].growth;
          //    this.investmentDetails.income = this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].income;
          //    this.investmentDetails.franked = this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].franking;
          //    this.investmentDetails.productFees = this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].productFees;


          //    if (this.clientDetails.maritalStatus == "S") {
          //        var ClientInvestment = this.investmentClient.filter((c: any) => c.type === "Domestic Cash");
          //        if (ClientInvestment == null || ClientInvestment.length == 0) {
          //            this.investmentDetails.owner = "Client";
          //            this.investmentService.create(this.investmentDetails, [], this.clientDetails.clientId).subscribe((data) => {
                         

          //                this.investmentDetails = {
          //                    investmentId: 0,
          //                    clientId: 0,
          //                    type: '',
          //                    name: '',
          //                    owner: '',
          //                    value: 0,
          //                    growth: 0.00,
          //                    income: 0.00,
          //                    franked: 0.00,
          //                    productFees: 0.0000,
          //                    costBase: 0,
          //                    reinvest: 'Y',
          //                    centrelink: 'N',
          //                    startDateType: 'Existing',
          //                    startDate: 0,
          //                    endDateType: 'Retain',
          //                    endDate: 0
          //                };



          //            });
                      
          //        }
                
          //    } else {
          //        var JointInvestment = this.investmentJoint.filter((c: any) => c.type === "Domestic Cash");
          //        var PartnerInvestment = this.investmentPartner.filter((c: any) => c.type === "Domestic Cash");
          //        var ClientInvestment = this.investmentClient.filter((c: any) => c.type === "Domestic Cash");

          //        if ((ClientInvestment == null && PartnerInvestment == null && JointInvestment == null) || (ClientInvestment.length == 0 && PartnerInvestment.length == 0 && JointInvestment.length == 0)) {
          //            this.investmentDetails.owner = "Joint";
          //            this.investmentService.create(this.investmentDetails, [], this.clientDetails.clientId).subscribe((data) => {
          //                this.investmentService.getInvestments(this.clientDetails.clientId).subscribe(
          //                    investments => {
          //                        this.investments = investments;
          //                        this.investmentClient = this.investments.filter(c => c.owner === "Client");
          //                        this.investmentPartner = this.investments.filter(c => c.owner === "Partner");
          //                        this.investmentJoint = this.investments.filter(c => c.owner === "Joint");

          //                    }
          //                );

          //                this.investmentDetails = {
          //                    investmentId: 0,
          //                    clientId: 0,
          //                    type: '',
          //                    name: '',
          //                    owner: '',
          //                    value: 0,
          //                    growth: 0.00,
          //                    income: 0.00,
          //                    franked: 0.00,
          //                    productFees: 0.0000,
          //                    costBase: 0,
          //                    reinvest: 'Y',
          //                    centrelink: 'N',
          //                    startDateType: 'Existing',
          //                    startDate: 0,
          //                    endDateType: 'Retain',
          //                    endDate: 0
          //                };
          //            });
          //        }
          //    }
          //    //Observable.forkJoin([this.investmentService.getInvestments(this.clientDetails.clientId)]).subscribe(
          //    //    investments => {
          //    //        this.investments = investments;
          //    //        this.investmentClient = this.investments.filter(c => c.owner === "Client");
          //    //        this.investmentPartner = this.investments.filter(c => c.owner === "Partner");
          //    //        this.investmentJoint = this.investments.filter(c => c.owner === "Joint");

          //    //    }
          //    //);

          //}
          //obj["owner"] = x.investmentId;
          if (q == 1) {
              var res = this.BeginningValue.find((y: any) => y.owner === id);
              if (diff > 0) {
                  totalVal[this.clientDetails.startDate + i] = diff;
                  assetAllocation[this.clientDetails.startDate + i] = diff * -1;
                  unfundedNetCF[this.clientDetails.startDate + i] = (totalVal[this.clientDetails.startDate + i] + assetAllocation[this.clientDetails.startDate + i]);
              } else if (diff < 0) {
                  totalVal[this.clientDetails.startDate + i] = diff;
                  assetAllocation[this.clientDetails.startDate + i] = (res.cashFlowValues[this.clientDetails.startDate + i]) * -1;
                  unfundedNetCF[this.clientDetails.startDate + i] = (totalVal[this.clientDetails.startDate + i] + assetAllocation[this.clientDetails.startDate + i]);;
              }
              else {
                  assetAllocation[this.clientDetails.startDate + i] = "-";
                  unfundedNetCF[this.clientDetails.startDate + i] = "-";
                  totalVal[this.clientDetails.startDate + i] = "-";
              }
          }
          else {
              if (diff > 0) {
                  totalVal[this.clientDetails.startDate + i] = diff;
                  assetAllocation[this.clientDetails.startDate + i] = diff * -1;
                  unfundedNetCF[this.clientDetails.startDate + i] = (totalVal[this.clientDetails.startDate + i] + assetAllocation[this.clientDetails.startDate + i]);
              } else if (diff < 0) {
                  totalVal[this.clientDetails.startDate + i] = diff;
                  assetAllocation[this.clientDetails.startDate + i] = 0;
                  unfundedNetCF[this.clientDetails.startDate + i] = (totalVal[this.clientDetails.startDate + i] + assetAllocation[this.clientDetails.startDate + i]);;
              }
              else {
                  assetAllocation[this.clientDetails.startDate + i] = "-";
                  unfundedNetCF[this.clientDetails.startDate + i] = "-";
                  totalVal[this.clientDetails.startDate + i] = "-";
              }
          }
          total["values"] = totalVal;
          total["assetAllocationValues"] = assetAllocation;
          total["unfundedNetCFValues"] = unfundedNetCF;
        

          if (this.netCashFlow.find((y: any) => y.owner === "NetCashflow") != null) {
              this.netCashFlow[this.netCashFlow.findIndex((c: any) => c.owner === "NetCashflow")] = total;
          }
          else {
              this.netCashFlow.push(total);
          }

      }

      
  }

  private calculateNetAsset(iVal: number) {
    

      for (var i = 0; i <= iVal; i++) {
          var total = this.netAsset.find((y: any) => y.owner === "NetAsset");
          var totalVal: any = {};
        
          if (total == null) {
              total = {};
            
          }
          else {
              totalVal = total.values;
             
          }

          total["owner"] = "NetAsset";
          total["name"] = "NetAsset";

          var result = 0;
          this.BeginningValue.forEach((x: any) => {        
              if (x.endingValues[this.clientDetails.startDate + i] != "-") {
                  var t = parseInt(x.endingValues[this.clientDetails.startDate + i]);
                  result = result + t;
                  }
          });

          this.PropertiesValue.forEach((x: any) => {
              if (x.endingValues[this.clientDetails.startDate + i] != "-") {
                  var t = parseInt(x.endingValues[this.clientDetails.startDate + i]);
                  result = result + t;
              }
          });

          this.SuperValue.forEach((x: any) => {
              if (x.endingValues[this.clientDetails.startDate + i] != "-") {
                  var t = parseInt(x.endingValues[this.clientDetails.startDate + i]);
                  result = result + t;
              }
          });

          this.PensionValue.forEach((x: any) => {
              if (x.endingValues[this.clientDetails.startDate + i] != "-") {
                  var t = parseInt(x.endingValues[this.clientDetails.startDate + i]);
                  result = result + t;
              }
          });

          this.LBValue.forEach((x: any) => {
              if (x.endingValues[this.clientDetails.startDate + i] != "-") {
                  var t = parseInt(x.endingValues[this.clientDetails.startDate + i]);
                  result = result - t;
              }
          });

          if (result > 0) {
              totalVal[this.clientDetails.startDate + i] = result;
            
          } else if (result < 0) {
              totalVal[this.clientDetails.startDate + i] = result;
             
          }
          else {
             
              totalVal[this.clientDetails.startDate + i] = "-";
          }
          total["values"] = totalVal;
         

          if (this.netAsset.find((y: any) => y.owner === "NetAsset") != null) {
              this.netAsset[this.netAsset.findIndex((c: any) => c.owner === "NetAsset")] = total;
          }
          else {
              this.netAsset.push(total);
          }

      }


  }

  private calculateNetAssetOptimized(iVal: number) {


      for (var i = 0; i <= iVal; i++) {
          var total = this.netAssetOptimized.find((y: any) => y.owner === "NetAsset");
          var totalVal: any = {};

          if (total == null) {
              total = {};

          }
          else {
              totalVal = total.values;

          }

          total["owner"] = "NetAsset";
          total["name"] = "NetAsset";

          var result = 0;
          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.endingValues[this.clientDetails.startDate + i] != "-") {
                  var t = parseInt(x.endingValues[this.clientDetails.startDate + i]);
                  result = result + t;
              }
          });

          this.PropertiesValueOptimized.forEach((x: any) => {
              if (x.endingValues[this.clientDetails.startDate + i] != "-") {
                  var t = parseInt(x.endingValues[this.clientDetails.startDate + i]);
                  result = result + t;
              }
          });

          this.SuperValueOptimized.forEach((x: any) => {
              if (x.endingValues[this.clientDetails.startDate + i] != "-") {
                  var t = parseInt(x.endingValues[this.clientDetails.startDate + i]);
                  result = result + t;
              }
          });

          this.PensionValueOptimized.forEach((x: any) => {
              if (x.endingValues[this.clientDetails.startDate + i] != "-") {
                  var t = parseInt(x.endingValues[this.clientDetails.startDate + i]);
                  result = result + t;
              }
          });

          this.LBValueOptimized.forEach((x: any) => {
              if (x.endingValues[this.clientDetails.startDate + i] != "-") {
                  var t = parseInt(x.endingValues[this.clientDetails.startDate + i]);
                  result = result - t;
              }
          });

          var cashflow = this.netCashFlowOptimized.find((y: any) => y.owner === "NetCashflow");
          if (cashflow.values[this.clientDetails.startDate + i] > 0) {
              result += cashflow.values[this.clientDetails.startDate + i];
          }
          if (result > 0) {
              totalVal[this.clientDetails.startDate + i] = result;

          } else if (result < 0) {
              totalVal[this.clientDetails.startDate + i] = result;

          }
          else {

              totalVal[this.clientDetails.startDate + i] = "-";
          }

         


          total["values"] = totalVal;



          if (this.netAssetOptimized.find((y: any) => y.owner === "NetAsset") != null) {
              this.netAssetOptimized[this.netAssetOptimized.findIndex((c: any) => c.owner === "NetAsset")] = total;
          }
          else {
              this.netAssetOptimized.push(total);
          }

      }


  }
  //Cashflow functions C
  private calculateTotalIncomeOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.inflowOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Income";


          let sum: number = 0;
          this.inflowOptimized.forEach((x: any) => {
              if (x.owner == filter) {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });
          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;


          if (this.inflowOptimized.find((y: any) => y.owner === owner) != null) {
              this.inflowOptimized[this.inflowOptimized.findIndex((c: any) => c.owner === owner)] = total;
              this.IncomeOptimized[this.IncomeOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.inflowOptimized.push(total);
              this.IncomeOptimized.push(total);
          }
      }
  }
  private calculateTotalExpenditureOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.outflowOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Expenditure";


          let sum: number = 0;
          this.outflowOptimized.forEach((x: any) => {
              if (x.owner == filter) {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });
          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;


          if (this.outflowOptimized.find((y: any) => y.owner === owner) != null) {
              this.outflowOptimized[this.outflowOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.outflowOptimized.push(total);
          }
      }
  }
  private calculateTotalInflowsOptimized(iVal: number) {

      for (var i = 0; i <= iVal; i++) {
          var total = this.inflowOptimized.find((y: any) => y.owner === "Inflow");
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = "Inflow";
          total["name"] = "Inflow";

          let sum: number = 0;
          this.inflowOptimized.forEach((x: any) => {
              if (x.owner == "Total-client" || x.owner == "Total-partner") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.FAtotalOptimized.forEach((y: any) => {
              if (y.owner == "TotalIPO" || y.owner == "TotalIW") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });

          this.PropertiestotalOptimized.forEach((y: any) => {
              if (y.owner == "TotalRent" || y.owner == "TotalSaleProceeds") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });

          this.PensiontotalOptimized.forEach((y: any) => {
              if (y.owner == "TotalPensionIncome") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });

          this.SupertotalOptimized.forEach((y: any) => {
              if (y.owner == "TotalLumpSumWithdrawals") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });

          this.LATotalOptimized.forEach((y: any) => {
              if (y.owner == "TotalLASales") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.inflowOptimized.find((y: any) => y.owner === "Inflow") != null) {
              this.inflowOptimized[this.inflowOptimized.findIndex((c: any) => c.owner === "Inflow")] = total;
          }
          else {
              this.inflowOptimized.push(total);
          }
      }
  }
  private calculateTotalOutflowsOptimized(iVal: number) {

      for (var i = 0; i <= iVal; i++) {
          var total = this.outflowOptimized.find((y: any) => y.owner === "Outflow");
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }

          total["owner"] = "Outflow";
          total["name"] = "Outflow";

          let sum: number = 0;
          this.outflowOptimized.forEach((x: any) => {
              if (x.owner == "Total-client" || x.owner == "Total-partner" || x.owner == "Total-joint") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });
          this.FAtotalOptimized.forEach((y: any) => {
              if (y.owner == "TotalITPayable" || y.owner == "TotalIC") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });
          this.PropertiestotalOptimized.forEach((y: any) => {
              if (y.owner == "TotalPropertyExpenses") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val1 = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val1;
                  }
              }
          });
          this.SupertotalOptimized.forEach((y: any) => {
              if (y.owner == "TotalSalarySacrificeContributions" || y.owner == "TotalPNCContributions" || y.owner == "TotalSpouseContributions") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val1 = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val1;
                  }
              }
          });
          this.LBtotalOptimized.forEach((y: any) => {
              if (y.owner == "TotalDebtRepayment") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val1 = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val1;
                  }
              }
          });

          this.LATotalOptimized.forEach((y: any) => {
              if (y.owner == "TotalLAPurchase") {
                  if (y.values[this.clientDetails.startDate + i] != "-") {
                      var val = parseInt(y.values[this.clientDetails.startDate + i]);
                      sum = sum + val;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.outflowOptimized.find((y: any) => y.owner === "Outflow") != null) {
              this.outflowOptimized[this.outflowOptimized.findIndex((c: any) => c.owner === "Outflow")] = total;
          }
          else {
              this.outflowOptimized.push(total);
          }
      }



  }
  private calculateNetCashflowOptimized(iVal: number) {
      var inflow = this.inflowOptimized.filter(c => c.name === "Inflow");
      var outflow = this.outflowOptimized.filter(c => c.name === "Outflow");


      for (var i = 0; i <= iVal; i++) {
          var total = this.netCashFlowOptimized.find((y: any) => y.owner === "NetCashflow");
          var totalVal: any = {};
          var assetAllocation: any = {};
          var unfundedNetCF: any = {};
          if (total == null) {
              total = {};
              assetAllocation = {};
              unfundedNetCF = {};
          }
          else {
              totalVal = total.values;
              assetAllocation = total.assetAllocationValues;
              unfundedNetCF = total.unfundedNetCFValues;
          }

          total["owner"] = "NetCashflow";
          total["name"] = "NetCashflow";

          var diff = 0;
          if (typeof inflow[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(inflow[0].values[this.clientDetails.startDate + i]) && typeof outflow[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(outflow[0].values[this.clientDetails.startDate + i])) {
              diff = inflow[0].values[this.clientDetails.startDate + i] - outflow[0].values[this.clientDetails.startDate + i];
          }




          //Cash Surplus Check

          //if (diff > 0) {
          //    this.investmentDetails.growth = this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].growth;
          //    this.investmentDetails.income = this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].income;
          //    this.investmentDetails.franked = this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].franking;
          //    this.investmentDetails.productFees = this.assetAssumptions.filter((a: any) => a.name == "Domestic Cash")[0].productFees;


          //    if (this.clientDetails.maritalStatus == "S") {
          //        var ClientInvestment = this.investmentClient.filter((c: any) => c.type === "Domestic Cash");
          //        if (ClientInvestment == null || ClientInvestment.length == 0) {
          //            this.investmentDetails.owner = "Client";
          //            this.investmentService.create(this.investmentDetails, [], this.clientDetails.clientId).subscribe((data) => {


          //                this.investmentDetails = {
          //                    investmentId: 0,
          //                    clientId: 0,
          //                    type: '',
          //                    name: '',
          //                    owner: '',
          //                    value: 0,
          //                    growth: 0.00,
          //                    income: 0.00,
          //                    franked: 0.00,
          //                    productFees: 0.0000,
          //                    costBase: 0,
          //                    reinvest: 'Y',
          //                    centrelink: 'N',
          //                    startDateType: 'Existing',
          //                    startDate: 0,
          //                    endDateType: 'Retain',
          //                    endDate: 0
          //                };



          //            });

          //        }

          //    } else {
          //        var JointInvestment = this.investmentJoint.filter((c: any) => c.type === "Domestic Cash");
          //        var PartnerInvestment = this.investmentPartner.filter((c: any) => c.type === "Domestic Cash");
          //        var ClientInvestment = this.investmentClient.filter((c: any) => c.type === "Domestic Cash");

          //        if ((ClientInvestment == null && PartnerInvestment == null && JointInvestment == null) || (ClientInvestment.length == 0 && PartnerInvestment.length == 0 && JointInvestment.length == 0)) {
          //            this.investmentDetails.owner = "Joint";
          //            this.investmentService.create(this.investmentDetails, [], this.clientDetails.clientId).subscribe((data) => {
          //                this.investmentService.getInvestments(this.clientDetails.clientId).subscribe(
          //                    investments => {
          //                        this.investments = investments;
          //                        this.investmentClient = this.investments.filter(c => c.owner === "Client");
          //                        this.investmentPartner = this.investments.filter(c => c.owner === "Partner");
          //                        this.investmentJoint = this.investments.filter(c => c.owner === "Joint");

          //                    }
          //                );

          //                this.investmentDetails = {
          //                    investmentId: 0,
          //                    clientId: 0,
          //                    type: '',
          //                    name: '',
          //                    owner: '',
          //                    value: 0,
          //                    growth: 0.00,
          //                    income: 0.00,
          //                    franked: 0.00,
          //                    productFees: 0.0000,
          //                    costBase: 0,
          //                    reinvest: 'Y',
          //                    centrelink: 'N',
          //                    startDateType: 'Existing',
          //                    startDate: 0,
          //                    endDateType: 'Retain',
          //                    endDate: 0
          //                };
          //            });
          //        }
          //    }
          //    //Observable.forkJoin([this.investmentService.getInvestments(this.clientDetails.clientId)]).subscribe(
          //    //    investments => {
          //    //        this.investments = investments;
          //    //        this.investmentClient = this.investments.filter(c => c.owner === "Client");
          //    //        this.investmentPartner = this.investments.filter(c => c.owner === "Partner");
          //    //        this.investmentJoint = this.investments.filter(c => c.owner === "Joint");

          //    //    }
          //    //);

          //}

          if (diff > 0) {
              totalVal[this.clientDetails.startDate + i] = diff;
              assetAllocation[this.clientDetails.startDate + i] = diff;
              unfundedNetCF[this.clientDetails.startDate + i] = 0;
          } else if (diff < 0) {
              totalVal[this.clientDetails.startDate + i] = diff;
              assetAllocation[this.clientDetails.startDate + i] = 0;
              unfundedNetCF[this.clientDetails.startDate + i] = diff;
          }
          else {
              assetAllocation[this.clientDetails.startDate + i] = "-";
              unfundedNetCF[this.clientDetails.startDate + i] = "-";
              totalVal[this.clientDetails.startDate + i] = "-";
          }
          total["values"] = totalVal;
          total["assetAllocationValues"] = assetAllocation;
          total["unfundedNetCFValues"] = unfundedNetCF;


          if (this.netCashFlowOptimized.find((y: any) => y.owner === "NetCashflow") != null) {
              this.netCashFlowOptimized[this.netCashFlowOptimized.findIndex((c: any) => c.owner === "NetCashflow")] = total;
          }
          else {
              this.netCashFlowOptimized.push(total);
          }

      }


  }
  //Tax functions
     
  private calculateTotalTaxIncome(owner: string, filter: string, iVal: number) {

      for (var i = 0; i <= iVal; i++) {
          var total = this.Income.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Income";

          let sum: number = 0;


          if (filter == "Client") {

              this.inflow.forEach((x: any) => {
                  if (x.owner == "ClientIncome-tax") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });


              this.FAtotal.forEach((x: any) => {
                  if (x.owner == "TotalTaxIE-client") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });

              this.FAtotal.forEach((x: any) => {
                  if (x.owner == "FrankingCredits-client") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
              this.Pensiontotal.forEach((x: any) => {
                  if (x.owner == "PensionIncome-client") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });

          }
          else {

              this.inflow.forEach((x: any) => {
                  if (x.owner == "PartnerIncome-tax") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });

              this.FAtotal.forEach((x: any) => {
                  if (x.owner == "TotalTaxIE-partner") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });

              this.FAtotal.forEach((x: any) => {
                  if (x.owner == "FrankingCredits-partner") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });

              this.Pensiontotal.forEach((x: any) => {
                  if (x.owner == "PensionIncome-partner") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
          }


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.Income.find((y: any) => y.owner === owner) != null) {
              this.Income[this.Income.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Income.push(total);
          }
      }
  }
  private calculateCapitalLossAdjustment(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Propertiestotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Capital loss adjustment";

          let AccumCL: number = 0;
          if (filter == "Client") {


              let SumCG: number = 0;
              let SumCL: number = 0;

              this.FAtotal.forEach((x: any) => {
                  if (x.owner == "RCGFA-client") {
                      if (x.values[this.clientDetails.startDate + i] >= 0) {
                          SumCG = SumCG + Number(x.values[this.clientDetails.startDate + i]);

                      }
                      else if (x.values[this.clientDetails.startDate + i] < 0) {
                          SumCL = SumCL + Number(x.values[this.clientDetails.startDate + i]);
                      }
                  }
              });

              this.PropertiesValue.forEach((x: any) => {
                  if (x.owner == "RCGP-client") {
                      if (x.values[this.clientDetails.startDate + i] >= 0) {
                          SumCG = SumCG + Number(x.values[this.clientDetails.startDate + i]);

                      }
                      else if (x.values[this.clientDetails.startDate + i] < 0) {
                          SumCL = SumCL + Number(x.values[this.clientDetails.startDate + i]);
                      }
                  }
              });


              AccumCL = AccumCL + SumCL;

              var t = SumCG + AccumCL;
              var CLA: number = 0;
              if (t >= 0) {
                  CLA = AccumCL;
                  AccumCL = 0;
              }
              else if (t < 0) {
                  CLA = Number(SumCG) * (-1);
                  AccumCL = SumCG - AccumCL;
              }

              totalVal[this.clientDetails.startDate + i] = CLA.toFixed();
              total["values"] = totalVal;


          }
          else {


              let SumCG: number = 0;
              let SumCL: number = 0;

              this.FAtotal.forEach((x: any) => {
                  if (x.owner == "RCGFA-partner") {
                      if (x.values[this.clientDetails.startDate + i] >= 0) {
                          SumCG = SumCG + Number(x.values[this.clientDetails.startDate + i]);

                      }
                      else if (x.values[this.clientDetails.startDate + i] < 0) {
                          SumCL = SumCL + Number(x.values[this.clientDetails.startDate + i]);
                      }
                  }
              });

              this.PropertiesValue.forEach((x: any) => {
                  if (x.owner == "RCGP-partner") {
                      if (x.values[this.clientDetails.startDate + i] >= 0) {
                          SumCG = SumCG + Number(x.values[this.clientDetails.startDate + i]);

                      }
                      else if (x.values[this.clientDetails.startDate + i] < 0) {
                          SumCL = SumCL + Number(x.values[this.clientDetails.startDate + i]);
                      }
                  }
              });


              AccumCL = AccumCL + SumCL;

              var t = SumCG + AccumCL;
              var CLA: number = 0;
              if (t >= 0) {
                  CLA = AccumCL;
                  AccumCL = 0;
              }
              else if (t < 0) {
                  CLA = Number(SumCG) * (-1);
                  AccumCL = SumCG - AccumCL;
              }

              totalVal[this.clientDetails.startDate + i] = CLA.toFixed();
              total["values"] = totalVal;
          }

          if (this.Propertiestotal.find((y: any) => y.owner === owner) != null) {
              this.Propertiestotal[this.Propertiestotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Propertiestotal.push(total);
          }
      }




  }
  private calculateTotalAssessibleIncome(owner: string, filter: string, type: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Income.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "ClientAssessibleIncome";

          let sum: number = 0;
          this.Income.forEach((x: any) => {
              if (x.owner == filter) {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          if (type == "Client") {
              this.FAtotal.forEach((x: any) => {
                  if (x.owner == "RCGFA-client") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
              this.Propertiestotal.forEach((x: any) => {
                  if (x.owner == "RCGP-client" || x.owner == "CLA-client") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
              this.Supertotal.forEach((x: any) => {
                  if (x.owner == "LumpSum-client") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
          }
          else {
              this.FAtotal.forEach((x: any) => {
                  if (x.owner == "RCGFA-partner") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
              this.Propertiestotal.forEach((x: any) => {
                  if (x.owner == "RCGP-partner" || x.owner == "CLA-partner") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
              this.Supertotal.forEach((x: any) => {
                  if (x.owner == "LumpSum-partner") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
          }


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.Income.find((y: any) => y.owner === owner) != null) {
              this.Income[this.Income.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Income.push(total);
          }

      }

  }
  private calculateClientTotalDeductions(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.ClientDeductions.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
      total["owner"] = owner;
      total["name"] = owner;
     
          let sum: number = 0;
          this.ClientDeductions.forEach((x: any) => {
              if (x.owner == filter || x.owner == "Joint") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.Propertiestotal.forEach((x: any) => {
              if (x.owner == "InvestmentPropertyExpenses-client") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.Supertotal.forEach((x: any) => {
              if (x.owner == "SalarySacrifice-client") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.LBtotal.forEach((x: any) => {
              if (x.owner == "Accruedliability-client") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.ClientDeductions.find((y: any) => y.owner === owner) != null) {
              this.ClientDeductions[this.ClientDeductions.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.ClientDeductions.push(total);
          }
      }

     
  }
  private calculatePartnerTotalDeductions(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.PartnerDeductions.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = owner;

          let sum: number = 0;
          this.PartnerDeductions.forEach((x: any) => {
              if (x.owner == filter || x.owner == "Joint") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.Propertiestotal.forEach((x: any) => {
              if (x.owner == "InvestmentPropertyExpenses-partner") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.Supertotal.forEach((x: any) => {
              if (x.owner == "SalarySacrifice-partner") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.LBtotal.forEach((x: any) => {
              if (x.owner == "Accruedliability-partner") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.PartnerDeductions.find((y: any) => y.owner === owner) != null) {
              this.PartnerDeductions[this.PartnerDeductions.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.PartnerDeductions.push(total);
          }
      }
    
  }
  private calculateClientTaxableIncome(iVal: number) {

      let lossBF: number = 0;
      let lossAdj: number = 0;
      var income = this.Income.filter(c => c.owner === "ClientAssessibleIncome");
      var deduction = this.ClientDeductions.filter(c => c.owner === "ClientDeductions");


      for (var i = 0; i <= iVal; i++) {
          var taxable = this.clientTaxableIncome.find((y: any) => y.owner === "ClientTaxableIncome");
          var taxableVal: any = {};
          if (taxable == null) {
              taxable = {};
          }
          else {
              taxableVal = taxable.values;
          }

          var adjustment = this.clientLossAdjustment.find((y: any) => y.owner === "ClientAdjustment");
          var adjustmentVal: any = {};
          if (adjustment == null) {
              adjustment = {};
          }
          else {
              adjustmentVal = adjustment.values;
          }
          taxable["owner"] = "ClientTaxableIncome";
          taxable["name"] = "ClientTaxableIncome";
          adjustment["owner"] = "ClientAdjustment";
          adjustment["name"] = "ClientAdjustment";

          //Gti stands for Gross taxable income
          let lossG: number = 0;
          let taxInc: number = 0;

          if (typeof income[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(income[0].values[this.clientDetails.startDate + i]) && typeof deduction[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(deduction[0].values[this.clientDetails.startDate + i])) {

              let Gti: number = Math.max(0, (income[0].values[this.clientDetails.startDate + i] - deduction[0].values[this.clientDetails.startDate + i]));
              if (Gti > 0) {
                  lossAdj = Math.min(lossBF, Gti);
              }


              if (deduction[0].values[this.clientDetails.startDate + i] > income[0].values[this.clientDetails.startDate + i]) {
                  lossG = deduction[0].values[this.clientDetails.startDate + i] - income[0].values[this.clientDetails.startDate + i];
              }

              //LossCF stands for Loss carried forward
              let lossCF: number = lossG + lossBF - lossAdj;
              lossBF = lossCF;

              taxInc = Gti - lossAdj;

          }

          if (lossAdj > 0) {
              adjustmentVal[this.clientDetails.startDate + i] = lossAdj;
          }
          else {
              adjustmentVal[this.clientDetails.startDate + i] = 0;
          }
          adjustment["values"] = adjustmentVal;

          if (this.clientLossAdjustment.find((y: any) => y.owner === "ClientAdjustment") != null) {
              this.clientLossAdjustment[this.clientLossAdjustment.findIndex((c: any) => c.owner === "ClientAdjustment")] = adjustment;
          }
          else {
              this.clientLossAdjustment.push(adjustment);
          }

          if (taxInc > 0) {
              taxableVal[this.clientDetails.startDate + i] = taxInc;
          }
          else {
              taxableVal[this.clientDetails.startDate + i] = 0;
          }
          taxable["values"] = taxableVal;

          if (this.clientTaxableIncome.find((y: any) => y.owner === "ClientTaxableIncome") != null) {
              this.clientTaxableIncome[this.clientTaxableIncome.findIndex((c: any) => c.owner === "ClientTaxableIncome")] = taxable;
          }
          else {
              this.clientTaxableIncome.push(taxable);
          }

          
      }
     

  }
  private calculatePartnerTaxableIncome(iVal: number) {

      let lossBF: number = 0;
      let lossAdj: number = 0;
      var income = this.Income.filter(c => c.owner === "PartnerAssessibleIncome");
      var deduction = this.PartnerDeductions.filter(c => c.owner === "PartnerDeductions");


      for (var i = 0; i <= iVal; i++) {
          var taxable = this.partnerTaxableIncome.find((y: any) => y.owner === "PartnerTaxableIncome");
          var taxableVal: any = {};
          if (taxable == null) {
              taxable = {};
          }
          else {
              taxableVal = taxable.values;
          }

          var adjustment = this.partnerLossAdjustment.find((y: any) => y.owner === "PartnerAdjustment");
          var adjustmentVal: any = {};
          if (adjustment == null) {
              adjustment = {};
          }
          else {
              adjustmentVal = adjustment.values;
          }

          taxable["owner"] = "PartnerTaxableIncome";
          taxable["name"] = "PartnerTaxableIncome";
          adjustment["owner"] = "PartnerAdjustment";
          adjustment["name"] = "PartnerAdjustment";

          //Gti stands for Gross taxable income
          let lossG: number = 0;
          let taxInc: number = 0;

          if (typeof income[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(income[0].values[this.clientDetails.startDate + i]) && typeof deduction[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(deduction[0].values[this.clientDetails.startDate + i])) {

              let Gti: number = Math.max(0, (income[0].values[this.clientDetails.startDate + i] - deduction[0].values[this.clientDetails.startDate + i]));
              if (Gti > 0) {
                  lossAdj = Math.min(lossBF, Gti);
              }


              if (deduction[0].values[this.clientDetails.startDate + i] > income[0].values[this.clientDetails.startDate + i]) {
                  lossG = deduction[0].values[this.clientDetails.startDate + i] - income[0].values[this.clientDetails.startDate + i];
              }

              //LossCF stands for Loss carried forward
              let lossCF: number = lossG + lossBF - lossAdj;
              lossBF = lossCF;

              taxInc = Gti - lossAdj;

          }

          if (lossAdj > 0) {
              adjustmentVal[this.clientDetails.startDate + i] = lossAdj;
          }
          else {
              adjustmentVal[this.clientDetails.startDate + i] = 0;
          }
          adjustment["values"] = adjustmentVal;

          if (this.partnerLossAdjustment.find((y: any) => y.owner === "PartnerAdjustment") != null) {
              this.partnerLossAdjustment[this.partnerLossAdjustment.findIndex((c: any) => c.owner === "PartnerAdjustment")] = adjustment;
          }
          else {
              this.partnerLossAdjustment.push(adjustment);
          }

          if (taxInc > 0) {
              taxableVal[this.clientDetails.startDate + i] = taxInc;
          }
          else {
              taxableVal[this.clientDetails.startDate + i] = 0;
          }
          taxable["values"] = taxableVal;

          if (this.partnerTaxableIncome.find((y: any) => y.owner === "PartnerTaxableIncome") != null) {
              this.partnerTaxableIncome[this.partnerTaxableIncome.findIndex((c: any) => c.owner === "PartnerTaxableIncome")] = taxable;
          }
          else {
              this.partnerTaxableIncome.push(taxable);
          }

          
      }
     
     

  }
  private calculateLowIncomeTO(owner: string, filter: string, type: string, iVal: number) {
     
      var taxableIncome: any = {};
      if (type == "Client") { taxableIncome = this.clientTaxableIncome.filter(c => c.owner === filter); }
      else if (type == "Partner") { taxableIncome = this.partnerTaxableIncome.filter(c => c.owner === filter); }

      for (var i = 0; i <= iVal; i++) {
          var total: any;
          if (type == "Client") {
              total = this.clientNRTaxOffset.find((y: any) => y.owner === owner);
          } else if (type == "Partner") {
              total = this.partnerNRTaxOffset.find((y: any) => y.owner === owner);
          }

          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
      total["owner"] = owner;
      total["name"] = "Low income tax offset";

     
          let lito: number = 0;

          if (typeof taxableIncome[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(taxableIncome[0].values[this.clientDetails.startDate + i])) {

              let val: number = taxableIncome[0].values[this.clientDetails.startDate + i];
              if (val <= 37000) {
                  lito = 445;
              } else if (val > 37000 && val <= 66667) {
                  lito = 445 - ((val - 37000) * 0.015)

              } else if (val > 66667) {
                  lito = 0;
              }

          }


          if (lito > 0) {
              totalVal[this.clientDetails.startDate + i] = lito.toFixed();
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (type == "Client") {
              if (this.clientNRTaxOffset.find((y: any) => y.owner === owner) != null) {
                  this.clientNRTaxOffset[this.clientNRTaxOffset.findIndex((c: any) => c.owner === owner)] = total;
              }
              else {
                  this.clientNRTaxOffset.push(total);
              }

          } else if (type == "Partner") {
              if (this.partnerNRTaxOffset.find((y: any) => y.owner === owner) != null) {
                  this.partnerNRTaxOffset[this.partnerNRTaxOffset.findIndex((c: any) => c.owner === owner)] = total;
              }
              else {
                  this.partnerNRTaxOffset.push(total);
              }

          }
     
      }

  }
  private calculateClientTotalNRTaxOffset(owner: string, filter: string, iVal: number) {

      for (var i = 0; i <= iVal; i++) {
          var total = this.clientNRTaxOffset.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Total non-refundable tax offsets";

          let sum: number = 0;
          this.clientNRTaxOffset.forEach((x: any) => {
              if (x.owner == filter) {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.Pensiontotal.forEach((x: any) => {
              if (x.owner == "SIncomeTaxOffset-client") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum.toFixed();
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.clientNRTaxOffset.find((y: any) => y.owner === owner) != null) {
              this.clientNRTaxOffset[this.clientNRTaxOffset.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.clientNRTaxOffset.push(total);
          }
      }
     
  }
  private calculatePartnerTotalNRTaxOffset(owner: string, filter: string, iVal: number) {

      for (var i = 0; i <= iVal; i++) {
          var total = this.partnerNRTaxOffset.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Total non-refundable tax offsets";

          let sum: number = 0;
          this.partnerNRTaxOffset.forEach((x: any) => {
              if (x.owner == filter) {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.Pensiontotal.forEach((x: any) => {
              if (x.owner == "SIncomeTaxOffset-partner") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum.toFixed();
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;
          if (this.partnerNRTaxOffset.find((y: any) => y.owner === owner) != null) {
              this.partnerNRTaxOffset[this.partnerNRTaxOffset.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.partnerNRTaxOffset.push(total);
          }
      }
     
  }
  private calculateRefundableTaxOffset(owner: string, type: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total: any;
          if (type == "Client") {
              total = this.clientRTaxOffset.find((y: any) => y.owner === owner);
          } else if (type == "Partner") {
              total = this.partnerRTaxOffset.find((y: any) => y.owner === owner);
          }

          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Franking Credits";


          let sum: number = 0;
          let jointSum: number = 0;

          this.BeginningValue.forEach((x: any) => {
              if (x.type == type) {
                  if (x.frankingCreditsValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.frankingCreditsValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.BeginningValue.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.frankingCreditsValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.frankingCreditsValues[this.clientDetails.startDate + i]);
                      jointSum = jointSum + t;
                  }
              }
          });

          totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2))

          total["values"] = totalVal;

          if (type == "Client") {
              if (this.clientRTaxOffset.find((y: any) => y.owner === owner) != null) {
                  this.clientRTaxOffset[this.clientRTaxOffset.findIndex((c: any) => c.owner === owner)] = total;
              }
              else {
                  this.clientRTaxOffset.push(total);
              }

          } else if (type == "Partner") {
              if (this.partnerRTaxOffset.find((y: any) => y.owner === owner) != null) {
                  this.partnerRTaxOffset[this.partnerRTaxOffset.findIndex((c: any) => c.owner === owner)] = total;
              }
              else {
                  this.partnerRTaxOffset.push(total);
              }

          }
      }
      

  }
  //TODO: get medicare levy (2) from database
  private calculateMedicareLevy(owner: string, filter: string, type: string, iVal: number) {
     
      var taxableIncome: any = {};
      if (type == "Client") { taxableIncome = this.clientTaxableIncome.filter(c => c.owner === filter); }
      else if (type == "Partner") { taxableIncome = this.partnerTaxableIncome.filter(c => c.owner === filter); }

      var grossTax: any = {};
      if (type == "Client") { grossTax = this.GrossTax.filter(c => c.owner === "ClientGrossTax"); }
      else if (type == "Partner") { grossTax = this.GrossTax.filter(c => c.owner === "PartnerGrossTax"); }

      for (var i = 0; i <= iVal; i++) {
          var total: any;
          if (type == "Client") {
              total = this.clientMedicareLevy.find((y: any) => y.owner === owner);
          } else if (type == "Partner") {
              total = this.partnerMedicareLevy.find((y: any) => y.owner === owner);
          }

          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Medicare levy";


          let ml: number = 0;

          if (grossTax[0].values[this.clientDetails.startDate + i] > 0) {
              if (typeof taxableIncome[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(taxableIncome[0].values[this.clientDetails.startDate + i])) {

                  let val: number = taxableIncome[0].values[this.clientDetails.startDate + i];
                  ml = (val * 2) / 100;

              }
          }
          else {
              ml = 0;
          }


          if (ml > 0) {
              totalVal[this.clientDetails.startDate + i] = ml.toFixed();
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (type == "Client") {
              if (this.clientMedicareLevy.find((y: any) => y.owner === owner) != null) {
                  this.clientMedicareLevy[this.clientMedicareLevy.findIndex((c: any) => c.owner === owner)] = total;
              }
              else {
                  this.clientMedicareLevy.push(total);
              }
             
          } else if (type == "Partner") {
              if (this.partnerMedicareLevy.find((y: any) => y.owner === owner) != null) {
                  this.partnerMedicareLevy[this.partnerMedicareLevy.findIndex((c: any) => c.owner === owner)] = total;
              }
              else {
                  this.partnerMedicareLevy.push(total);
              }
             
          }
         
      }
   
  }
  private calculateGrossTax(owner: string, filter: string, type: string, iVal: number) {

     
      var taxableIncome: any = {};
      if (type == "Client") { taxableIncome = this.clientTaxableIncome.filter(c => c.owner === filter); }
      else if (type == "Partner") { taxableIncome = this.partnerTaxableIncome.filter(c => c.owner === filter); }

      let index: number = 0;
      //TODO: Verify
      Math.max.apply(Math, this.marginalTaxRates.map(function (o: any) { if (o.index > index) index = o.index; }))

      for (var i = 0; i <= iVal; i++) {

          var total = this.GrossTax.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Gross tax payable";

          let totalGrTax: number = 0;
          let incTaxed: number = 0;

          for (var j = index; j >= 1; j--) {
              let threshold = this.marginalTaxRates.filter(c => c.index === (j - 1));
              let rate = this.marginalTaxRates.filter(c => c.index === j);
              if (typeof taxableIncome[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(taxableIncome[0].values[this.clientDetails.startDate + i])) {
                  let inc: number = Math.max(0, taxableIncome[0].values[this.clientDetails.startDate + i] - incTaxed - threshold[0].threshold);
                  let grTax: number = inc * (rate[0].rate / 100);
                  totalGrTax = totalGrTax + grTax;
                  incTaxed = incTaxed + inc;
              }

          }

          if (totalGrTax > 0) {
              totalVal[this.clientDetails.startDate + i] = totalGrTax.toFixed();
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.GrossTax.find((y: any) => y.owner === owner) != null) {
              this.GrossTax[this.GrossTax.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.GrossTax.push(total);
          }
      }



  }
  private calculateTaxPayableNonRefundable(owner: string, filter1: string, filter2: string, type: string, iVal: number) {

     
      var grossTax: any = {};
      var nRTaxOffset: any = {};

      if (type == "Client") {
          grossTax = this.GrossTax.filter(c => c.owner === filter1);
          nRTaxOffset = this.clientNRTaxOffset.filter(c => c.owner === filter2);

      }
      else if (type == "Partner") {
          grossTax = this.GrossTax.filter(c => c.owner === filter1);
          nRTaxOffset = this.partnerNRTaxOffset.filter(p => p.owner === filter2);
      }

      for (var i = 0; i <= iVal; i++) {

          var total = this.NetPayable.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }

          total["owner"] = owner;
          total["name"] = "Tax payable after non-refundable tax offsets";


          let val: number = 0;


          val = Math.max(0, (grossTax[0].values[this.clientDetails.startDate + i] - nRTaxOffset[0].values[this.clientDetails.startDate + i]));

          if (val > 0) {
              totalVal[this.clientDetails.startDate + i] = val;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.NetPayable.find((y: any) => y.owner === owner) != null) {
              this.NetPayable[this.NetPayable.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.NetPayable.push(total);
          }
      }

     
  }
  private calculateTaxPayableRefundable(owner: string, filter1: string, filter2: string, type: string, iVal: number) {

     

      var tp: any = {};
      var rTaxOffset: any = {};

      if (type == "Client") {
          tp = this.NetPayable.filter(c => c.owner === filter1);
          rTaxOffset = this.clientRTaxOffset.filter(c => c.owner === filter2);

      }
      else if (type == "Partner") {
          tp = this.NetPayable.filter(c => c.owner === filter1);
          rTaxOffset = this.partnerRTaxOffset.filter(p => p.owner === filter2);
      }

      for (var i = 0; i <= iVal; i++) {

          var total = this.NetPayable.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }

      total["owner"] = owner;
      total["name"] = "Tax payable after refundable tax offsets";

     
          let val: number = 0;


          val = tp[0].values[this.clientDetails.startDate + i] - rTaxOffset[0].values[this.clientDetails.startDate + i];


          totalVal[this.clientDetails.startDate + i] = val;

          total["values"] = totalVal;

          if (this.NetPayable.find((y: any) => y.owner === owner) != null) {
              this.NetPayable[this.NetPayable.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.NetPayable.push(total);
          }
      }
  }
  private calculateTotalTaxesPayable(owner: string, filter1: string, filter2: string, type: string, iVal: number) {

     

      var netTax: any = {};
      var medicare: any = {};

      if (type == "Client") {
          netTax = this.NetPayable.filter(c => c.owner === filter1);
          medicare = this.clientMedicareLevy.filter(c => c.owner === filter2);

      }
      else if (type == "Partner") {
          netTax = this.NetPayable.filter(c => c.owner === filter1);
          medicare = this.partnerMedicareLevy.filter(p => p.owner === filter2);
      }
      for (var i = 0; i <= iVal; i++) {

          var total = this.TotalPayable.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Total taxes payable";

          let val: number = 0;

          val = netTax[0].values[this.clientDetails.startDate + i] + parseInt(medicare[0].values[this.clientDetails.startDate + i]);

          if (val > 0) {
              totalVal[this.clientDetails.startDate + i] = val;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.TotalPayable.find((y: any) => y.owner === owner) != null) {
              this.TotalPayable[this.TotalPayable.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.TotalPayable.push(total);
          }
      }
     
  }
  private calculateAverageTaxRate(owner: string, filter1: string, filter2: string, type: string, iVal: number) {

     

      var totalTax: any = {};
      var income: any = {};

      if (type == "Client") {
          totalTax = this.TotalPayable.filter(c => c.owner === filter1);
          income = this.Income.filter(c => c.owner === filter2);

      }
      else if (type == "Partner") {
          totalTax = this.TotalPayable.filter(c => c.owner === filter1);
          income = this.Income.filter(p => p.owner === filter2);
      }

      for (var i = 0; i <= iVal; i++) {

          var total = this.TotalPayable.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Average tax rate";


          let val: number = 0;

          val = (totalTax[0].values[this.clientDetails.startDate + i] / parseInt(income[0].values[this.clientDetails.startDate + i])) * 100;

          if (val > 0) {
              totalVal[this.clientDetails.startDate + i] = val.toFixed(1);
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.TotalPayable.find((y: any) => y.owner === owner) != null) {
              this.TotalPayable[this.TotalPayable.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.TotalPayable.push(total);
          }
      }
  }
  private calculateMarginalTaxRate(owner: string, filter: string, type: string, iVal: number) {

      var taxableIncome: any = {};
      if (type == "Client") { taxableIncome = this.clientTaxableIncome.filter(c => c.owner === filter); }
      else if (type == "Partner") { taxableIncome = this.partnerTaxableIncome.filter(c => c.owner === filter); }

      let index: number = 0;
      Math.max.apply(Math, this.marginalTaxRates.map(function (o: any) { if (o.index > index) index = o.index; }))

      for (var i = 0; i <= iVal; i++) {

          var total = this.TotalPayable.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Marginal tax rate";




          let mtr: number = 0;
          let val: number = taxableIncome[0].values[this.clientDetails.startDate + i];

          for (var j = 1; j <= index; j++) {

              let one = this.marginalTaxRates.filter(c => c.index === (j - 1));
              let two = this.marginalTaxRates.filter(c => c.index === j);


              if (typeof taxableIncome[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(taxableIncome[0].values[this.clientDetails.startDate + i])) {
                  if (j == index) {
                      if (val > one[0].threshold) {
                          mtr = two[0].rate;
                      }
                  }
                  else {
                      if (val > one[0].threshold && val <= two[0].threshold) {
                          mtr = two[0].rate;
                          break;
                      }
                  }

              }


          }

          if (mtr > 0) {
              totalVal[this.clientDetails.startDate + i] = mtr.toFixed(1);
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.TotalPayable.find((y: any) => y.owner === owner) != null) {
              this.TotalPayable[this.TotalPayable.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.TotalPayable.push(total);
          }

      }

  }
  private calculateTotalIncomeTaxPayable(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {

          var total = this.FAtotal.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Income Tax Payable";

          let sum: number = 0;


          this.TotalPayable.forEach((x: any) => {
              if (x.owner == "ClientTotalTaxPayable" || x.owner == "PartnerTotalTaxPayable") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.FAtotal.find((y: any) => y.owner === owner) != null) {
              this.FAtotal[this.FAtotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotal.push(total);;
          }
      }

    

  }

  //Tax functions

  private calculateTotalTaxIncomeOptimized(owner: string, filter: string, iVal: number) {

      for (var i = 0; i <= iVal; i++) {
          var total = this.IncomeOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Income";

          let sum: number = 0;


          if (filter == "Client") {

              this.inflowOptimized.forEach((x: any) => {
                  if (x.owner == "ClientIncome-tax") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });


              this.FAtotalOptimized.forEach((x: any) => {
                  if (x.owner == "TotalTaxIE-client") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });

              this.FAtotalOptimized.forEach((x: any) => {
                  if (x.owner == "FrankingCredits-client") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
              this.PensiontotalOptimized.forEach((x: any) => {
                  if (x.owner == "PensionIncome-client") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });

          }
          else {

              this.inflowOptimized.forEach((x: any) => {
                  if (x.owner == "PartnerIncome-tax") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });

              this.FAtotalOptimized.forEach((x: any) => {
                  if (x.owner == "TotalTaxIE-partner") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });

              this.FAtotalOptimized.forEach((x: any) => {
                  if (x.owner == "FrankingCredits-partner") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });

              this.PensiontotalOptimized.forEach((x: any) => {
                  if (x.owner == "PensionIncome-partner") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
          }


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.IncomeOptimized.find((y: any) => y.owner === owner) != null) {
              this.IncomeOptimized[this.IncomeOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.IncomeOptimized.push(total);
          }
      }
  }
  private calculateCapitalLossAdjustmentOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.PropertiestotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Capital loss adjustment";

          let AccumCL: number = 0;
          if (filter == "Client") {


              let SumCG: number = 0;
              let SumCL: number = 0;

              this.FAtotalOptimized.forEach((x: any) => {
                  if (x.owner == "RCGFA-client") {
                      if (x.values[this.clientDetails.startDate + i] >= 0) {
                          SumCG = SumCG + Number(x.values[this.clientDetails.startDate + i]);

                      }
                      else if (x.values[this.clientDetails.startDate + i] < 0) {
                          SumCL = SumCL + Number(x.values[this.clientDetails.startDate + i]);
                      }
                  }
              });

              this.PropertiesValueOptimized.forEach((x: any) => {
                  if (x.owner == "RCGP-client") {
                      if (x.values[this.clientDetails.startDate + i] >= 0) {
                          SumCG = SumCG + Number(x.values[this.clientDetails.startDate + i]);

                      }
                      else if (x.values[this.clientDetails.startDate + i] < 0) {
                          SumCL = SumCL + Number(x.values[this.clientDetails.startDate + i]);
                      }
                  }
              });


              AccumCL = AccumCL + SumCL;

              var t = SumCG + AccumCL;
              var CLA: number = 0;
              if (t >= 0) {
                  CLA = AccumCL;
                  AccumCL = 0;
              }
              else if (t < 0) {
                  CLA = Number(SumCG) * (-1);
                  AccumCL = SumCG - AccumCL;
              }

              totalVal[this.clientDetails.startDate + i] = CLA.toFixed();
              total["values"] = totalVal;


          }
          else {


              let SumCG: number = 0;
              let SumCL: number = 0;

              this.FAtotalOptimized.forEach((x: any) => {
                  if (x.owner == "RCGFA-partner") {
                      if (x.values[this.clientDetails.startDate + i] >= 0) {
                          SumCG = SumCG + Number(x.values[this.clientDetails.startDate + i]);

                      }
                      else if (x.values[this.clientDetails.startDate + i] < 0) {
                          SumCL = SumCL + Number(x.values[this.clientDetails.startDate + i]);
                      }
                  }
              });

              this.PropertiesValueOptimized.forEach((x: any) => {
                  if (x.owner == "RCGP-partner") {
                      if (x.values[this.clientDetails.startDate + i] >= 0) {
                          SumCG = SumCG + Number(x.values[this.clientDetails.startDate + i]);

                      }
                      else if (x.values[this.clientDetails.startDate + i] < 0) {
                          SumCL = SumCL + Number(x.values[this.clientDetails.startDate + i]);
                      }
                  }
              });


              AccumCL = AccumCL + SumCL;

              var t = SumCG + AccumCL;
              var CLA: number = 0;
              if (t >= 0) {
                  CLA = AccumCL;
                  AccumCL = 0;
              }
              else if (t < 0) {
                  CLA = Number(SumCG) * (-1);
                  AccumCL = SumCG - AccumCL;
              }

              totalVal[this.clientDetails.startDate + i] = CLA.toFixed();
              total["values"] = totalVal;
          }

          if (this.PropertiestotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.PropertiestotalOptimized[this.PropertiestotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.PropertiestotalOptimized.push(total);
          }
      }




  }
  private calculateTotalAssessibleIncomeOptimized(owner: string, filter: string, type: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.IncomeOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "ClientAssessibleIncome";

          let sum: number = 0;
          this.IncomeOptimized.forEach((x: any) => {
              if (x.owner == filter) {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          if (type == "Client") {
              this.FAtotalOptimized.forEach((x: any) => {
                  if (x.owner == "RCGFA-client") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
              this.PropertiestotalOptimized.forEach((x: any) => {
                  if (x.owner == "RCGP-client" || x.owner == "CLA-client") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
              this.SupertotalOptimized.forEach((x: any) => {
                  if (x.owner == "LumpSum-client") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
          }
          else {
              this.FAtotalOptimized.forEach((x: any) => {
                  if (x.owner == "RCGFA-partner") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
              this.PropertiestotalOptimized.forEach((x: any) => {
                  if (x.owner == "RCGP-partner" || x.owner == "CLA-partner") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
              this.SupertotalOptimized.forEach((x: any) => {
                  if (x.owner == "LumpSum-partner") {
                      if (x.values[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.values[this.clientDetails.startDate + i]);
                          sum = sum + t;
                      }
                  }
              });
          }


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.IncomeOptimized.find((y: any) => y.owner === owner) != null) {
              this.IncomeOptimized[this.IncomeOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.IncomeOptimized.push(total);
          }

      }

  }
  private calculateClientTotalDeductionsOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.ClientDeductionsOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = owner;

          let sum: number = 0;
          this.ClientDeductionsOptimized.forEach((x: any) => {
              if (x.owner == filter || x.owner == "Joint") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.PropertiestotalOptimized.forEach((x: any) => {
              if (x.owner == "InvestmentPropertyExpenses-client") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.SupertotalOptimized.forEach((x: any) => {
              if (x.owner == "SalarySacrifice-client") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.LBtotalOptimized.forEach((x: any) => {
              if (x.owner == "Accruedliability-client") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.ClientDeductionsOptimized.find((y: any) => y.owner === owner) != null) {
              this.ClientDeductionsOptimized[this.ClientDeductionsOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.ClientDeductionsOptimized.push(total);
          }
      }


  }
  private calculatePartnerTotalDeductionsOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.PartnerDeductionsOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = owner;

          let sum: number = 0;
          this.PartnerDeductionsOptimized.forEach((x: any) => {
              if (x.owner == filter || x.owner == "Joint") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.PropertiestotalOptimized.forEach((x: any) => {
              if (x.owner == "InvestmentPropertyExpenses-partner") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.SupertotalOptimized.forEach((x: any) => {
              if (x.owner == "SalarySacrifice-partner") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.LBtotalOptimized.forEach((x: any) => {
              if (x.owner == "Accruedliability-partner") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.PartnerDeductionsOptimized.find((y: any) => y.owner === owner) != null) {
              this.PartnerDeductionsOptimized[this.PartnerDeductionsOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.PartnerDeductionsOptimized.push(total);
          }
      }

  }
  private calculateClientTaxableIncomeOptimized(iVal: number) {

      let lossBF: number = 0;
      let lossAdj: number = 0;
      var income = this.IncomeOptimized.filter(c => c.owner === "ClientAssessibleIncome");
      var deduction = this.ClientDeductionsOptimized.filter(c => c.owner === "ClientDeductions");


      for (var i = 0; i <= iVal; i++) {
          var taxable = this.clientTaxableIncomeOptimized.find((y: any) => y.owner === "ClientTaxableIncome");
          var taxableVal: any = {};
          if (taxable == null) {
              taxable = {};
          }
          else {
              taxableVal = taxable.values;
          }

          var adjustment = this.clientLossAdjustmentOptimized.find((y: any) => y.owner === "ClientAdjustment");
          var adjustmentVal: any = {};
          if (adjustment == null) {
              adjustment = {};
          }
          else {
              adjustmentVal = adjustment.values;
          }
          taxable["owner"] = "ClientTaxableIncome";
          taxable["name"] = "ClientTaxableIncome";
          adjustment["owner"] = "ClientAdjustment";
          adjustment["name"] = "ClientAdjustment";

          //Gti stands for Gross taxable income
          let lossG: number = 0;
          let taxInc: number = 0;

          if (typeof income[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(income[0].values[this.clientDetails.startDate + i]) && typeof deduction[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(deduction[0].values[this.clientDetails.startDate + i])) {

              let Gti: number = Math.max(0, (income[0].values[this.clientDetails.startDate + i] - deduction[0].values[this.clientDetails.startDate + i]));
              if (Gti > 0) {
                  lossAdj = Math.min(lossBF, Gti);
              }


              if (deduction[0].values[this.clientDetails.startDate + i] > income[0].values[this.clientDetails.startDate + i]) {
                  lossG = deduction[0].values[this.clientDetails.startDate + i] - income[0].values[this.clientDetails.startDate + i];
              }

              //LossCF stands for Loss carried forward
              let lossCF: number = lossG + lossBF - lossAdj;
              lossBF = lossCF;

              taxInc = Gti - lossAdj;

          }

          if (lossAdj > 0) {
              adjustmentVal[this.clientDetails.startDate + i] = lossAdj;
          }
          else {
              adjustmentVal[this.clientDetails.startDate + i] = 0;
          }
          adjustment["values"] = adjustmentVal;

          if (this.clientLossAdjustmentOptimized.find((y: any) => y.owner === "ClientAdjustment") != null) {
              this.clientLossAdjustmentOptimized[this.clientLossAdjustmentOptimized.findIndex((c: any) => c.owner === "ClientAdjustment")] = adjustment;
          }
          else {
              this.clientLossAdjustmentOptimized.push(adjustment);
          }

          if (taxInc > 0) {
              taxableVal[this.clientDetails.startDate + i] = taxInc;
          }
          else {
              taxableVal[this.clientDetails.startDate + i] = 0;
          }
          taxable["values"] = taxableVal;

          if (this.clientTaxableIncomeOptimized.find((y: any) => y.owner === "ClientTaxableIncome") != null) {
              this.clientTaxableIncomeOptimized[this.clientTaxableIncomeOptimized.findIndex((c: any) => c.owner === "ClientTaxableIncome")] = taxable;
          }
          else {
              this.clientTaxableIncomeOptimized.push(taxable);
          }


      }


  }
  private calculatePartnerTaxableIncomeOptimized(iVal: number) {

      let lossBF: number = 0;
      let lossAdj: number = 0;
      var income = this.Income.filter(c => c.owner === "PartnerAssessibleIncome");
      var deduction = this.PartnerDeductionsOptimized.filter(c => c.owner === "PartnerDeductions");


      for (var i = 0; i <= iVal; i++) {
          var taxable = this.partnerTaxableIncomeOptimized.find((y: any) => y.owner === "PartnerTaxableIncome");
          var taxableVal: any = {};
          if (taxable == null) {
              taxable = {};
          }
          else {
              taxableVal = taxable.values;
          }

          var adjustment = this.partnerLossAdjustmentOptimized.find((y: any) => y.owner === "PartnerAdjustment");
          var adjustmentVal: any = {};
          if (adjustment == null) {
              adjustment = {};
          }
          else {
              adjustmentVal = adjustment.values;
          }

          taxable["owner"] = "PartnerTaxableIncome";
          taxable["name"] = "PartnerTaxableIncome";
          adjustment["owner"] = "PartnerAdjustment";
          adjustment["name"] = "PartnerAdjustment";

          //Gti stands for Gross taxable income
          let lossG: number = 0;
          let taxInc: number = 0;

          if (typeof income[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(income[0].values[this.clientDetails.startDate + i]) && typeof deduction[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(deduction[0].values[this.clientDetails.startDate + i])) {

              let Gti: number = Math.max(0, (income[0].values[this.clientDetails.startDate + i] - deduction[0].values[this.clientDetails.startDate + i]));
              if (Gti > 0) {
                  lossAdj = Math.min(lossBF, Gti);
              }


              if (deduction[0].values[this.clientDetails.startDate + i] > income[0].values[this.clientDetails.startDate + i]) {
                  lossG = deduction[0].values[this.clientDetails.startDate + i] - income[0].values[this.clientDetails.startDate + i];
              }

              //LossCF stands for Loss carried forward
              let lossCF: number = lossG + lossBF - lossAdj;
              lossBF = lossCF;

              taxInc = Gti - lossAdj;

          }

          if (lossAdj > 0) {
              adjustmentVal[this.clientDetails.startDate + i] = lossAdj;
          }
          else {
              adjustmentVal[this.clientDetails.startDate + i] = 0;
          }
          adjustment["values"] = adjustmentVal;

          if (this.partnerLossAdjustmentOptimized.find((y: any) => y.owner === "PartnerAdjustment") != null) {
              this.partnerLossAdjustmentOptimized[this.partnerLossAdjustmentOptimized.findIndex((c: any) => c.owner === "PartnerAdjustment")] = adjustment;
          }
          else {
              this.partnerLossAdjustmentOptimized.push(adjustment);
          }

          if (taxInc > 0) {
              taxableVal[this.clientDetails.startDate + i] = taxInc;
          }
          else {
              taxableVal[this.clientDetails.startDate + i] = 0;
          }
          taxable["values"] = taxableVal;

          if (this.partnerTaxableIncomeOptimized.find((y: any) => y.owner === "PartnerTaxableIncome") != null) {
              this.partnerTaxableIncomeOptimized[this.partnerTaxableIncomeOptimized.findIndex((c: any) => c.owner === "PartnerTaxableIncome")] = taxable;
          }
          else {
              this.partnerTaxableIncomeOptimized.push(taxable);
          }


      }



  }
  private calculateLowIncomeTOOptimized(owner: string, filter: string, type: string, iVal: number) {

      var taxableIncome: any = {};
      if (type == "Client") { taxableIncome = this.clientTaxableIncomeOptimized.filter(c => c.owner === filter); }
      else if (type == "Partner") { taxableIncome = this.partnerTaxableIncomeOptimized.filter(c => c.owner === filter); }

      for (var i = 0; i <= iVal; i++) {
          var total: any;
          if (type == "Client") {
              total = this.clientNRTaxOffsetOptimized.find((y: any) => y.owner === owner);
          } else if (type == "Partner") {
              total = this.partnerNRTaxOffsetOptimized.find((y: any) => y.owner === owner);
          }

          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Low income tax offset";


          let lito: number = 0;

          if (typeof taxableIncome[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(taxableIncome[0].values[this.clientDetails.startDate + i])) {

              let val: number = taxableIncome[0].values[this.clientDetails.startDate + i];
              if (val <= 37000) {
                  lito = 445;
              } else if (val > 37000 && val <= 66667) {
                  lito = 445 - ((val - 37000) * 0.015)

              } else if (val > 66667) {
                  lito = 0;
              }

          }


          if (lito > 0) {
              totalVal[this.clientDetails.startDate + i] = lito.toFixed();
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (type == "Client") {
              if (this.clientNRTaxOffsetOptimized.find((y: any) => y.owner === owner) != null) {
                  this.clientNRTaxOffsetOptimized[this.clientNRTaxOffsetOptimized.findIndex((c: any) => c.owner === owner)] = total;
              }
              else {
                  this.clientNRTaxOffsetOptimized.push(total);
              }

          } else if (type == "Partner") {
              if (this.partnerNRTaxOffsetOptimized.find((y: any) => y.owner === owner) != null) {
                  this.partnerNRTaxOffsetOptimized[this.partnerNRTaxOffsetOptimized.findIndex((c: any) => c.owner === owner)] = total;
              }
              else {
                  this.partnerNRTaxOffsetOptimized.push(total);
              }

          }

      }

  }
  private calculateClientTotalNRTaxOffsetOptimized(owner: string, filter: string, iVal: number) {

      for (var i = 0; i <= iVal; i++) {
          var total = this.clientNRTaxOffsetOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Total non-refundable tax offsets";

          let sum: number = 0;
          this.clientNRTaxOffsetOptimized.forEach((x: any) => {
              if (x.owner == filter) {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.PensiontotalOptimized.forEach((x: any) => {
              if (x.owner == "SIncomeTaxOffset-client") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum.toFixed();
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.clientNRTaxOffsetOptimized.find((y: any) => y.owner === owner) != null) {
              this.clientNRTaxOffsetOptimized[this.clientNRTaxOffsetOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.clientNRTaxOffsetOptimized.push(total);
          }
      }

  }
  private calculatePartnerTotalNRTaxOffsetOptimized(owner: string, filter: string, iVal: number) {

      for (var i = 0; i <= iVal; i++) {
          var total = this.partnerNRTaxOffsetOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Total non-refundable tax offsets";

          let sum: number = 0;
          this.partnerNRTaxOffsetOptimized.forEach((x: any) => {
              if (x.owner == filter) {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.PensiontotalOptimized.forEach((x: any) => {
              if (x.owner == "SIncomeTaxOffset-partner") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum.toFixed();
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;
          if (this.partnerNRTaxOffsetOptimized.find((y: any) => y.owner === owner) != null) {
              this.partnerNRTaxOffsetOptimized[this.partnerNRTaxOffsetOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.partnerNRTaxOffsetOptimized.push(total);
          }
      }

  }
  private calculateRefundableTaxOffsetOptimized(owner: string, type: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total: any;
          if (type == "Client") {
              total = this.clientRTaxOffsetOptimized.find((y: any) => y.owner === owner);
          } else if (type == "Partner") {
              total = this.partnerRTaxOffsetOptimized.find((y: any) => y.owner === owner);
          }

          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Franking Credits";


          let sum: number = 0;
          let jointSum: number = 0;

          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.type == type) {
                  if (x.frankingCreditsValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.frankingCreditsValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.frankingCreditsValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.frankingCreditsValues[this.clientDetails.startDate + i]);
                      jointSum = jointSum + t;
                  }
              }
          });

          totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2))

          total["values"] = totalVal;

          if (type == "Client") {
              if (this.clientRTaxOffsetOptimized.find((y: any) => y.owner === owner) != null) {
                  this.clientRTaxOffsetOptimized[this.clientRTaxOffsetOptimized.findIndex((c: any) => c.owner === owner)] = total;
              }
              else {
                  this.clientRTaxOffsetOptimized.push(total);
              }

          } else if (type == "Partner") {
              if (this.partnerRTaxOffsetOptimized.find((y: any) => y.owner === owner) != null) {
                  this.partnerRTaxOffsetOptimized[this.partnerRTaxOffsetOptimized.findIndex((c: any) => c.owner === owner)] = total;
              }
              else {
                  this.partnerRTaxOffsetOptimized.push(total);
              }

          }
      }


  }
  //TODO: get medicare levy (2) from database
  private calculateMedicareLevyOptimized(owner: string, filter: string, type: string, iVal: number) {

      var taxableIncome: any = {};
      if (type == "Client") { taxableIncome = this.clientTaxableIncomeOptimized.filter(c => c.owner === filter); }
      else if (type == "Partner") { taxableIncome = this.partnerTaxableIncomeOptimized.filter(c => c.owner === filter); }

      var grossTax: any = {};
      if (type == "Client") { grossTax = this.GrossTaxOptimized.filter(c => c.owner === "ClientGrossTax"); }
      else if (type == "Partner") { grossTax = this.GrossTaxOptimized.filter(c => c.owner === "PartnerGrossTax"); }

      for (var i = 0; i <= iVal; i++) {
          var total: any;
          if (type == "Client") {
              total = this.clientMedicareLevyOptimized.find((y: any) => y.owner === owner);
          } else if (type == "Partner") {
              total = this.partnerMedicareLevyOptimized.find((y: any) => y.owner === owner);
          }

          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Medicare levy";


          let ml: number = 0;

          if (grossTax[0].values[this.clientDetails.startDate + i] > 0) {
              if (typeof taxableIncome[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(taxableIncome[0].values[this.clientDetails.startDate + i])) {

                  let val: number = taxableIncome[0].values[this.clientDetails.startDate + i];
                  ml = (val * 2) / 100;

              }
          }
          else {
              ml = 0;
          }


          if (ml > 0) {
              totalVal[this.clientDetails.startDate + i] = ml.toFixed();
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (type == "Client") {
              if (this.clientMedicareLevyOptimized.find((y: any) => y.owner === owner) != null) {
                  this.clientMedicareLevyOptimized[this.clientMedicareLevyOptimized.findIndex((c: any) => c.owner === owner)] = total;
              }
              else {
                  this.clientMedicareLevyOptimized.push(total);
              }

          } else if (type == "Partner") {
              if (this.partnerMedicareLevyOptimized.find((y: any) => y.owner === owner) != null) {
                  this.partnerMedicareLevyOptimized[this.partnerMedicareLevyOptimized.findIndex((c: any) => c.owner === owner)] = total;
              }
              else {
                  this.partnerMedicareLevyOptimized.push(total);
              }

          }

      }

  }
  private calculateGrossTaxOptimized(owner: string, filter: string, type: string, iVal: number) {


      var taxableIncome: any = {};
      if (type == "Client") { taxableIncome = this.clientTaxableIncomeOptimized.filter(c => c.owner === filter); }
      else if (type == "Partner") { taxableIncome = this.partnerTaxableIncomeOptimized.filter(c => c.owner === filter); }

      let index: number = 0;
      //TODO: Verify
      Math.max.apply(Math, this.marginalTaxRates.map(function (o: any) { if (o.index > index) index = o.index; }))

      for (var i = 0; i <= iVal; i++) {

          var total = this.GrossTaxOptimized.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Gross tax payable";

          let totalGrTax: number = 0;
          let incTaxed: number = 0;

          for (var j = index; j >= 1; j--) {
              let threshold = this.marginalTaxRates.filter(c => c.index === (j - 1));
              let rate = this.marginalTaxRates.filter(c => c.index === j);
              if (typeof taxableIncome[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(taxableIncome[0].values[this.clientDetails.startDate + i])) {
                  let inc: number = Math.max(0, taxableIncome[0].values[this.clientDetails.startDate + i] - incTaxed - threshold[0].threshold);
                  let grTax: number = inc * (rate[0].rate / 100);
                  totalGrTax = totalGrTax + grTax;
                  incTaxed = incTaxed + inc;
              }

          }

          if (totalGrTax > 0) {
              totalVal[this.clientDetails.startDate + i] = totalGrTax.toFixed();
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.GrossTaxOptimized.find((y: any) => y.owner === owner) != null) {
              this.GrossTaxOptimized[this.GrossTaxOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.GrossTaxOptimized.push(total);
          }
      }



  }
  private calculateTaxPayableNonRefundableOptimized(owner: string, filter1: string, filter2: string, type: string, iVal: number) {


      var grossTax: any = {};
      var nRTaxOffset: any = {};

      if (type == "Client") {
          grossTax = this.GrossTaxOptimized.filter(c => c.owner === filter1);
          nRTaxOffset = this.clientNRTaxOffsetOptimized.filter(c => c.owner === filter2);

      }
      else if (type == "Partner") {
          grossTax = this.GrossTaxOptimized.filter(c => c.owner === filter1);
          nRTaxOffset = this.partnerNRTaxOffsetOptimized.filter(p => p.owner === filter2);
      }

      for (var i = 0; i <= iVal; i++) {

          var total = this.NetPayableOptimized.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }

          total["owner"] = owner;
          total["name"] = "Tax payable after non-refundable tax offsets";


          let val: number = 0;


          val = Math.max(0, (grossTax[0].values[this.clientDetails.startDate + i] - nRTaxOffset[0].values[this.clientDetails.startDate + i]));

          if (val > 0) {
              totalVal[this.clientDetails.startDate + i] = val;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.NetPayableOptimized.find((y: any) => y.owner === owner) != null) {
              this.NetPayableOptimized[this.NetPayableOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.NetPayableOptimized.push(total);
          }
      }


  }
  private calculateTaxPayableRefundableOptimized(owner: string, filter1: string, filter2: string, type: string, iVal: number) {



      var tp: any = {};
      var rTaxOffset: any = {};

      if (type == "Client") {
          tp = this.NetPayable.filter(c => c.owner === filter1);
          rTaxOffset = this.clientRTaxOffsetOptimized.filter(c => c.owner === filter2);

      }
      else if (type == "Partner") {
          tp = this.NetPayable.filter(c => c.owner === filter1);
          rTaxOffset = this.partnerRTaxOffsetOptimized.filter(p => p.owner === filter2);
      }

      for (var i = 0; i <= iVal; i++) {

          var total = this.NetPayableOptimized.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }

          total["owner"] = owner;
          total["name"] = "Tax payable after refundable tax offsets";


          let val: number = 0;


          val = tp[0].values[this.clientDetails.startDate + i] - rTaxOffset[0].values[this.clientDetails.startDate + i];


          totalVal[this.clientDetails.startDate + i] = val;

          total["values"] = totalVal;

          if (this.NetPayableOptimized.find((y: any) => y.owner === owner) != null) {
              this.NetPayableOptimized[this.NetPayableOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.NetPayableOptimized.push(total);
          }
      }
  }
  private calculateTotalTaxesPayableOptimized(owner: string, filter1: string, filter2: string, type: string, iVal: number) {



      var netTax: any = {};
      var medicare: any = {};

      if (type == "Client") {
          netTax = this.NetPayableOptimized.filter(c => c.owner === filter1);
          medicare = this.clientMedicareLevyOptimized.filter(c => c.owner === filter2);

      }
      else if (type == "Partner") {
          netTax = this.NetPayableOptimized.filter(c => c.owner === filter1);
          medicare = this.partnerMedicareLevyOptimized.filter(p => p.owner === filter2);
      }
      for (var i = 0; i <= iVal; i++) {

          var total = this.TotalPayableOptimized.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Total taxes payable";

          let val: number = 0;

          val = netTax[0].values[this.clientDetails.startDate + i] + parseInt(medicare[0].values[this.clientDetails.startDate + i]);

          if (val > 0) {
              totalVal[this.clientDetails.startDate + i] = val;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.TotalPayableOptimized.find((y: any) => y.owner === owner) != null) {
              this.TotalPayableOptimized[this.TotalPayableOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.TotalPayableOptimized.push(total);
          }
      }

  }
  private calculateAverageTaxRateOptimized(owner: string, filter1: string, filter2: string, type: string, iVal: number) {



      var totalTax: any = {};
      var income: any = {};

      if (type == "Client") {
          totalTax = this.TotalPayableOptimized.filter(c => c.owner === filter1);
          income = this.IncomeOptimized.filter(c => c.owner === filter2);

      }
      else if (type == "Partner") {
          totalTax = this.TotalPayableOptimized.filter(c => c.owner === filter1);
          income = this.IncomeOptimized.filter(p => p.owner === filter2);
      }

      for (var i = 0; i <= iVal; i++) {

          var total = this.TotalPayableOptimized.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Average tax rate";


          let val: number = 0;

          val = (totalTax[0].values[this.clientDetails.startDate + i] / parseInt(income[0].values[this.clientDetails.startDate + i])) * 100;

          if (val > 0) {
              totalVal[this.clientDetails.startDate + i] = val.toFixed(1);
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.TotalPayableOptimized.find((y: any) => y.owner === owner) != null) {
              this.TotalPayableOptimized[this.TotalPayableOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.TotalPayableOptimized.push(total);
          }
      }
  }
  private calculateMarginalTaxRateOptimized(owner: string, filter: string, type: string, iVal: number) {

      var taxableIncome: any = {};
      if (type == "Client") { taxableIncome = this.clientTaxableIncomeOptimized.filter(c => c.owner === filter); }
      else if (type == "Partner") { taxableIncome = this.partnerTaxableIncomeOptimized.filter(c => c.owner === filter); }

      let index: number = 0;
      Math.max.apply(Math, this.marginalTaxRates.map(function (o: any) { if (o.index > index) index = o.index; }))

      for (var i = 0; i <= iVal; i++) {

          var total = this.TotalPayableOptimized.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Marginal tax rate";




          let mtr: number = 0;
          let val: number = taxableIncome[0].values[this.clientDetails.startDate + i];

          for (var j = 1; j <= index; j++) {

              let one = this.marginalTaxRates.filter(c => c.index === (j - 1));
              let two = this.marginalTaxRates.filter(c => c.index === j);


              if (typeof taxableIncome[0].values[this.clientDetails.startDate + i] === "number" && !isNaN(taxableIncome[0].values[this.clientDetails.startDate + i])) {
                  if (j == index) {
                      if (val > one[0].threshold) {
                          mtr = two[0].rate;
                      }
                  }
                  else {
                      if (val > one[0].threshold && val <= two[0].threshold) {
                          mtr = two[0].rate;
                          break;
                      }
                  }

              }


          }

          if (mtr > 0) {
              totalVal[this.clientDetails.startDate + i] = mtr.toFixed(1);
          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.TotalPayableOptimized.find((y: any) => y.owner === owner) != null) {
              this.TotalPayableOptimized[this.TotalPayableOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.TotalPayableOptimized.push(total);
          }

      }

  }
  private calculateTotalIncomeTaxPayableOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {

          var total = this.FAtotalOptimized.find((y: any) => y.owner === owner);


          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Income Tax Payable";

          let sum: number = 0;


          this.TotalPayableOptimized.forEach((x: any) => {
              if (x.owner == "ClientTotalTaxPayable" || x.owner == "PartnerTotalTaxPayable") {
                  if (x.values[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.values[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.FAtotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.FAtotalOptimized[this.FAtotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotalOptimized.push(total);;
          }
      }



  }
  

  //Financial Assets Function

  private calculateTotalInvestmentPaidOut(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.FAtotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Financial Assets";

          let sum: number = 0;


          this.BeginningValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.incomePaidOutValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.incomePaidOutValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.FAtotal.find((y: any) => y.owner === owner) != null) {
              this.FAtotal[this.FAtotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotal.push(total);
          }
      }
  
  }
  private calculateTotalInvestmentWithdrawals(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.FAtotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Financial Assets";
          let sum: number = 0;

          this.BeginningValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.regularWithdrawalsValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.regularWithdrawalsValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.BeginningValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.saleOfAssetValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.saleOfAssetValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.FAtotal.find((y: any) => y.owner === owner) != null) {
              this.FAtotal[this.FAtotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotal.push(total);
          }
      }

  }
  private calculateTotalInvestmentContributions(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.FAtotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }

          total["owner"] = owner;
          total["name"] = "Financial Assets";

          let sum: number = 0;

          this.BeginningValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.regularContributionsValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.regularContributionsValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.BeginningValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.purchaseOfAssetValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.purchaseOfAssetValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.FAtotal.find((y: any) => y.owner === owner) != null) {
              this.FAtotal[this.FAtotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotal.push(total);
          }
      }
  }
  private calculateTotalInvestmentEarnings(owner: string, filter: string,iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.FAtotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Investment Earnings";

          let sum: number = 0;
          let jointSum: number = 0;

          this.BeginningValue.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.incomePaidOutValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.incomePaidOutValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.BeginningValue.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.incomePaidOutValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.incomePaidOutValues[this.clientDetails.startDate + i]);
                      jointSum = jointSum + t;
                  }
              }
          });

          this.PropertiesValue.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.rentValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.rentValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.PropertiesValue.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.rentValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.rentValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0 || jointSum > 0) {
              totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2)).toFixed();

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;



          if (this.FAtotal.find((y: any) => y.owner === owner) != null) {
              this.FAtotal[this.FAtotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotal.push(total);
          }
      }

  }
  private calculateRealizedCGFA(owner: string, filter: string,iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.FAtotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
      total["owner"] = owner;
      total["name"] = "Financial assets";
    
          let sum: number = 0;
          let jointSum: number = 0;

          this.BeginningValue.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.BeginningValue.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                      jointSum = jointSum + t;
                  }
              }
          });


          if (sum > 0 || jointSum > 0) {
              totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2)).toFixed();

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.FAtotal.find((y: any) => y.owner === owner) != null) {
              this.FAtotal[this.FAtotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotal.push(total);
          }
      }

 

  }
  private calculateFrankingCredits(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.FAtotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
      total["owner"] = owner;
      total["name"] = "Franking Credits";
     
          let sum: number = 0;
          let jointSum: number = 0;

          this.BeginningValue.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.frankingCreditsValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.frankingCreditsValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.BeginningValue.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.frankingCreditsValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.frankingCreditsValues[this.clientDetails.startDate + i]);
                      jointSum = jointSum + t;
                  }
              }
          });


          totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2)).toFixed();

          total["values"] = totalVal;
          if (this.FAtotal.find((y: any) => y.owner === owner) != null) {
              this.FAtotal[this.FAtotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotal.push(total);
          }

      }

    

  }

//Optimized financial assets

  private calculateTotalInvestmentPaidOutOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.FAtotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Financial Assets";

          let sum: number = 0;


          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.incomePaidOutValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.incomePaidOutValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.FAtotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.FAtotalOptimized[this.FAtotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotalOptimized.push(total);
          }
      }

  }
  private calculateTotalInvestmentWithdrawalsOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.FAtotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Financial Assets";
          let sum: number = 0;

          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.regularWithdrawalsValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.regularWithdrawalsValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.saleOfAssetValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.saleOfAssetValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.FAtotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.FAtotalOptimized[this.FAtotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotalOptimized.push(total);
          }
      }

  }
  private calculateTotalInvestmentContributionsOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.FAtotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }

          total["owner"] = owner;
          total["name"] = "Financial Assets";

          let sum: number = 0;

          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.regularContributionsValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.regularContributionsValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.purchaseOfAssetValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.purchaseOfAssetValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.FAtotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.FAtotalOptimized[this.FAtotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotalOptimized.push(total);
          }
      }
  }
    //verify - before properties
  private calculateTotalInvestmentEarningsOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.FAtotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Investment Earnings";

          let sum: number = 0;
          let jointSum: number = 0;

          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.incomePaidOutValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.incomePaidOutValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.incomePaidOutValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.incomePaidOutValues[this.clientDetails.startDate + i]);
                      jointSum = jointSum + t;
                  }
              }
          });

          this.PropertiesValueOptimized.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.rentValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.rentValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.PropertiesValueOptimized.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.rentValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.rentValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0 || jointSum > 0) {
              totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2)).toFixed();

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;



          if (this.FAtotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.FAtotalOptimized[this.FAtotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotalOptimized.push(total);
          }
      }

  }
  private calculateRealizedCGFAOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.FAtotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Financial assets";

          let sum: number = 0;
          let jointSum: number = 0;

          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                      jointSum = jointSum + t;
                  }
              }
          });


          if (sum > 0 || jointSum > 0) {
              totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2)).toFixed();

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.FAtotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.FAtotalOptimized[this.FAtotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotalOptimized.push(total);
          }
      }



  }
  private calculateFrankingCreditsOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.FAtotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Franking Credits";

          let sum: number = 0;
          let jointSum: number = 0;

          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.frankingCreditsValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.frankingCreditsValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.BeginningValueOptimized.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.frankingCreditsValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.frankingCreditsValues[this.clientDetails.startDate + i]);
                      jointSum = jointSum + t;
                  }
              }
          });


          totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2)).toFixed();

          total["values"] = totalVal;
          if (this.FAtotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.FAtotalOptimized[this.FAtotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.FAtotalOptimized.push(total);
          }

      }



  }
 //Liabilities Function


  private calculateTotalDebtRepayment(owner: string, iVal: number) {


      for (var i = 0; i <= iVal; i++) {
          var total = this.LBtotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }

          total["owner"] = owner;
          total["name"] = "Debt Repayment";

          let sum: number = 0;

          this.LBValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.repmtValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.repmtValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });



          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.LBtotal.find((y: any) => y.owner === owner) != null) {
              this.LBtotal[this.LBtotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.LBtotal.push(total);
          }
      }

  }
  private calculateAccruedLiabilities(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.LBtotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }

          total["owner"] = owner;
          total["name"] = "Accrued liability interest";

          let sum: number = 0;
          let jointSum: number = 0;

          this.LBValue.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.accruedInterestValues[this.clientDetails.startDate + i] != "-") {
                      var t: number = 0;
                      if (x.deductibility > 0) {
                          t = parseInt(x.accruedInterestValues[this.clientDetails.startDate + i]) * (x.deductibility / 100);
                      }
                      else {
                          t = 0;
                      }

                      sum = sum + t;
                  }
              }
          });

          this.LBValue.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.accruedInterestValues[this.clientDetails.startDate + i] != "-") {
                      var t: number = 0;
                      if (x.deductibility > 0) {
                          var t = parseInt(x.accruedInterestValues[this.clientDetails.startDate + i]) * (x.deductibility / 100);
                      }
                      else {
                          t = 0;
                      }
                      jointSum = jointSum + t;
                  }
              }
          });


          totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2)).toFixed();

          total["values"] = totalVal;

          if (this.LBtotal.find((y: any) => y.owner === owner) != null) {
              this.LBtotal[this.LBtotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.LBtotal.push(total);
          }
      }
  }
    //Optimized Liabilities Function
  private calculateTotalDebtRepaymentOptimized(owner: string, iVal: number) {


      for (var i = 0; i <= iVal; i++) {
          var total = this.LBtotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }

          total["owner"] = owner;
          total["name"] = "Debt Repayment";

          let sum: number = 0;

          this.LBValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.repmtValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.repmtValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });



          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.LBtotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.LBtotalOptimized[this.LBtotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.LBtotalOptimized.push(total);
          }
      }

  }
  private calculateAccruedLiabilitiesOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.LBtotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }

          total["owner"] = owner;
          total["name"] = "Accrued liability interest";

          let sum: number = 0;
          let jointSum: number = 0;

          this.LBValueOptimized.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.accruedInterestValues[this.clientDetails.startDate + i] != "-") {
                      var t: number = 0;
                      if (x.deductibility > 0) {
                          t = parseInt(x.accruedInterestValues[this.clientDetails.startDate + i]) * (x.deductibility / 100);
                      }
                      else {
                          t = 0;
                      }

                      sum = sum + t;
                  }
              }
          });

          this.LBValueOptimized.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.accruedInterestValues[this.clientDetails.startDate + i] != "-") {
                      var t: number = 0;
                      if (x.deductibility > 0) {
                          var t = parseInt(x.accruedInterestValues[this.clientDetails.startDate + i]) * (x.deductibility / 100);
                      }
                      else {
                          t = 0;
                      }
                      jointSum = jointSum + t;
                  }
              }
          });


          totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2)).toFixed();

          total["values"] = totalVal;

          if (this.LBtotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.LBtotalOptimized[this.LBtotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.LBtotalOptimized.push(total);
          }
      }
  }

  // Property Function

  private calculateTotalRent(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Propertiestotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Rent";

          let sum: number = 0;


          this.PropertiesValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.rentValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.rentValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.Propertiestotal.find((y: any) => y.owner === owner) != null) {
              this.Propertiestotal[this.Propertiestotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Propertiestotal.push(total);
          }
      }

     
  }
  private calculateTotalSaleProceeds(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Propertiestotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Property";

          let sum: number = 0;
          this.PropertiesValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.PropertySaleValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.PropertySaleValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.Propertiestotal.find((y: any) => y.owner === owner) != null) {
              this.Propertiestotal[this.Propertiestotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Propertiestotal.push(total);
          }
      }
  }
  private calculateTotalPropertyExpenses(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Propertiestotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Property";

          let sum: number = 0;


          this.PropertiesValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.expensesValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.expensesValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.PropertiesValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.PropertyPurchaseValues[this.clientDetails.startDate + i] != "-") {
                      var p = parseInt(x.PropertyPurchaseValues[this.clientDetails.startDate + i]);
                      sum = sum + p;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.Propertiestotal.find((y: any) => y.owner === owner) != null) {
              this.Propertiestotal[this.Propertiestotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Propertiestotal.push(total);
          }
      }
  }
  private calculateInvestmentPropertyExpenses(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Propertiestotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Investment property expenses";

          let sum: number = 0;
          let jointSum: number = 0;

          this.PropertiesValue.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.expensesValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.expensesValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.PropertiesValue.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.expensesValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.expensesValues[this.clientDetails.startDate + i]);
                      jointSum = jointSum + t;
                  }
              }
          });


          totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2)).toFixed();

          total["values"] = totalVal;

          if (this.Propertiestotal.find((y: any) => y.owner === owner) != null) {
              this.Propertiestotal[this.Propertiestotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Propertiestotal.push(total);
          }
      }

  }
  private calculateRealizedCGP(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Propertiestotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
      total["owner"] = owner;
      total["name"] = "Properties";
     
          let sum: number = 0;
          let jointSum: number = 0;

          this.PropertiesValue.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.startDateType == "Existing") {
                      if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                          sum = sum + (t / 2);
                      }
                  }
                  else {
                      //Verify
                      if ((this.clientDetails.startDate + i) - Number(x.propPurchase) > 1) {
                          if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                              var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                              sum = sum + (t / 2);
                          }
                      }
                      else {
                          if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                              var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                              sum = sum + t;
                          }
                      }
                  }
              }
          });

          //TODO : Decimal Value ?
          this.PropertiesValue.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.type == filter) {
                      if (x.startDateType == "Existing") {
                          if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                              var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                              jointSum = jointSum + (t / 2);
                          }
                      }
                      else {
                          if ((this.clientDetails.startDate + i) - Number(x.propPurchase) > 1) {
                              if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                                  var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                                  jointSum = jointSum + (t / 2);
                              }
                          }
                          else {
                              if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                                  var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                                  jointSum = jointSum + t;
                              }
                          }
                      }


                  }
              }
          });


          if (sum > 0 || jointSum > 0) {
              totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2)).toFixed();

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.Propertiestotal.find((y: any) => y.owner === owner) != null) {
              this.Propertiestotal[this.Propertiestotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Propertiestotal.push(total);
          }
      }

  }

    //Optimized Property Function

  private calculateTotalRentOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.PropertiestotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Rent";

          let sum: number = 0;


          this.PropertiesValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.rentValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.rentValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.PropertiestotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.PropertiestotalOptimized[this.PropertiestotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.PropertiestotalOptimized.push(total);
          }
      }


  }
  private calculateTotalSaleProceedsOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.PropertiestotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Property";

          let sum: number = 0;
          this.PropertiesValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.PropertySaleValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.PropertySaleValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.PropertiestotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.PropertiestotalOptimized[this.PropertiestotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.PropertiestotalOptimized.push(total);
          }
      }
  }
  private calculateTotalPropertyExpensesOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.PropertiestotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Property";

          let sum: number = 0;


          this.PropertiesValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.expensesValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.expensesValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.PropertiesValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner" || x.type == "Joint") {
                  if (x.PropertyPurchaseValues[this.clientDetails.startDate + i] != "-") {
                      var p = parseInt(x.PropertyPurchaseValues[this.clientDetails.startDate + i]);
                      sum = sum + p;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.PropertiestotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.PropertiestotalOptimized[this.PropertiestotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.PropertiestotalOptimized.push(total);
          }
      }
  }
  private calculateInvestmentPropertyExpensesOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.PropertiestotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Investment property expenses";

          let sum: number = 0;
          let jointSum: number = 0;

          this.PropertiesValueOptimized.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.expensesValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.expensesValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });

          this.PropertiesValueOptimized.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.expensesValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.expensesValues[this.clientDetails.startDate + i]);
                      jointSum = jointSum + t;
                  }
              }
          });


          totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2)).toFixed();

          total["values"] = totalVal;

          if (this.PropertiestotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.PropertiestotalOptimized[this.PropertiestotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.PropertiestotalOptimized.push(total);
          }
      }

  }
  private calculateRealizedCGPOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.PropertiestotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Properties";

          let sum: number = 0;
          let jointSum: number = 0;

          this.PropertiesValueOptimized.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.startDateType == "Existing") {
                      if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                          var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                          sum = sum + (t / 2);
                      }
                  }
                  else {
                      //Verify
                      if ((this.clientDetails.startDate + i) - Number(x.propPurchase) > 1) {
                          if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                              var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                              sum = sum + (t / 2);
                          }
                      }
                      else {
                          if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                              var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                              sum = sum + t;
                          }
                      }
                  }
              }
          });

          //TODO : Decimal Value ?
          this.PropertiesValueOptimized.forEach((x: any) => {
              if (x.type == "Joint") {
                  if (x.type == filter) {
                      if (x.startDateType == "Existing") {
                          if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                              var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                              jointSum = jointSum + (t / 2);
                          }
                      }
                      else {
                          if ((this.clientDetails.startDate + i) - Number(x.propPurchase) > 1) {
                              if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                                  var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                                  jointSum = jointSum + (t / 2);
                              }
                          }
                          else {
                              if (x.realCGValues[this.clientDetails.startDate + i] != "-") {
                                  var t = parseInt(x.realCGValues[this.clientDetails.startDate + i]);
                                  jointSum = jointSum + t;
                              }
                          }
                      }


                  }
              }
          });


          if (sum > 0 || jointSum > 0) {
              totalVal[this.clientDetails.startDate + i] = (sum + (jointSum / 2)).toFixed();

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.PropertiestotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.PropertiestotalOptimized[this.PropertiestotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.PropertiestotalOptimized.push(total);
          }
      }

  }
    //Pension Function
  private calculateTotalPensionIncome(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Pensiontotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Pension Income";

          let sum: number = 0;
          this.PensionValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner") {
                  if (x.pensionIncomeValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.pensionIncomeValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.Pensiontotal.find((y: any) => y.owner === owner) != null) {
              this.Pensiontotal[this.Pensiontotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Pensiontotal.push(total);
          }
      }
  }
  private calculatePensionIncomeTaxable(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Pensiontotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Pension Income - Taxable";

          let sum: number = 0;
          this.PensionValue.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.pITaxAssessableValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.pITaxAssessableValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });
          totalVal[this.clientDetails.startDate + i] = sum.toFixed();
          total["values"] = totalVal;

          if (this.Pensiontotal.find((y: any) => y.owner === owner) != null) {
              this.Pensiontotal[this.Pensiontotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Pensiontotal.push(total);
          }
      }

  }
  private calculateSuperIncomeTaxOffset(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Pensiontotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Super income streams tax offset";

          let sum: number = 0;
          this.PensionValue.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.pITaxAssessableValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.pITaxAssessableValues[this.clientDetails.startDate + i]) * (15/100);
                      sum = sum + t;
                  }
              }
          });
          totalVal[this.clientDetails.startDate + i] = sum.toFixed();
          total["values"] = totalVal;

          if (this.Pensiontotal.find((y: any) => y.owner === owner) != null) {
              this.Pensiontotal[this.Pensiontotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Pensiontotal.push(total);
          }
      }

  }
  //Pension Function Optimized
  private calculateTotalPensionIncomeOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.PensiontotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Pension Income";

          let sum: number = 0;
          this.PensionValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner") {
                  if (x.pensionIncomeValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.pensionIncomeValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.PensiontotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.PensiontotalOptimized[this.PensiontotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.PensiontotalOptimized.push(total);
          }
      }
  }
  private calculatePensionIncomeTaxableOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.PensiontotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Pension Income - Taxable";

          let sum: number = 0;
          this.PensionValueOptimized.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.pITaxAssessableValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.pITaxAssessableValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });
          totalVal[this.clientDetails.startDate + i] = sum.toFixed();
          total["values"] = totalVal;

          if (this.PensiontotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.PensiontotalOptimized[this.PensiontotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.PensiontotalOptimized.push(total);
          }
      }

  }
  private calculateSuperIncomeTaxOffsetOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.PensiontotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Super income streams tax offset";

          let sum: number = 0;
          this.PensionValueOptimized.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.pITaxAssessableValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.pITaxAssessableValues[this.clientDetails.startDate + i]) * (15 / 100);
                      sum = sum + t;
                  }
              }
          });
          totalVal[this.clientDetails.startDate + i] = sum.toFixed();
          total["values"] = totalVal;

          if (this.PensiontotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.PensiontotalOptimized[this.PensiontotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.PensiontotalOptimized.push(total);
          }
      }

  }

  // Super Function 

  private calculateTotalLumpSumWithdrawals(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Supertotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Super Lump Sum Withdrawals";

          let sum: number = 0;
          this.SuperValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner") {
                  if (x.lumpSumValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.lumpSumValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.Supertotal.find((y: any) => y.owner === owner) != null) {
              this.Supertotal[this.Supertotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Supertotal.push(total);
          }
      }
  }
  private calculateTotalSalarySacrificeContribution(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Supertotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Salary Sacrifice Contributions";

          let sum: number = 0;
          this.SuperValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner") {
                  if (x.ssContrValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.ssContrValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.Supertotal.find((y: any) => y.owner === owner) != null) {
              this.Supertotal[this.Supertotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Supertotal.push(total);
          }
      }
  }
  private calculateTotalPNCContibution(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Supertotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
      total["owner"] = owner;
      total["name"] = "Personal Non-Concessional Contributions";
     
          let sum: number = 0;
          this.SuperValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner") {
                  if (x.pncContrValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.pncContrValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.Supertotal.find((y: any) => y.owner === owner) != null) {
              this.Supertotal[this.Supertotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Supertotal.push(total);
          }
      }
  }
  private calculateTotalSpouseContibution(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Supertotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Spouse Contributions";

          let sum: number = 0;
          this.SuperValue.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner") {
                  if (x.spouseContrValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.spouseContrValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.Supertotal.find((y: any) => y.owner === owner) != null) {
              this.Supertotal[this.Supertotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Supertotal.push(total);
          }
      }
  }
  private calculateSalarySacrificeTax(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Supertotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Salary Sacrifice / Personal Deductible";

          let sum: number = 0;
          this.SuperValue.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.ssContrValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.ssContrValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });



          totalVal[this.clientDetails.startDate + i] = sum.toFixed();

          total["values"] = totalVal;

          if (this.Supertotal.find((y: any) => y.owner === owner) != null) {
              this.Supertotal[this.Supertotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Supertotal.push(total);
          }
      }

  } //Done
  private calculateLumpSumTax(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.Supertotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Super Lump Sum Withdrawal";

          let sum: number = 0;
          this.SuperValue.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.lumpSumTaxableValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.lumpSumTaxableValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });
          totalVal[this.clientDetails.startDate + i] = sum.toFixed();
          total["values"] = totalVal;

          if (this.Supertotal.find((y: any) => y.owner === owner) != null) {
              this.Supertotal[this.Supertotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.Supertotal.push(total);
          }
      }

  }

  // Super Function Optimized

  private calculateTotalLumpSumWithdrawalsOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.SupertotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Super Lump Sum Withdrawals";

          let sum: number = 0;
          this.SuperValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner") {
                  if (x.lumpSumValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.lumpSumValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.SupertotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.SupertotalOptimized[this.SupertotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.SupertotalOptimized.push(total);
          }
      }
  }
  private calculateTotalSalarySacrificeContributionOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.SupertotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Salary Sacrifice Contributions";

          let sum: number = 0;
          this.SuperValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner") {
                  if (x.ssContrValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.ssContrValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.SupertotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.SupertotalOptimized[this.SupertotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.SupertotalOptimized.push(total);
          }
      }
  }
  private calculateTotalPNCContibutionOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.SupertotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Personal Non-Concessional Contributions";

          let sum: number = 0;
          this.SuperValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner") {
                  if (x.pncContrValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.pncContrValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.SupertotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.SupertotalOptimized[this.SupertotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.SupertotalOptimized.push(total);
          }
      }
  }
  private calculateTotalSpouseContibutionOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.SupertotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Spouse Contributions";

          let sum: number = 0;
          this.SuperValueOptimized.forEach((x: any) => {
              if (x.type == "Client" || x.type == "Partner") {
                  if (x.spouseContrValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.spouseContrValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.SupertotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.SupertotalOptimized[this.SupertotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.SupertotalOptimized.push(total);
          }
      }
  }
  private calculateSalarySacrificeTaxOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.SupertotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Salary Sacrifice / Personal Deductible";

          let sum: number = 0;
          this.SuperValueOptimized.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.ssContrValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.ssContrValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });



          totalVal[this.clientDetails.startDate + i] = sum.toFixed();

          total["values"] = totalVal;

          if (this.SupertotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.SupertotalOptimized[this.SupertotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.SupertotalOptimized.push(total);
          }
      }

  } //Done
  private calculateLumpSumTaxOptimized(owner: string, filter: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.SupertotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Super Lump Sum Withdrawal";

          let sum: number = 0;
          this.SuperValueOptimized.forEach((x: any) => {
              if (x.type == filter) {
                  if (x.lumpSumTaxableValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.lumpSumTaxableValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });
          totalVal[this.clientDetails.startDate + i] = sum.toFixed();
          total["values"] = totalVal;

          if (this.SupertotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.SupertotalOptimized[this.SupertotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.SupertotalOptimized.push(total);
          }
      }

  }

    //Lifestyle Function

  private calculateTotalLASaleProceeds(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.LATotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Lifestyle Assets";

          let sum: number = 0;
          this.lifestyles.forEach((x: any) => {
              if (x.owner == "Client" || x.owner == "Partner" || x.owner == "Joint") {
                  if (x.saleOfAssetValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.saleOfAssetValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.LATotal.find((y: any) => y.owner === owner) != null) {
              this.LATotal[this.LATotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.LATotal.push(total);
          }
      }
  }
  private calculateTotalLAPropertyExpenses(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.LATotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Lifestyle Assets";

          let sum: number = 0;

          this.lifestyles.forEach((x: any) => {
              if (x.owner == "Client" || x.owner == "Partner" || x.owner == "Joint") {
                  if (x.purchaseOfAssetValues[this.clientDetails.startDate + i] != "-") {
                      var p = parseInt(x.purchaseOfAssetValues[this.clientDetails.startDate + i]);
                      sum = sum + p;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.LATotal.find((y: any) => y.owner === owner) != null) {
              this.LATotal[this.LATotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.LATotal.push(total);
          }
      }
  }

  private calculateTotalLASaleProceedsOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.LATotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Lifestyle Assets";

          let sum: number = 0;
          this.lifestylesOptimized.forEach((x: any) => {
              if (x.owner == "Client" || x.owner == "Partner" || x.owner == "Joint") {
                  if (x.saleOfAssetValues[this.clientDetails.startDate + i] != "-") {
                      var t = parseInt(x.saleOfAssetValues[this.clientDetails.startDate + i]);
                      sum = sum + t;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.LATotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.LATotalOptimized[this.LATotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.LATotalOptimized.push(total);
          }
      }
  }
  private calculateTotalLAPropertyExpensesOptimized(owner: string, iVal: number) {
      for (var i = 0; i <= iVal; i++) {
          var total = this.LATotalOptimized.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }
          total["owner"] = owner;
          total["name"] = "Lifestyle Assets";

          let sum: number = 0;

          this.lifestylesOptimized.forEach((x: any) => {
              if (x.owner == "Client" || x.owner == "Partner" || x.owner == "Joint") {
                  if (x.purchaseOfAssetValues[this.clientDetails.startDate + i] != "-") {
                      var p = parseInt(x.purchaseOfAssetValues[this.clientDetails.startDate + i]);
                      sum = sum + p;
                  }
              }
          });


          if (sum > 0) {
              totalVal[this.clientDetails.startDate + i] = sum;

          } else {
              totalVal[this.clientDetails.startDate + i] = 0;
          }
          total["values"] = totalVal;

          if (this.LATotalOptimized.find((y: any) => y.owner === owner) != null) {
              this.LATotalOptimized[this.LATotalOptimized.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.LATotalOptimized.push(total);
          }
      }
  }
  //Centrelink Functions

  private calculateEligiblePeriod(owner: string, filter: string, iVal: number) {

      for (var i = 0; i <= iVal; i++) {
          var total = this.CentrelinkTotal.find((y: any) => y.owner === owner);
          var totalVal: any = {};
          if (total == null) {
              total = {};
          }
          else {
              totalVal = total.values;
          }

          total["owner"] = owner;
          total["name"] = "Period of Eligibility";

          let eligiblePeriod: number = 0;
          var eligibleDays: number = 0;

          if (filter == "Client") {

               var qualifyingAge: number = 0;
              var currentAge: number = Number(this.clientAge + iVal);
              var qualifying = this.qualifyingAge.sort((a: any, b: any) => a.dob - b.dob);

              //var currentYear = this.clientDetails.startDate + i;
              //var pAge: number = 0;
              //var minRate: number = 0;

              for (var k = 0; k < qualifying.length; k++) {

                  if ((k == (qualifying.length - 1)) && (this.clientDetails.clientDob >= qualifying[k].dob)) {
                      qualifyingAge = qualifying[k].age;

                  }
                  else if (k == 0 && ((this.clientDetails.clientDob) <= qualifying[k].dob)) {
                      qualifyingAge = qualifying[k].age;
                      break;

                  }
                  else if ((this.clientDetails.clientDob) > qualifying[k].dob && (this.clientDetails.clientDob) <= qualifying[k + 1].dob) {
                      qualifyingAge = qualifying[k + 1].age;
                      break;

                  }
              }

              if ((Number(qualifyingAge) - Number(currentAge)) >= 0 && (Number(qualifyingAge) - Number(currentAge)) <= 1) {

                  if (Number(this.clientDetails.clientDob.getMonth) >= 7 && Number(this.clientDetails.clientDob.getMonth) <= 12) {
                      var date1 = new Date("7/01/ " + this.clientDetails.startDate + iVal);
                      var date2 = new Date(this.clientDetails.clientDob.getDate + "/" + this.clientDetails.clientDob.getMonth + "/" + this.clientDetails.startDate + iVal);
                      var timeDiff = Math.abs(date2.getTime() - date1.getTime());
                      var diffDays = (Math.ceil(timeDiff / (1000 * 3600 * 24))) / 365;
                      eligibleDays = diffDays;
                  }
                  else {
                      var date1 = new Date("7/01/ " + this.clientDetails.startDate + iVal);
                      var date2 = new Date(this.clientDetails.clientDob.getDate + "/" + this.clientDetails.clientDob.getMonth + "/" + this.clientDetails.startDate + iVal + 1);
                      var timeDiff = Math.abs(date2.getTime() - date1.getTime());
                      var diffDays = (Math.ceil(timeDiff / (1000 * 3600 * 24))) / 365;
                      eligibleDays = diffDays;
                  }
              }

          }
          else {
              var qualifyingAge: number = 0;
              var currentAge: number = Number(this.partnerAge + iVal);
              var qualifying = this.qualifyingAge.sort((a: any, b: any) => a.dob - b.dob);
              
              for (var k = 0; k < qualifying.length; k++) {

                  if ((k == (qualifying.length - 1)) && (this.clientDetails.partnerDob >= qualifying[k].dob)) {
                      qualifyingAge = qualifying[k].age;

                  }
                  else if (k == 0 && ((this.clientDetails.partnerDob) <= qualifying[k].dob)) {
                      qualifyingAge = qualifying[k].age;
                      break;

                  }
                  else if ((this.clientDetails.partnerDob) > qualifying[k].dob && (this.clientDetails.partnerDob) <= qualifying[k + 1].dob) {
                      qualifyingAge = qualifying[k + 1].age;
                      break;

                  }
              }

              if ((Number(qualifyingAge) - Number(currentAge)) >= 0 && (Number(qualifyingAge) - Number(currentAge)) <= 1) {

                  if (Number(this.clientDetails.partnerDob.getMonth) >= 7 && Number(this.clientDetails.partnerDob.getMonth) <= 12) {
                      var date1 = new Date("7/01/ " + this.clientDetails.startDate + iVal);
                      var date2 = new Date(this.clientDetails.partnerDob.getDate + "/" + this.clientDetails.partnerDob.getMonth + "/" + this.clientDetails.startDate + iVal);
                      var timeDiff = Math.abs(date2.getTime() - date1.getTime());
                      var diffDays = (Math.ceil(timeDiff / (1000 * 3600 * 24))) / 365;
                      eligibleDays = diffDays;
                  }
                  else {
                      var date1 = new Date("7/01/ " + this.clientDetails.startDate + iVal);
                      var date2 = new Date(this.clientDetails.partnerDob.getDate + "/" + this.clientDetails.partnerDob.getMonth + "/" + this.clientDetails.startDate + iVal + 1);
                      var timeDiff = Math.abs(date2.getTime() - date1.getTime());
                      var diffDays = (Math.ceil(timeDiff / (1000 * 3600 * 24))) / 365;
                      eligibleDays = diffDays;
                  }
              }
          }


          if (eligibleDays != 0) {
              var date1 = new Date("7/01/ " + this.clientDetails.startDate + iVal);
              var date2 = new Date("7/01/ " + this.clientDetails.startDate + iVal + 1);
              var timeDiff = Math.abs(date2.getTime() - date1.getTime());
              var diffDays = (Math.ceil(timeDiff / (1000 * 3600 * 24))) / 365;
              eligiblePeriod = eligibleDays / diffDays;
          }
      
         

          if (eligiblePeriod > 0) {
              totalVal[this.clientDetails.startDate + i] = eligiblePeriod;
          } else {
              totalVal[this.clientDetails.startDate + i] = 0.00;
          }
          total["values"] = totalVal;

          if (this.CentrelinkTotal.find((y: any) => y.owner === owner) != null) {
              this.CentrelinkTotal[this.CentrelinkTotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.CentrelinkTotal.push(total);
          }
      }
  }
  private calculateTotalAssessableAssets(owner: string, filter: string, iVal: number) {

      for (var i = 0; i <= iVal; i++) {
          var total = this.CentrelinkTotal.find((y: any) => y.owner === owner);
          var financialInvestment: any = {};
          var realEstate: any = {};
          var supperannuation: any = {};
          var pension: any = {};
          var lifestyleAssets: any = {};


          if (total == null) {
              total = {};
          }
          else {
              financialInvestment = total.financialInvestmentValues;
              realEstate = total.realEstateValues;
              supperannuation = total.supperannuationValues;
              pension = total.pensionValues;
              lifestyleAssets = total.lifestyleAssetsValues;

          }

          total["owner"] = owner;
          total["name"] = "Total Assessable  Assets";

          let financialInvestmentSum: number = 0;
          let realEstateSum: number = 0;
          let supperannuationSum: number = 0;
          let pensionSum: number = 0;
          let lifestyleAssetsSum: number = 0;

         

          total["financialInvestmentValues"] = financialInvestment;
          total["realEstateValues"] = realEstate;
          total["supperannuationValues"] = supperannuation;
          total["pensionValues"] = pension;
          total["lifestyleAssetsValues"] = lifestyleAssets;        

          if (this.CentrelinkTotal.find((y: any) => y.owner === owner) != null) {
              this.CentrelinkTotal[this.CentrelinkTotal.findIndex((c: any) => c.owner === owner)] = total;
          }
          else {
              this.CentrelinkTotal.push(total);
          }
      }
  }

  //Routing
    onPreviousCF() {
        this.router.navigate(['counter/current-position']);
    }

    onNextCF() {
        this.router.navigate(['counter/current-projections/tax']);
    }

    onPreviousTX() {
        this.router.navigate(['counter/current-projections/cashflow']);
    }

    onNextTX() {
        this.router.navigate(['counter/current-projections/financialAssets']);
    }

    onPreviousFA() {
        this.router.navigate(['counter/current-projections/tax']);
    }

    onNextFA() {
        this.router.navigate(['counter/current-projections/liabilities']);
    }


    onPreviousLB() {
        this.router.navigate(['counter/current-projections/financialAssets']);
    }

    onNextLB() {
        this.router.navigate(['counter/current-projections/strategyOptimizer']);
    }

    onPreviousSO() {
        this.router.navigate(['counter/current-projections/liabilities']);
    }

    onNextSO() {
        this.router.navigate(['counter/current-projections/proposedcashflow']);
    }

    onPreviousPCF() {
        this.router.navigate(['counter/current-projections/strategyOptimizer']);
    }

    onNextPCF() {
        this.router.navigate(['counter/current-projections/proposedtax']);
    }

    onPreviousPTX() {
        this.router.navigate(['counter/current-projections/proposedcashflow']);
    }

    onNextPTX() {
        this.router.navigate(['counter/current-projections/proposedFinancialAssets']);
    }

    onPreviousPFA() {
        this.router.navigate(['counter/current-projections/proposedtax']);
    }

    onNextPFA() {
        this.router.navigate(['counter/current-projections/liabilitiesProposed']);
    }

    onPreviousPLB() {
        this.router.navigate(['counter/current-projections/proposedFinancialAssets']);
    }
}

